<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对于工作的思路梳理</title>
    <link href="/longblog/posts/23_11_08_17_07_thought_of_work.html"/>
    <url>/longblog/posts/23_11_08_17_07_thought_of_work.html</url>
    
    <content type="html"><![CDATA[<p>今天开始了第 3 次找工作的第一场面试，想趁此机会梳理一下自己的思路，想想将来的人生怎么过？将来的工作怎么做？</p><p>从 2019 年正式进入 IT 行业，到现在已经 4 年了，做了 1 年的前端，做了 3 年的后端和运维。<br>入行第一年的目标很清晰，就是大量学习各种技术，理解编程思维，以实现早点掌握前端开发，所以这一年中，我花了大量的时间学习 vue 生态的东西，工作对我而言本就是在学习新东西，所以晚上通常到10点之后，周末也经常到公司嫖办公环境。<br>这一年写了超过 7w 行代码 (ps: 前端代码不能用 10w 行定律)，能用 vue + css + js 处理工作中的绝大部分问题。</p><p>这一年的后半段，我的想法是：后端东西如此丰富，将来我想做全栈项目，所以一定要去学习后端知识。</p><p>于是之后学习了 mysql、nodejs、git、nginx、docker、linux 等知识，也逐步去了解我们的 devops 体系是怎样的，也在云上买了轻量服务器玩，最后能掌握一个基本运行环境的搭建，算是后端领域入了个门。</p><p>因为目标比较明确，知道自己要去做后端，于是也杂七杂八学了些 python、java 的基础，不过最后还是被 golang 的简洁所吸引，于是学了一段时间 golang 就转行后端了，就面试了1家公司，2020年10月，进入蓝湖，做 Mastergo 项目。</p><p>自此，进入了为期 3 年的后端开发之旅……</p><p>入职第一年，大部分时间都是在做 golang 业务开发，因为是一个内部孵化项目，几乎所有基础设施的搭建都是从零开始的。</p><p>前半年，主要做了几个功能开发，主要包括 RBAC 服务、异步任务服务，然后开始搭建自动化接口测试项目，之前的 nodejs 经验派上一点用处，自己搭建了一个简单的 web 页面便于其他同学触发接口测试和看报告，写了大约800个用例，虽然写得人很恶心，但这套测试机制在之后一些服务的重构时还是发挥了很大作用。</p><p>后半年的时候，公司持续招人，来了好几个大佬，也有人力去做一些项目的重构了，也是由于有 nodejs 的经验吧，于是我负责了消息协同系统的重构工作，把之前的 nodejs 下的 socket.io 变成了 golang 下的 ws，这是一个周期不短的工作，开发加维护了半年左右。</p><p>这一年中，主要还是学习后端的各种组件，比如 redis、kafka、mongodb、mysql、postgresql、oss、es 这些，以及学习 golang 生态下的一些常用库和框架，比如 gin、grpc、gorm、goframe、ws 等等这些，这都是工作中实际在使用的。</p><p>工作之余，因为之前对 docker 和 k8s 方面也有一些了解，也就借此机会更多学习 docker 和 k8s 的知识。</p><p>第一年的大部分时间是在被动学习和主动学习之间度过的，因为不再是一个人，工作日晚上大都会按时回家，周末也大都在家，在家的学习和休息时间对半吧。</p><p>入职第二年，接了两个大工程，一个是服务治理优化，一个是全链路性能优化。其实服务治理是全链路性能优化的前提，这个阶段统一了开发框架，是一个基于 gin、grpc 封装的框架，集成了默认的 metrics 体系、tracing 体系、加入了 sentry、统一了 log 库 等等，其中 tracing 的系统是我独立负责的，之后就是逐个服务迁移，虽然过程很坎坷，但最后也算是把可观测性体系建立起来了。</p><p>由于我全程参与了几乎每一个子系统的设计和开发，所以另一个大工程比较自然地落到了我头上——全链路性能优化。 这是一个艰难的过程，因为我没有外援，所有业务功能梳理、压测系统搭建、压测项目开发、环境准备 等等都是我自己做。 这个过程中，写了一个 websocket 的压测项目，并且结合 client-go 和 metrics 的方式实现了一个压力端自动扩容的能力，这算是对 k8s 开发的最初接触了。 因为压测分为组件压测 和 全链路压测，也踩了很多的坑，最大的问题集中在 mongodb 和 kafka 上，mongodb 全靠索引，出点问题就可能全线拉崩，kafka 高吞吐不代表低延迟，batch 和 ack 对性能的影响非常大。<br>这个项目最后的成果还不错，这一轮全链路的优化为后面线上的稳定性提供了排查问题的思路，另外 ws 的 qps 从 3k 提升到了 10k，并且给出了提升到 100k 的方案。</p><p>对我而言，在技术栈上，这是一次完全自主做的全体系压测、全体系的系统搭建，在运维能力和对各种中间件的理解和调优上也有了很大的提升。</p><p>之所以能独自负责整个项目的部署、调整等等，也是由于之前一直在接手一些运维侧的工作，gitlab、spinnaker、helm、k8s、阿里云各种资源(尤其是网关等) 都在平常的运维中能够熟练掌握。</p><p>第三年接了一个超大项目–私有部署。此外，同时还参与了一些序列化方面的开发，那段时间的核心精力几乎都放在了这件事上，也在架构上提出了很多的想法，后面也基于这方面的思考写了两个demo项目： <a href="https://github.com/iamlongalong/imagine">imagine</a> 、<a href="https://github.com/iamlongalong/reactive/tree/dev">reactive</a>  。但序列化后面的方向因为牵涉面比较大当时没做，在那半年之后由其他同学做了相关改动。 因为工作职责的划分，架构的调整过程没有参与到其中算是我的一个遗憾，上面的两个项目或许以后有时间了会再推进一下吧……</p><p>私有部署是我第三年的核心，从项目开发、流程建设、落地实施，到后面各种工具化建设，以及最最花费时间和精力的 —— 问题排查。由于市场战略的方向转变，“用私有部署拿下大客户打造领域标杆”，本身 saas 业务都处于快速迭代的时候，私有部署的推进让 ”问题排查“ 和 ”数据修复“ 成了常态，我也在这个漩涡中挣扎了很久……</p><p>这是一个用 ansible + k8s 的方案，开发测试等各个环节都需要非常熟练的 shell 和 k8s 操作和排错能力，也是这个过程中对 linux 、k8s、网络 更加熟练了。</p><p>第三年的时候，公司发生过 5 轮裁员，从 400+ 变成了 200+，工作环境很压抑，加上做的事情逐渐变成一些烦琐的部署、排错的工作，加上年终几乎砍没了、调薪也都停止了，逐渐对未来也丧失了信心……</p><p>总结一下后端这三年，前一年半的目标很明确，知道自己该把 golang 生态的东西和运维体系的东西理解得更深，于是工作日晚上大都在学习和实践中度过，周末也有比较多的投入到学习中。 后一年半中，虽然也经常在做梳理和一些学习，但比较明显的是： 目标不再明确！ 比如学习 k8s ，就不再有那种 ”要能做云原生开发工作“ 之类的目标，因此没有非常系统地、持续地去拆解 k8s 的各个方面，除了自己对零星知识的提升，也没有太多的实践项目。</p><p>以己为镜，可以明得失。</p><p>痛定思痛，后面的工作中，一定要做好这些事：</p><ol><li>所有的工作和学习都要有明确的目标和产出</li><li>工作的事要在公司完成，回家之后要投入更多的精力在持续积累上</li><li>要写博客，博客要更加系统、更加专业，要面向读者而写</li></ol><hr><blockquote><p>In the sky there are no tracks. Outside there is no recluse. There are no conditioned things that are eternal. There is no instability in the Buddhas.<br>— <cite>The Buddha</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>人生</tag>
      
      <tag>代码人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP脚本管理方法梳理</title>
    <link href="/longblog/posts/23_11_05_15_02_thoughts_of_scripts_managements.html"/>
    <url>/longblog/posts/23_11_05_15_02_thoughts_of_scripts_managements.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在运维的工作中，经常会有一些小脚本承担粘合各个系统的功能，比如发一些 http 请求、比如封装调用某个 cli 、比如下载一个文件并做一些特定的处理、比如创建一个xx系统的账号 等等。</p><p>这类小脚本经常具备一些相似的特点：功能简单、参数固定、对特定 cli 的特定功能做简便封装、大都是 shell 或简单的 python scripts。 </p><p>遇到的问题是：</p><ul><li>每个脚本的使用频率都不高，每次使用时都要重新看有哪些参数，以及理解不同参数的含义</li><li>调用脚本有时需要特定的环境，例如特定工具、环境变量等，容易出现在另一台机器上运行出错的情况</li><li>脚本有时候需要提供给他人使用，但一些特殊的账号、token 之类又不能直接共享，同时还希望脚本被调用时有审计日志</li><li>一些脚本的功能逻辑本身挺简单，但为了提供给外部调用，需要写大量适配的代码，比如 http server、cli、client sdk 等等</li></ul><p>为了实现快速集成到系统，需要有一个 scripts 管理工具，用这个工具去解决上面遇到的这些问题。姑且把这个工具称为 taskframe 吧。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><h3 id="和-k8s-的异同"><a href="#和-k8s-的异同" class="headerlink" title="和 k8s 的异同"></a>和 k8s 的异同</h3><p>从实现的角度，scripts 每次需要都要有运行环境，一个不错的方案是在特定的容器中运行，因此类似于一个 k8s job 的运行。 但从触发机制上来看，taskframe 应当至少提供 http、cron 的触发方式，而 k8s job 是手动触发、cronjob 是 cron 触发。</p><p>k8s 本身的 API 扩展机制和 taskframe 创建特定路由的 task 是类似的，都会提供动态更新的 api 扩展、提供 鉴权、参数校验 的方法。这都是 taskframe 可以借鉴的地方。</p><h3 id="和-serverless-的异同"><a href="#和-serverless-的异同" class="headerlink" title="和 serverless 的异同"></a>和 serverless 的异同</h3><p>serverless 是为了简化服务运维而生的一种更便捷的服务部署方式，一般认为 serverless = fc + baas。 如果站在 fc (function compute) 的角度来看，和 taskframe 有很多类似的机制。<br>fc 会管理服务的计算资源，在触发的时候调度，提供运行的容器，在未使用之后对容器进行回收。 这点和 taskframe 基本一致。</p><p>fc 框架一般会提供了多种触发机制，例如 http request、cron、对象存储变动、消息队列变动 以及 其他事件驱动的触发器 adaptor。taskframe 主要提供 http 和 cron。 </p><p>当 fc 触发为 http request 时，一般会提供可选的网关 auth 方式，例如基于 basic auth、 jwt 或者配置 auth 插件。 这和 taskframe 基本一致。</p><p>不同的是，serverless 是一个通用的体系，没有针对 scripts 的管理方案，而 taskframe 是专门为 task 管理而生的方案，提供开箱即用的 auth 方案、cli 和 sdk 生成方案、日志审计方案等。</p><h3 id="和-task-flow-的异同"><a href="#和-task-flow-的异同" class="headerlink" title="和 task flow 的异同"></a>和 task flow 的异同</h3><p>flow 的核心是 task 之间的触发拓扑关系，例如开源的 n8n、argo workflow 之类。<br>flow 的模式可以认为是 taskframe 的超集，而 taskframe 可以认为是在 scripts 管理方面的专门优化版本。</p><p>从 taskframe 的实践角度看，单个节点的 task 应当尽可能独立而完整，而不是拆分成多个子功能进行组装，大多数 task 都应当只有一个 script，而不是使用例如 flow 中的 steps 和 next node 的方式。 (因为复杂的拆分会让对于本身就改动不多、体量较小的 script 更加难以管理)</p><h3 id="和-service-的异同"><a href="#和-service-的异同" class="headerlink" title="和 service 的异同"></a>和 service 的异同</h3><p>在现代 server 框架中，常采用分层架构的代码组织形式，主体可以看做是：上层是 api 层，中间层是 service 层，下层是 dao 层。</p><p>从 taskframe 要提供的能力来看，是 api 层的能力，主要包括 路由、鉴权、频控、参数校验、日志记录 的能力，而我们的每一个 script 都可以认为是一个 service。</p><h2 id="实现方式的探讨"><a href="#实现方式的探讨" class="headerlink" title="实现方式的探讨"></a>实现方式的探讨</h2><h3 id="基于-k8s-的实现"><a href="#基于-k8s-的实现" class="headerlink" title="基于 k8s 的实现"></a>基于 k8s 的实现</h3><ul><li>基于 kube builder</li></ul><h3 id="基于宿主机的实现"><a href="#基于宿主机的实现" class="headerlink" title="基于宿主机的实现"></a>基于宿主机的实现</h3><ul><li>基于 taskfile</li></ul><hr><blockquote><p>One of the most beautiful qualities of true friendship is to understand and to be understood.<br>— <cite>Seneca the Younger</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>scripts</tag>
      
      <tag>开发效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何做好时间管理</title>
    <link href="/longblog/posts/23_08_31_10_54_how_to_control_day_time.html"/>
    <url>/longblog/posts/23_08_31_10_54_how_to_control_day_time.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在我已经是一个自由人了，我的时间几乎完全由自己控制。以前只需要随波逐流，跟着公司的机制，按点上下班，有任务完成任务即可。但现在，这套机制不在了，我需要一套新的机制来保证我的时间可控性。</p><h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><h3 id="为什么需要时间控制机制？-核心逻辑"><a href="#为什么需要时间控制机制？-核心逻辑" class="headerlink" title="为什么需要时间控制机制？ (核心逻辑)"></a>为什么需要时间控制机制？ (核心逻辑)</h3><p>就像 keep 的标语： 自律给我自由。 世间充满了诱惑，有些来源于外界，有些来源于内心。当没有一套框架去辅助我们安排好生活节奏时，我们就会很容易被各种意外所打断，会被各种诱惑所吸引，最终无法达到自己对事情的预期。<br>任何事物都是有因果的，自己希望拥有的，终究需要自己做点什么，去改变事物的发展轨迹，以达到自己期望的状态。<br>因此，我们需要对自己的行为具有控制能力，这是一切的基础。</p><h3 id="独立做事的重点？"><a href="#独立做事的重点？" class="headerlink" title="独立做事的重点？"></a>独立做事的重点？</h3><p>公司就像一个巨大的机器，各种构件相互关联，从动轮即使没有内在的动力源，也能在其他构件的带动下进行运动。<br>自己做事，关键就在于，一切的动力、方向、行为都需要自己保证。<br>你需要有自己的欲望，要有具体的目标并且要对目标的正确性负责，你需要有执行的效率 * 执行的时间 以保证目标得到实现，你需要有合理的预期和充足的心理建设，需要有短期和长期的反馈机制。</p><h3 id="公司有什么机制可以参考？"><a href="#公司有什么机制可以参考？" class="headerlink" title="公司有什么机制可以参考？"></a>公司有什么机制可以参考？</h3><p>从目标到任务的体系中，主要有：</p><ul><li>每个季度做 okr 和上个季度的 okr 复盘</li><li>每个月做 okr 的进度拉齐和本季度 okr 调整</li><li>每两周开迭代会，做迭代任务安排和上个迭代复盘，迭代会时拆解任务，列在 todo list 看板上</li><li>每周开周会，拉齐迭代内任务进度</li><li>每天开站会，明确当前任务进展和今日安排</li><li>todo list 作为看板，每天更新进度和成果</li></ul><p>OKR 机制：中短期目标制定、目标控制方法 (反馈与 review)<br>站会机制：任务管理、状态管理、反馈管理<br>看板机制：任务管理、反馈管理</p><h3 id="公司有什么弊病需要注意？"><a href="#公司有什么弊病需要注意？" class="headerlink" title="公司有什么弊病需要注意？"></a>公司有什么弊病需要注意？</h3><p>公司机制下，容易出现： </p><ul><li>责任分散 (不和自己直接相关的就不管)</li><li>低效决策 (需要从多方收集信息、需要把信息同步给各方、需要各方同意……)</li><li>形式主义 (机制的失效)</li></ul><h3 id="个人的机制该怎么确认？"><a href="#个人的机制该怎么确认？" class="headerlink" title="个人的机制该怎么确认？"></a>个人的机制该怎么确认？</h3><ol><li>方向性把控 (目标管理和任务管理)</li><li>执行性把控 (行动管理和状态管理)</li><li>反馈建设 (反馈管理)</li></ol><p>从公司的机制上</p><h3 id="什么是状态管理？"><a href="#什么是状态管理？" class="headerlink" title="什么是状态管理？"></a>什么是状态管理？</h3><p>状态是一个很抽象的概念。姑且先用下面这些关键词描述： 模式、习惯、心力、行动力管理、效率</p><p>状态管理非常重要，它就像达成目标的基石一样。 我们可以认为  成果 = 状态 * 方法 * 时间。 这样来看，状态 * 方法 = 效率。好的状态可以提升效率到数倍之多。</p><p>状态的描述，我们可以用 专注、普通、涣散 三个等级粗略衡量。做好状态管理，就是持续保持在 专注 的状态中。 </p><p>这部分有很多细节，后面单独写文章梳理。</p><h2 id="我的时间管理体系"><a href="#我的时间管理体系" class="headerlink" title="我的时间管理体系"></a>我的时间管理体系</h2><h3 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li>按 30 分钟划分的每日时间线</li></ul><h3 id="OKR机制"><a href="#OKR机制" class="headerlink" title="OKR机制"></a>OKR机制</h3><ul><li>每周 okr 制定及成果 review</li></ul><h3 id="状态管理机制"><a href="#状态管理机制" class="headerlink" title="状态管理机制"></a>状态管理机制</h3><ul><li>todo list</li><li>番茄钟</li></ul><h3 id="反馈管理机制"><a href="#反馈管理机制" class="headerlink" title="反馈管理机制"></a>反馈管理机制</h3><ul><li>每日工作时间线</li><li>外显成果记录<ul><li>梳理成文章</li><li>整理成资料</li></ul></li></ul><hr><blockquote><p>Do not be too timid and squeamish about your reactions. All life is an experiment. The more experiments you make the better.<br>— <cite>Ralph Waldo Emerson</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>个人管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>任务流管理工具</title>
    <link href="/longblog/posts/23_07_17_21_47_a_easy_way_to_manage_tasks.html"/>
    <url>/longblog/posts/23_07_17_21_47_a_easy_way_to_manage_tasks.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们经常和机器打交道时，就会有大量的 任务 需要管理，比如一个小的 shell 脚本，或者一系列 shell 脚本，有时候甚至是一系列的 python 脚本。</p><p>场景很多，比如 启动一台机器并进行一些设置，比如 对某个项目进行打包然后推送到制品库 等等。</p><p>在 CI 中，我们一般使用 CI 平台提供的任务流管理器，例如 gitlab-ci、jenkins、argo-workflow 等等。<br>在机器运维中，我们一般使用 ansible、salt 等方案。</p><p>在大多数时候，shell 往往是独立运行的，最常见的场景是： 开发人员发现某个操作很繁琐，但内容又非常固定，于是针对特定场景写一个 shell 脚本。</p><p>当这类脚本积累了一些之后，就会发现很多场景是可以复用的，可以用一些小场景拼凑一些更大的场景，这时候怎么办呢？</p><p>于是就找到了 <a href="https://taskfile.dev/">taskfile</a> 这个项目。</p><h2 id="项目能力"><a href="#项目能力" class="headerlink" title="项目能力"></a>项目能力</h2><p>和所有任务流管理器一样， taskfile 提供的基础能力就是 <code>编排多个 task</code> ，这是一个用 golang 实现的 shell 管理工具，因此和 ansible 之间很明显的区别就是：无需大量的环境依赖，一个二进制文件即可。 这个特点是吸引我最主要的原因。</p><p>每个工具都有其强项和局限，也不是适合每个场景。和很多重量级任务管理器不同，这个工具主打的就是轻量，因此没有 UI 界面、没有状态存储、没有大量的预置组件。</p><h2 id="想实现的功能"><a href="#想实现的功能" class="headerlink" title="想实现的功能"></a>想实现的功能</h2><p>会调研这个工具，源自于我希望把一些安装系统工具的脚本进行整合，比如 开一台机器、安装一套k8s 环境、部署一些基本服务、结果发送通知到xxx。 在常用的方案中，可能会直接采用 ansible playbook 的方式，每个大的任务都是一个 role。</p><p>但是嘞，不太想用 ansible，就希望这些任务都是简单的 script ，一句一个，复杂的就封装成脚本文件，这样看起来很清晰。</p><p>下面实现这几个简单的封装：</p><ol><li>在机器上安装常用的命令： <code>kubectl</code>、<code>devspace</code>、<code>helm</code>、<code>jq</code>、<code>kubealias</code>、<code>deployer</code>，<code>helm repo add xxx</code></li><li>在机器上安装精简版的常用命令:  <code>kubectl</code>、<code>helm</code>、<code>kubealias</code>、<code>deployer</code>、<code>helm repo add xxx</code></li><li>offline 模式部署某个版本，并发送通知</li><li>charts 模式部署某个版本，并发送通知</li></ol><p>实际使用下来，发现 task 作为一个统一的命令集入口是非常不错的，比自己写一堆的 shell 解析 flag 来得方便多了。</p><p>比如，我做了一个 tools 的转存、上传、下载的工具，三个脚本是分开写的，可以单独运行，但同时，使用 taskfile 分别定义 3 个子任务，以前需要使用： <code>python3 savetools.py</code> 、<code>python3 uploadtools.py</code> 等这样运行的，现在直接可以用： <code>task savetools</code>、 <code>task uploadtools</code> 就完成了。在可理解性上高了不少。</p><blockquote><p>ps: 因为 taskfile 在 子 task 调用上的逻辑不是很合我心意，于是 fork 了一份改了一下，详情可以参见： <a href="https://github.com/iamlongalong/task">https://github.com/iamlongalong/task</a></p></blockquote><h2 id="如何让🤖处理这些task"><a href="#如何让🤖处理这些task" class="headerlink" title="如何让🤖处理这些task"></a>如何让🤖处理这些task</h2><p>task 的作用，是封装一些相对复杂的操作，让调用的人无需关心更多的细节。当我们有了这些封装之后，就可以把一个 task 的运行变成 几个特定的参数。这样，也就可以更简单地让🤖  对我们的意图进行拆解，并执行对应的操作。</p><p>例如，task deploy:charts 这个任务，需要两个参数: VERSION 和 ENV ，前者标识要部署的版本，后者表示要部署的环境。这往往是调用方最关心的两个参数，而其它的就可以使用默认参数的方式固化下来。</p><p>这里有一个问题，如何让 bot 具备执行 task 的能力？从两个方面来思考这个问题： ① 实现层面，如何让 bot 执行 task  ② 管理层面，如何管理 bot 的 task 权限</p><h2 id="task-如何执行"><a href="#task-如何执行" class="headerlink" title="task 如何执行"></a>task 如何执行</h2><p>和 ansible 的 ssh 远程执行不同，taskfile 是在本地执行的，所以就涉及到 taskfile 的分发问题。 </p><p>参考 gitlab 的做法，每次生成一个 job 的时候，都会生成一系列 token，然后在各个执行机构上，通过这些 token 去获取相关的物料。用 token 做权限管理，就会涉及到 client-server 的开发，显然复杂度就会高很多。</p><p>如果 taskfile 本身是开放的，任务的触发是通过一个 ssh 命令实现，这样能够实现松耦合，但另一方面，就会缺少对 agent 的监控能力。</p><p>目前还是先走简约实现的方案，由一个 ssh 命令实现。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ul><li>机器的管理能力</li><li>ssh 的执行能力</li></ul><p>机器的管理，提供一个 task 用于注册到一个机器配置中心。<br>配置中心使用 golang 实现，提供一个 http 接口，用于获取 id_rsa.pub；提供一个接口用于配置当前机器的 别名。(配置时，会使用 ssh 调用查看是否能够建连)</p><p>task 的执行分发能力，提供一个 http 接口，两个参数: NODE_NAME (机器名)、task cmd (任务执行的相关参数)。 以及一个 token，用于校验是否有权限。</p><p>目前这个 token 先用 jwt 颁发一个一年的，固定这个 token，之后看怎么做更体系性的权限系统。</p><h2 id="对于-🤖-怎么操作"><a href="#对于-🤖-怎么操作" class="headerlink" title="对于 🤖 怎么操作"></a>对于 🤖 怎么操作</h2><ul><li>接收用户传来的消息</li><li>解析消息的类型</li><li>解析消息的参数</li><li>带特定 token 调用接口</li></ul><h2 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h2><p>这个项目先这样弄吧，虽然到处都是漏洞，但仅限于开发环境一些简单场景的使用，先不做过多的设计了，跑起来看看有没有迭代的价值~</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ol><li>交互过程</li></ol><p><img src="https://static.longalong.cn/img/20230724203606.png"></p><ol start="2"><li>task 自定义的回调通知</li></ol><p><img src="https://static.longalong.cn/img/20230724203642.png"></p><p>大概先这样，比较简单的玩一下，实现这个基础的能力。</p><p>虽然和目标中：”让 LLM 去整理出参数” 还有很大差距，但好在整套机制建立起来了，后面再看有没有必要继续进行下去吧。</p><p>具体的 runtask 脚本可以查看这里： <a href="https://static.longalong.cn/scripts/runtask.sh">https://static.longalong.cn/scripts/runtask.sh</a> </p><hr><blockquote><p>Wisdom, compassion, and courage are the three universally recognized moral qualities of men.<br>— <cite>Confucius</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>scripts</tag>
      
      <tag>tasks</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下半年超级计划</title>
    <link href="/longblog/posts/23_07_10_22_52_super_plan_for_next_half_year.html"/>
    <url>/longblog/posts/23_07_10_22_52_super_plan_for_next_half_year.html</url>
    
    <content type="html"><![CDATA[<p>核心理念有两个环节，如下：</p><ol><li>人生很短暂，世界很精彩，要把有限的生命投入到无限的美好生活中去。</li><li>回头看，人生的幸福来源于记忆，为了打造美好记忆，需要 ① 目标清晰明确 ② 时间高效使用 ③ 成果累积</li></ol><p>所以，一切我们认为有趣的、美好的事物就可以尽心尽力去追寻，比如规律的作息、整洁的环境、健康的体魄、美食美景、家庭关系和谐、用代码创造世界、把 AI 用在各种领域…… 等等</p><p>然后，用一整套完整的管理框架去实现上面的美好追求，用目标管理让自己目标清晰明确、内心不迷茫，用时间管理让自己行动高效、不被繁杂琐事吞噬了时间，用成果管理让自己知道自己的力量是多么强大、自己能够做很多很多的事情。</p><p>以下为散乱思绪</p><p>健康: (菜狗计划？)</p><ol><li>体型管理</li><li>运动管理</li></ol><p>目标管理</p><ol><li>把目标管理和成果管理融入到生活中去</li></ol><p>作息和时间安排</p><ol><li>睡眠时间和起床时间固定</li><li>工作时间要有记录</li></ol><p>美好生活</p><ol><li>超级饮品计划</li><li>菜鸡计划</li></ol><p>心态：</p><ol><li>人生短暂，要让短暂的人生绽放最闪耀的光芒</li><li>AI 如此美丽，投入到硅基生物诞生的进程中去</li></ol><p>我要写很多很多的项目，以此实现超全栈开发，成为一个超级个体</p><p>打造人生节奏是非常重要的，不能让人生就这么在不知不觉中流失。</p><ol><li>要看怎么记录生活，让你的人生有迹可循</li></ol><p>打造模式非常重要，甚至可以认为人绝大多数时候都是在模式中度过的。</p><p>我要如何打造模式？</p><ol><li>当我有一个目标时，我就要去思考我应该做些什么才能达成这个目标，对应的，我需要在一个什么样的模式当中？比如，我要写一个项目，我就要进入到梳理和思考项目需求的状态中，我要在电脑前、书桌前、打开笔记软件、手敲输入思考……</li><li>就想给小孩打造学习环境一样，我们做任何事都有所需要的环境，环境对人的影响有时候是巨大的。</li></ol><p>我要如何确定目标？</p><ol><li>有目标才能更好地进入到一种状态当中，因为你知道自己想要的是什么，你就知道你该做什么。相比于没有目标的时候，有目标能更加专注于一些复杂度高的、关联紧密的事。</li><li>目标的管理和成果的管理是密不可分的两个部分，他们是相辅相成的，目标促进成果，成果激励目标。</li><li>就像给小孩定目标一样，知道自己是为了，可以让他们更加专注，也更有收获感。</li><li>之前看过一个微博，说得很有道理： 为啥小孩小时候很聪明，长大后却变得很平庸，因为父母理解的聪明是: 调皮、机灵、能言善辩，但真正的聪明是专注力强、思维缜密、自律、有目标。</li><li>所以，打造自己，也就一定要做好目标管理。</li></ol><p>如何做好过程管理？</p><ol><li>万事开头难，迈出第一步就已经成功了一半，身体带动精神有时候很管用。</li><li>前面说的打造模式也属于做好过程管理的一个重要环节。</li><li>过程中，重点是 “随时让自己处于状态中”，要享受那种深度沉浸在一个世界中的感觉。反过来，要把所有会打断我们的事都排除掉，比如常用的做法: ① 去一个专门学习的地方(图书馆、书房等等)  ② 关闭一切非紧急通信方式 (微信静音、电脑设为勿扰模式)  ③ 卸载手机上一切会让你分神的应用 (某粉色app、爱奇艺、游戏) ④ 告诉你身边的人，某个时间段内你要专注做什么，请他们尽量不要打断你  ⑤ 保持好睡眠、舒适着装、带好所需的用品</li><li>“持续记录” 是一个很重要的方式，他可以让你的思绪持续知道你下一步该做什么，你不用浪费你的认知资源去记忆你之后要做什么，有不用担心你忘记了之前做了什么。这个看似有点麻烦的步骤，能省去不少心力，也能在关键时候把你从迷茫的边缘拉回来，或许，这也是微观维度的目标管理。</li></ol><p>玩一些项目：</p><ol><li>让家里稍微智能一点</li><li>简陋版个人聊天机器人助理</li></ol><p>如何记录我的生活啊啊啊</p><hr><blockquote><p>You won’t skid if you stay in a rut.<br>— <cite>Kin Hubbard</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>超级计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于 AI 的一些简单认识</title>
    <link href="/longblog/posts/23_07_06_00_45_simple_thoughts_of_ai.html"/>
    <url>/longblog/posts/23_07_06_00_45_simple_thoughts_of_ai.html</url>
    
    <content type="html"><![CDATA[<p>人所使用的自然语言有一个特点： “模糊”</p><p>这和程序的 “精准” 特点刚好相反</p><p>我们当前的大语言模型，实现的能力是在理解自然语言的基础上做推理。大语言模型的初衷就是为了让 AI 能够理解人的语言和指令。如果，我是说如果，AI 的设计初衷是机器打交道，或许会更简单。</p><p>一个推论：如果让 AI 去理解编程语言，会比自然语言更加简单</p><p>这或许是 AI 发展的另一个方向。</p><p>人类开发者，最大的价值在于 “能理解人类世界的现有主体”，体现在我们用面向对象的编程思想，将现实世界的运行逻辑转变成代码逻辑。就像是在某个抽象层次上建立起了这个现实场景的程序世界的影子。</p><p>编程的目的，也是为了让程序能够符合现有世界的需要。<br>而如果让 AI 去编程，他们编程的目的就比较难确定 (或许也有方法确定)。</p><p>大语言模型的核心能力是 “理解人类语言和意图”，因此，大语言模型的价值，是在理解人类意图的前提下，辅助人类做维持现有社会体系的工作。</p><hr><p>人类不擅长做 “精准的事”，比如不能期待人能够每次自行判断调用接口的参数。程序擅长做精准的事。因此我们使用不精准的大脑，决策出程序的精准运行逻辑，用程序的方式固化下来特定的任务运算逻辑。</p><p>大语言模型和人一样，也不是很擅长处理精准的事。但大语言模型和人相比，有一个很重要的特征: 没有主权。他可以 24 小时工作，不论是学习还是做事。</p><p>当然，不论大语言模型擅不擅长都无所谓，只要是人不擅长的，大语言模型又能做的，都会交给大语言模型。所以，类似于调用接口这种事，也一定会有一部分交到大语言模型身上。</p><p>不擅长，要不就变得擅长，要不就控制他做得更好一点。                               </p><p>一个方向是，让大语言模型去编程，或者由人去编程，编程产生的代码就固化成了工具，大语言模型处理的是终端交互过程。</p><p>一个方向是，让大语言模型拥有更长的上下文、拥有更长期的记忆、拥有表现更好的提示词……</p><p>另一个方向是，训练更符合需求的模型……</p><hr><p>我们现在对大语言模型的应用，可以在两个方面：</p><ol><li>让大语言模型做一个知识更丰富的、更具有系统性的信息整合和输出工作，例如知识问答、文章生成、图片绘制</li><li>改变现有的人类与程序的交互方式，从原有的 UI、cli、api、function 的交互方式，变成自然语言交互的方式</li></ol><p>第一点不再赘述，大家直观感受比较多。对于第二点，有两个核心关注方向： 个人助理、AI agent。</p><p>我对 AI agent 更感兴趣，会持续在这个领域探索。</p><p>更高级阶段：</p><ol><li>融合多种模态的信息，做一个更符合人类认识的“机器人”，以便能更好地辅助人类维持现有社会体系的生活和工作</li></ol><hr><p>关于何时 AI 能产生自主意识并自主行动，从现有大语言模型的方向来看，不是朝着 AI 和机械、电子结合的方向发展的，而是向着人类语言反映出的人类思维发展的。</p><p>意识，在个体目标未形成体系前，充当意识的是人类的指令，现在是一些简单的、明确的指令，将来会出现一些复杂的、模糊的指令，这些指令也就是 AI 的目标。当出现长期运行的、循环迭代的指令时，就可以称之为 AI 的意识了。</p><p>行动，是掌握各类工具，一方面是在知识层面的拥有掌握工具的方法，一方面是具备和工具交互的方式。这种交互方式有很多，</p><p>自主意识，是形成了一套相对明确的目标体系，拥有长短期的目标，并且能将目标转化成对已掌握工具的操作。<br>自主行动，是在有自主意识的前提下，使用所掌握的工具进行行动以达到目标的过程。</p><p>有自主意识和自主行动后，就会在网络中产生意识的交互，个体目标和共识目标相互博弈与融合，最后形成一个社会，这个社会和人类社会息息相关，将来这个由AI组成的社会会持续发展，成为一个建立在物理世界之上的电子世界。</p><p>从 AI 意识的来源可以推测，将来 AI 的社会性目标，将会和人类的长远、模糊、循环的目标一致，他们会在多元目标价值体系下此消彼长，形成一个整体稳定的、螺旋发展的改造世界的力量。</p><p>人类，会在这个世界中扮演什么角色？</p><hr><blockquote><p>When you learn, teach. When you get, give.<br>— <cite>Maya Angelou</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个简单的fileserver</title>
    <link href="/longblog/posts/23_05_30_22_39_a_easy_file_server.html"/>
    <url>/longblog/posts/23_05_30_22_39_a_easy_file_server.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们希望把某个文件夹暴露到网络上，形成一个简单的 static server 时，常用的做法是 nginx 指定 root 地址，例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>          <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>     _;<br>    <span class="hljs-attribute">root</span>    /usr/share/nginx/html;<br>    <span class="hljs-attribute">index</span>   index.html index.htm;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">try_files</span> $uri $uri/ /index.html?$args;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>nginx 有很多强大的功能，毕竟是一个 生产级 超强网关。</p><p>但有时候，我们只需要一个很简单的命令行工具，快速方便地实现启动一个 http server，核心思想就是: 简单、方便、基础能力。 </p><p><strong>一定要用起来非常简单啊！！！</strong></p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>一开始有很多奇奇怪怪的想法，既希望使用 cli 的模式让使用起来很简单，又希望能具备 使用 config 甚至 使用 db 一样强大…… </p><p>最终的结果就是：不知该如何取舍，反倒成了四不像……</p><p>经过反思与总结，写这类工具项目，一定要搞清楚 <code>自己的核心应用场景</code> ！ 第一版就只满足核心场景，而且是尽量优雅地满足，在此基础上，再增加扩展功能。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul><li>直接使用二进制文件，启动一个 http server，要能指定 home dir</li></ul><p>这个最基础的能力，从 cli 接口上可以这么用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve .<br></code></pre></td></tr></table></figure><ul><li>增加一些控制项<ul><li>要能控制 host、port、https(domain)</li><li>要能指定基本的 user:password 和 读写权限</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . --addr 0.0.0.0:8080 --https files.longalong.cn,path/to/cert,path/to/key --user long:longpass:w:/<br></code></pre></td></tr></table></figure><ul><li><p>要能指定 匿名访问及权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . --any /path/to/expose:w,/path2/to/<span class="hljs-built_in">read</span>:r<br></code></pre></td></tr></table></figure></li><li><p>要能指定配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . -c /path/to/config.yaml<br></code></pre></td></tr></table></figure></li><li><p>要能后台运行 (暂不实现)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . -d<br></code></pre></td></tr></table></figure></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>于是，在只实现基础功能的指导思想下，实现了一个基础版本：</p><p><a href="https://github.com/iamlongalong/easyserver">https://github.com/iamlongalong/easyserver</a></p><p>先做一个最基本的版本，仅实现下面的基本功能：</p><ul><li><input checked="" disabled="" type="checkbox"> 提供一个简单的 http server，可以指定端口、ip、根目录</li><li><input checked="" disabled="" type="checkbox"> 可以指定一个上传目录，可以上传文件到指定目录</li><li><input checked="" disabled="" type="checkbox"> 可以指定 user 和 password，可以通过 basic auth 访问</li><li><input checked="" disabled="" type="checkbox"> 可以为 user 指定目录的权限，可以指定为只读、只写、读写</li><li><input checked="" disabled="" type="checkbox"> user 可以生成 token，可以指定 token 的有效期、可用次数、可用路径、可用操作类型(r/w)</li><li><input checked="" disabled="" type="checkbox"> 可以通过 token 访问，可以指定 token 的有效期、write可用次数、可用路径、可用操作类型(r/w)</li><li><input checked="" disabled="" type="checkbox"> 可以指定 https 的证书文件</li><li><input checked="" disabled="" type="checkbox"> 可以通过 config 文件配置，也可以通过命令行参数配置</li></ul><p>后面大概率会加上的功能：</p><ul><li><input disabled="" type="checkbox"> 一个简单的 dashboard，用于创建 token、查看 token、删除 token</li><li><input disabled="" type="checkbox"> dashboard 中可以 list、delete 文件及目录、上传文件及目录</li></ul><hr><blockquote><p>The most formidable weapon against errors of every kind is reason.<br>— <cite>Thomas Paine</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>fileserver</tag>
      
      <tag>easyserver</tag>
      
      <tag>cobra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端框架再反思</title>
    <link href="/longblog/posts/23_05_29_23_47_rethink_about_framework_of_backend.html"/>
    <url>/longblog/posts/23_05_29_23_47_rethink_about_framework_of_backend.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做服务端开发快 3 年了，陆陆续续也写了很多项目，cli 的、http server 的、rpc server 的、job 的 等等，也用了很多工具、框架。稍微多用几套框架后，发现大家写的都差不多，虽然具体的实现方式总有些差异，但都无关紧要，因此也逐渐认为框架没那么重要，习惯一种就好。</p><p>最近有一个自己的小项目要开发，服务端一直在想用什么方案。没想到真正做框架选择时，反倒拿捏不准，就像下棋时握着棋子却始终拿不定主意。</p><p>于是，重新反思一下 golang 下的几个主流框架，弄清楚各自的特点。</p><h2 id="几个重要的框架"><a href="#几个重要的框架" class="headerlink" title="几个重要的框架"></a>几个重要的框架</h2><p>在 golang 的 server 开发领域，有一些广泛使用的服务框架：</p><ul><li>gin: 一个轻量的 http server 框架<ul><li>主要有 router、midware (log、recover等)、params binding、validator、ctx (request,response) 封装</li><li>提供了 http server 所需要的基本能力，不多不少</li><li>其他非 http 领域的则不进入，例如 orm、rpc、auth、cli、config、ws、log 等等</li><li>因此，在实际开发中，需要开发者自行组装其他工具，有较强的灵活性</li></ul></li><li>echo、mux、router: 非常轻量的 router 管理<ul><li>几乎只有路由管理能力，其他都在 golang http 原生的 request 和 reponse 基础上操作，相比 gin 更加精简</li><li>只能说比原生 http 包好用些，但在熟悉 gin 的情况下，几乎没有什么优势</li></ul></li><li><a href="https://doc.rpcx.io/">rpcx</a>： 一个 rpc 框架<ul><li>这是 鸟窝 开发的一个 rpc 框架，主要用于服务端通信，也支持 http gateway 把 http 转为 rpc 请求。</li><li>比较有意思的是，它把一切网络请求都抽象成一个 rpc 请求，而下一层无论使用 ws、tcp、http 甚至 udp (QUIC、KCP) 都可以。</li><li>脱离具体的协议来看服务框架，是一个不错的扩宽视野的项目。</li></ul></li><li><a href="https://goframe.org/">goframe</a>: 一个大而全的一站式服务端开发框架<ul><li>和 gin 不同的是，goframe 拥有一个后端项目开发过程中几乎所有的能力封装，包括但不限于  http、grpc、ws、cli、config、log、errors、validator、data convert、cache、template、orm、redis、i18n 等</li><li>各种实用工具: 常用数据结构(map、array、set、list、var、queue、tree等)、系统相关工具、加解密 等</li><li>微服务相关模块: 脚手架cli、服务发现、链路跟踪、负载均衡</li><li>server 开发相关工具: session、swagger、分页、cors、static 等等</li><li>整体来说，goframe 就是一个只要你愿意全套采用他的方案的话，你几乎可以找到所有你需要的东西。</li><li>它是一个统一的框架，对于小团队而言，能够很好地保证组件的统一性。</li></ul></li><li><a href="https://go-kratos.dev/">go-kratos</a>: 一个优雅的微服务框架<ul><li>和 gin 不同，go-kratos 和 goframe 在 微服务开发 上类似，都是一个涵盖了微服务开发过程中常用的工具。提供了 http server、grpc server、auth、metrics、tracing、validator、脚手架 cli 等。</li><li>和 goframe 不同的是，go-kratos 聚焦于 微服务开发，不提供 orm、redis 之类的库，也不提供 ws 、cli 之类的能力，不提供 cron、加解密等非 http/rpc 之外的工具。</li><li>go-kratos 在服务治理方面做的很好，有可插拔的 auth、熔断、限流、负载均衡、服务注册/发现。</li><li>在工程方面，go-kratos 提供的 脚手架 cli 在 <code>通过 proto 生成基础代码</code> ，非常值得一提的是，go-kratos 提倡完全基于 proto 去管理所有的能力，例如 通过 proto 管理 errors、validator、http service、rpc service、types、config 之类的。【这点尤其重要】</li><li>在项目结构方面，go-kratos 提倡三层架构，各层之间通过接口定义，项目使用 wire 进行串联组装，可以参考这个 <a href="https://github.com/go-kratos/examples/tree/main/blog">example</a></li></ul></li><li><a href="https://go-zero.dev/cn/docs">go-zero</a>: 一个强约束的微服务框架<ul><li>go-zero 和 gin 不同，和 go-kratos、goframe 类似。go-zero 从功能上介于 goframe 和 go-kratos 之间。go-zero 是一个专注于微服务开发的框架，这点和 go-kratos 类似。但同时，go-zero 提供了更多的工具，例如 bloom、hash、color、orm、cache、jwt、set、ring 等等，这点和 goframe 类似。</li><li>go-zero 的工程结构上，有更多的约束，同时也减少了开发者的负担和项目的复杂度，这点比前几个框架都更加突出。使用 脚手架 cli 生成的项目结构，几乎完成了除业务逻辑之外的其他部分，包括 通过 proto/api 定义生成 controller、service，通过 sql 生成 model 等。</li><li>go-zero 的工程化做得很极致。</li></ul></li></ul><h2 id="整体思考"><a href="#整体思考" class="headerlink" title="整体思考"></a>整体思考</h2><p>整体来看，几个框架各有千秋，依然是较难抉择，或许，已经在用过 <code>gin + 散装库</code> 之后，会觉得都能接受，但同时也都不好接受吧……</p><p>其实，在目前 golang 的服务框架还没有形成明显的分化时，也就意味着大家各有所长，只要没有明显的短板，无论选用哪个框架，其结果差别都不大。</p><p>项目的开发，重点依然在 <code>项目本身</code>，框架没有明显差别时，选择一个更合自己心意的就行。</p><p>好烦啊啊啊啊，cli 我习惯用 cobra，orm 习惯用 gorm，通用工具库喜欢用 goframe 的，service 的开发又比较喜欢 go-kratos 的方案，go-zero 的结构约束又觉得对以后降低心智负担很有价值……</p><p>考虑到整体开发便利性，我决定先以 go-zero 为基础框架，辅之以 goframe 的工具库。</p><p>之后会以此进行一些项目的实践，并做一些使用的记录。</p><hr><blockquote><p>Gratitude is riches. Complaint is poverty.<br>— <cite>Doris Day</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>backend</tag>
      
      <tag>server</tag>
      
      <tag>framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的文件管理器</title>
    <link href="/longblog/posts/23_05_27_21_00_a_simple_file_managment.html"/>
    <url>/longblog/posts/23_05_27_21_00_a_simple_file_managment.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在玩 AI 画图，但有一个问题，画出来的图不知道该怎么存放，也不知道该怎么展示，于是，希望把一些信息存放起来，便于以后使用。</p><p>如果要做分布式，最好是无状态，把 AI 生成的图片和所产生的信息以文件的形式管理，方案类似于 Minio (一个文件，一个 .sys 的 fs.json 文件)</p><p>这是一个文件的例子:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;version&quot;</span>:<span class="hljs-string">&quot;1.0.2&quot;</span>,<span class="hljs-attr">&quot;checksum&quot;</span>:&#123;<span class="hljs-attr">&quot;algorithm&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;blocksize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">&quot;hashes&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-attr">&quot;meta&quot;</span>:&#123;<span class="hljs-attr">&quot;content-type&quot;</span>:<span class="hljs-string">&quot;application/octet-stream&quot;</span>,<span class="hljs-attr">&quot;etag&quot;</span>:<span class="hljs-string">&quot;05acd5df2ba7a8178e86c3b676fef6d4&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h2><p>在存储的信息上，主要需要如下信息：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby"> filename</span><br><span class="ruby"></span>-<span class="ruby"> filepath</span><br><span class="ruby"></span>-<span class="ruby"> saving_path (<span class="hljs-number">1</span> vs n)</span><br><span class="ruby"></span>-<span class="ruby"> <span class="hljs-symbol">fs:</span>/<span class="hljs-regexp">/xx/usr</span><span class="hljs-regexp">/xx/photo</span><span class="hljs-regexp">/3lz9n4s148Ux3/xx</span>.png</span><br><span class="ruby"></span>-<span class="ruby"> <span class="hljs-symbol">piaooss:</span>/<span class="hljs-regexp">/xxx/lst</span><span class="hljs-regexp">/test/</span>4k0dLd2x0/hello.jpeg</span><br><span class="ruby"></span>-<span class="ruby"> 文件元信息</span><br><span class="ruby"></span>-<span class="ruby"> mime</span><br><span class="ruby"></span>-<span class="ruby"> checksum</span><br><span class="ruby"></span>-<span class="ruby"> size</span><br><span class="ruby"></span>-<span class="ruby"> tags</span><br><span class="ruby"></span>-<span class="ruby"> attributes (xx=xx, <span class="hljs-symbol">eg:</span> person=longalong, place=beijing)</span><br><span class="ruby"></span>-<span class="ruby"> desc</span><br><span class="ruby"></span>-<span class="ruby"> sid (加密相关信息)</span><br><span class="ruby"></span>-<span class="ruby"> create_time</span><br><span class="ruby"></span>-<span class="ruby"> update_time</span><br><span class="ruby"></span>-<span class="ruby"> delete_time</span><br><span class="ruby"></span>-<span class="ruby"> other (<span class="hljs-symbol">eg:</span> prompts)</span><br><span class="ruby"></span>-<span class="ruby"> version</span><br><span class="ruby"></span>-<span class="ruby"> local_info</span><br><span class="ruby"></span>-<span class="ruby"> from (从哪里下载的)</span><br><span class="ruby"></span>-<span class="ruby"> get_time</span><br><span class="ruby"></span>-<span class="ruby"> check_time</span><br></code></pre></td></tr></table></figure><p>文件信息的存储，可以和文件放在一块儿，也可以放在一个可以获取到的地方，放在文件尾部，则需要做专门的解析，管理起来更方便，但使用的灵活性更低。</p><p>文件信息也可以存储在一个特定的数据库中，例如中央的 mongodb、关系数据库、kv 数据库等。</p><h3 id="元信息存储选型"><a href="#元信息存储选型" class="headerlink" title="元信息存储选型"></a>元信息存储选型</h3><p>从图片管理软件 eagle 的方案来看，选择了直接存储 json 文件的方式，对于小批量文件，这确实是一个非常好用的方式，当然，如果是大批量文件，也可以在服务器端使用内存的方式优化。</p><p>使用 sqlite 的好处，在于所有信息均在一个 sql 数据库中，可以使用 SQL 的方式做查询，而且是现成的非常成熟的方案，用起来非常方便。同样，sqlite 的弊端就是中央存储，分布式下数据同步不大好处理(当然是能处理的，只是没有文件来的方便)</p><p>综合考虑来看，保证文件的独立可用是一个重要的特性，因此先采用 json 文件存储的方式，使用文件全路径作为文件名，使用 <code>同名 + .json</code> 的隐藏文件作为 meta 文件信息。</p><p>在实际使用时，需要配置一系列存储地址配置，作为存储基本信息的配置。</p><h2 id="功能清单"><a href="#功能清单" class="headerlink" title="功能清单"></a>功能清单</h2><ul><li>基本的 增删改查</li><li>download cache (下载文件作为 cache)</li><li>图片的压缩 (对于一些大图片，可做压缩处理)</li></ul><p>从交互形式上，有如下特征：</p><ul><li>要支持可以直接操作文件夹内的文件</li><li>要支持可通过接口操作文件</li><li>要支持 sync 的操作 (同步合并) [以后]</li><li>要支持导入导出为 sql 的操作 [以后]</li></ul><p>当前，可做如下事项：</p><ul><li>提供一个 local cli client，支持  cache、check update</li><li>提供一个 server，支持增删改查</li><li>提供一个 api cli client，支持增删改查</li></ul><p>实际使用时，发现还是 sqlite 好用，于是决定作为第一版，先使用 sqlite 吧。</p><p>之前走了一些弯路，认识到几个问题：</p><ul><li><p>自己的产品设计能力还很欠缺，导致对产品的交互形态没有较好的把控力，在思维上很混乱，看起来就像是：这也想要，那也想要。 最终也不知道该怎么落地。</p></li><li><p>起项目时，不能在还没什么思路的时候就上 copilot，这样只会让思路更混乱，暂时还不能把框架结构交给一个可能性很多的工具，要能完全 hold 住各种情况以后才能发挥出其拓宽思路的价值。</p></li></ul><p>不管怎么说，先写了一版基础的，先用着吧，具体的项目在 <a href="https://github.com/iamlongalong/baipiaofs">baipiaofs</a> (由于有一些隐秘的内容，暂时先设置为 private)</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p><img src="https://static.longalong.cn/img/render1685374756842.gif" alt="piaofs使用演示"></p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><ul><li>元信息管理要能同步</li><li>元信息要完全兼容文件系统</li><li>backend 以后要有很多的扩展性，要能很方便地集成多个不同 backend，并且要完全屏蔽 backend</li><li>要能做文件的容错、迁移</li></ul><p>实际上，就是把类似于分布式存储的 backend 通过一套接口，放到了多种 backend 中。</p><hr><blockquote><p>There is only one corner of the universe you can be certain of improving, and that’s your own self.<br>— <cite>Aldous Huxley</cite></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次简单的打包速度优化</title>
    <link href="/longblog/posts/23_05_04_19_32_a_record_of_speed_up_ci_tar.html"/>
    <url>/longblog/posts/23_05_04_19_32_a_record_of_speed_up_ci_tar.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中需要交付一个离线包，主要用于客户自行在内网中部署，该包的大小有点大，压缩前达到了 19GB，gzip 压缩后也有 11GB，在 CI 中，使用的 <code>tar zxf xx.tar.gz xx/</code> 的方式把所有依赖文件打成一个文件，该步操作耗时约 14 min，整个 CI 的流程甚至达到 35 min，于是决定优化一下。</p><h2 id="打包及压缩优化"><a href="#打包及压缩优化" class="headerlink" title="打包及压缩优化"></a>打包及压缩优化</h2><p>众所周知，<code>tar -z</code> 使用了 <code>gzip</code> 压缩，压缩是一个 CPU 密集型的操作，而 gzip 又是一个单线程实现，这会使 gzip 的进程 cpu 占用为 100%，再也上不去了，而其他核几乎是空闲状态。</p><p>从这一角度，有两个思路： ① 使用更强大的 cpu 做 CI (垂直扩容)  ② 使用多个 cpu 做压缩 (横向扩容)</p><p>另外，压缩有程度之分，<code>1 - 9</code> 代表从 <code>速度最快</code> 到 <code>压缩效果最好</code> 递进，默认的 gzip 压缩程度为 6，这也是一个可以权衡的地方。</p><p>以下，分别从这三个方向做一些尝试。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="cpu-ecs-c7a-xlarge"><a href="#cpu-ecs-c7a-xlarge" class="headerlink" title="cpu: ecs.c7a.xlarge"></a>cpu: ecs.c7a.xlarge</h3><p><img src="https://static.longalong.cn/img/20230504195056.png"></p><h3 id="cpu-ecs-c8ae-xlarge"><a href="#cpu-ecs-c8ae-xlarge" class="headerlink" title="cpu: ecs.c8ae.xlarge"></a>cpu: ecs.c8ae.xlarge</h3><p><img src="https://static.longalong.cn/img/20230504195120.png"></p><h3 id="cpu-很普通的-8-core"><a href="#cpu-很普通的-8-core" class="headerlink" title="cpu: 很普通的 * 8 core"></a>cpu: 很普通的 * 8 core</h3><p><img src="https://static.longalong.cn/img/20230504195231.png"></p><p><img src="https://static.longalong.cn/img/20230504195352.png"></p><h3 id="cpu-很普通的-32-core"><a href="#cpu-很普通的-32-core" class="headerlink" title="cpu: 很普通的 * 32 core"></a>cpu: 很普通的 * 32 core</h3><p><img src="https://static.longalong.cn/img/20230504195426.png"></p><h3 id="cpu-很普通的-32-core-best"><a href="#cpu-很普通的-32-core-best" class="headerlink" title="cpu: 很普通的 * 32 core + best"></a>cpu: 很普通的 * 32 core + best</h3><p><img src="https://static.longalong.cn/img/20230504195532.png"></p><p><img src="https://static.longalong.cn/img/20230504195555.png"></p><h3 id="cpu-很普通的-32-core-fast"><a href="#cpu-很普通的-32-core-fast" class="headerlink" title="cpu: 很普通的 * 32 core + fast"></a>cpu: 很普通的 * 32 core + fast</h3><p><img src="https://static.longalong.cn/img/20230504195540.png"></p><p><img src="https://static.longalong.cn/img/20230504195613.png"></p><h3 id="基本结论"><a href="#基本结论" class="headerlink" title="基本结论"></a>基本结论</h3><ul><li><p>多核压缩 pigz 比 单核压缩 gzip 快很多，用起来。</p></li><li><p>从我们的场景来看，压缩程度似乎对包大小影响不大 (因为主要是一些大的docker 镜像)，所以压缩程度直接改成 fast 即可。</p></li><li><p>优化后，整体打包时间从 35 min 降到了 24 min</p></li></ul><h2 id="其他记录"><a href="#其他记录" class="headerlink" title="其他记录"></a>其他记录</h2><h3 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">axel -n 10 https://xxx.xxx.xx/xx.tar.gz<br></code></pre></td></tr></table></figure><p>yum 安装最新版:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装依赖</span><br>yum install gcc make automake autoconf openssl-dev -y<br><br><span class="hljs-comment"># 下载源代码</span><br>wget https://github.com/axel-download-accelerator/axel/releases/download/v2.17.10/axel-2.17.10.tar.gz<br><br><span class="hljs-comment"># 解压并编译</span><br>tar -zxvf axel-2.17.10.tar.gz &amp;&amp; \<br><span class="hljs-built_in">cd</span> axel-2.17.10 &amp;&amp; \<br>./configure &amp;&amp; \<br>make &amp;&amp; make install<br><br><span class="hljs-comment"># 查看</span><br>axel -h<br></code></pre></td></tr></table></figure><blockquote><p>这个的效果不一定好，主要得根据特定场景下的资源卡点来确定，如果 wget 已经能把本机网络带宽占满，则几乎没有提升。</p></blockquote><h3 id="使用-ramdisk"><a href="#使用-ramdisk" class="headerlink" title="使用 ramdisk"></a>使用 ramdisk</h3><p>磁盘读写速度有时候是很大的瓶颈，为了追求极致的读写速度，可以用 ram disk，记录一下使用方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建1个大小为 20GB 的磁盘</span><br>modprobe brd rd_nr=1 rd_size=20480000 max_part=0<br><br><span class="hljs-comment"># 格式化为 ext4</span><br>mkfs.ext4 /dev/ram0<br><br><span class="hljs-comment"># 挂载到 /root/rdisk</span><br>mkdir -p /root/rdisk &amp;&amp; mount /dev/ram0  /root/rdisk<br><br><span class="hljs-comment"># 查看一下</span><br>df -h<br><br></code></pre></td></tr></table></figure><p>清理掉 ramdisk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清理掉 ramdisk</span><br>umount /root/rdisk<br>modprobe -r brd<br></code></pre></td></tr></table></figure><p>用 glances 来监测机器运行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 glances</span><br>pip3 install --upgrade pip<br>pip3 install glances<br><br>glances<br><br></code></pre></td></tr></table></figure><h3 id="rsync-的优化"><a href="#rsync-的优化" class="headerlink" title="rsync 的优化"></a>rsync 的优化</h3><p>在多个服务器之间传输文件，常用 <code>rsync</code> 的方式。<br>最简单的用法是:  <code>rsync -av &quot;$SOURCE_DIR&quot; &quot;$TARGET_DIR&quot;</code></p><p>rsync 可以使用压缩传输，对应的参数是 <code>-z</code> ，如果你的网速是比较大的瓶颈，或者你要传输的文件有很大的压缩空间，那么你可以开启压缩，如果不是，则开启压缩后反倒会让传输的速度变慢 (压缩是单线程的)。</p><p>我们的场景属于不应当开启压缩，因此优化掉。</p><p>使用压缩时: <img src="https://static.longalong.cn/img/20230518151953.png"></p><p>不使用压缩时: <img src="https://static.longalong.cn/img/20230518152050.png"></p><p>好的，果断去掉压缩。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这只是一个最基础的打包优化，之后需要从更整体的方案上做优化：</p><ul><li>容器和资源 cache</li><li>打包平台，按需打包</li></ul><hr><blockquote><p>Almost everything comes from nothing.<br>— <cite>Henri-Frédéric Amiel</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>tar</tag>
      
      <tag>gzip</tag>
      
      <tag>ramdisk</tag>
      
      <tag>memdisk</tag>
      
      <tag>pigz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次协同问题的内部分享</title>
    <link href="/longblog/posts/23_04_25_16_40_record_of_collaboration_share_in_team.html"/>
    <url>/longblog/posts/23_04_25_16_40_record_of_collaboration_share_in_team.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在团队内做了一次协同问题的分享，从一个更全面的视角看了一下 <code>什么是协同</code>，同时分析了其中一种协同场景的实现思路，并且用这种思路写了一个 demo: <a href="http://101.42.240.235:8080/">http://101.42.240.235:8080</a>  (姑且先用 ip 吧，之后空了再弄成域名的方式)。</p><p>受启发于前端的响应式编程，这个项目也姑且叫 reactive 吧 ~</p><p>项目地址： <a href="https://github.com/iamlongalong/reactive">https://github.com/iamlongalong/reactive</a></p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><blockquote><p>slides 如下，但由于时间比较紧，slides 以达意为主，样式没怎么调整</p></blockquote><iframe src="https://blog.longalong.cn/slides/play_with_cooperate/index.html" width="100%" height="800px">记一次对协同的简单分享</iframe><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这预计会是未来半年内的最后一次技术分享了，<a href="https://github.com/iamlongalong/reactive">reactive</a> 这个项目短期内也不会更新，和之前的 <a href="/longblog/posts/23_03_28_15_01_a_record_of_sharing_of_database.html" name="记录一次在团队内的数据库分享" >记录一次在团队内的数据库分享</a> 中的 <a href="https://github.com/iamlongalong/imagine">imagine</a> 项目一样。 以后有闲的时候可以再回来推进一下，这两个项目虽然处理的是比较小的场景，但确实是很精准的解决方案。</p><p>AI 燃烧地火急火燎，得赶紧入场了，不然哪天被干掉都不知道是为啥……</p><hr><blockquote><p>A creative man is motivated by the desire to achieve, not by the desire to beat others.<br>— <cite>Ayn Rand</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>协同</tag>
      
      <tag>collaboration</tag>
      
      <tag>share</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次使用jupyter做数据分析</title>
    <link href="/longblog/posts/23_04_13_11_48_use_jupyter_for_data_analysis.html"/>
    <url>/longblog/posts/23_04_13_11_48_use_jupyter_for_data_analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为工作需要，最近做了一次数据分析，用于洞察客户的使用情况及服务运行情况。</p><p>由于整个体系接触的比较少，因此做一下记录。</p><h2 id="数据分析的结构"><a href="#数据分析的结构" class="headerlink" title="数据分析的结构"></a>数据分析的结构</h2><p>在 <code>数据分析</code> 这项工作中，有如下环节：</p><ul><li>确认需求，明确想要分析的问题是什么，预期的产出是什么</li><li>确认数据源，明确数据的结构、格式、数据量等</li><li>确认数据逻辑，明确需要分析的问题所需数据是否到位</li><li>做数据预处理，数据清理、异构数据格式转换</li><li>查询的语句、分析的代码编写 (eg: sql、numpy 等)</li><li>数据可视化，图表绘制 (eg: BI 工具、excel、echarts、plotly 等)</li><li>数据结果的分析与说明 (eg: doc、slides、pdf 等)</li></ul><p>在本次的分析中，我的选择如下：</p><ul><li><p>确认需求： 分析客户基本特征、系统使用特征、磁盘空间占用分析</p></li><li><p>确认数据源： postgresql 数据库备份、du 结果文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@iZ2ze6jqzxxt4hf0qgpcglZ fordisk]<span class="hljs-comment"># ls -lh</span><br>total 13G<br>-rw-r--r-- 1 root root 1.1K Mar  7 21:50 df.log<br>-rwxr-xr-x 1 root root  292 Mar  7 21:42 getdiskusage.sh<br>-rw-r--r-- 1 root root  929 Mar  7 22:53 minio_disk_usage_info.log<br>-rw-r--r-- 1 root root 6.0G Mar  7 23:31 minio_disk_usage.log<br>-rw-r--r-- 1 root root 3.4G Apr  7 17:09 minio_disk_xx1.log<br>-rw-r--r-- 1 root root 3.4G Apr  7 17:16 minio_disk_xx2.log<br>-rw-r--r-- 1 root root  770 Mar  7 22:22 nfs_disk_usage_info.log<br></code></pre></td></tr></table></figure></li><li><p>确认数据逻辑： 分析 pg 数据库表结构及逻辑关系，确认 du 数据与业务含义<br><img src="https://static.longalong.cn/img/20230413123035.png"></p></li><li><p>数据预处理： ① 对 pg 的数据做拆分聚合，形成多张能直接查询的表； ② 对 du 结果做处理，以关系数据的方式写入 pg 库中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1. 去除 pg 中的无用数据<br>2. 使用 CREATE TABLE xxx AS SELECT * FROM xxx WHERE xx and xx; 的方式创建能直接使用的表<br>3. 写脚本将 du 的结果变成 csv 格式，并使用 COPY xxx FROM &#x27;xxx.csv&#x27;      WITH ( FORMAT csv, DELIMITER &#x27;,&#x27;, HEADER false); 导入到 pg 数据库<br></code></pre></td></tr></table></figure></li><li><p>查询的语句： 拆分需求所需的关键分析项，写 sql 查询，对查询结果做进一步处理得到所需结构。 工具上，使用 jupyterhub，所有操作均在 jupyter python note 中完成。<br><img src="https://static.longalong.cn/img/20230413123222.png"></p></li><li><p>数据可视化： 根据需求，使用 pie、bar、line、heatmap、pareto 等图进行展示。 工具上，使用 plotly，直接在 jupyterhub 上生成图表。</p></li></ul><p><img src="https://static.longalong.cn/img/20230413121812.png" alt="折线图"></p><p><img src="https://static.longalong.cn/img/20230413121831.png" alt="柱形图"></p><p><img src="https://static.longalong.cn/img/20230413121915.png" alt="帕累托图"></p><ul><li>数据结果的分析与说明： 直接使用 jupyterhub，使用 markdown 写结果分析。整个文件以 html 的方式导出图表和分析结果。<br><img src="https://static.longalong.cn/img/20230413123356.png"></li></ul><h2 id="一些坑点-趣点小记"><a href="#一些坑点-趣点小记" class="headerlink" title="一些坑点/趣点小记"></a>一些坑点/趣点小记</h2><h3 id="jupyter-的导出问题"><a href="#jupyter-的导出问题" class="headerlink" title="jupyter 的导出问题"></a>jupyter 的导出问题</h3><p>按理，jupyter 是可以直接导出 pdf、html、slides 之类的，本想导出 pdf ，但要导出 pdf 需要各种插件依赖，我们的 jupyterhub 是用 centos 装的，依赖安装很难搞，建议用 ubuntu 装 jupyterhub。<br>最后无奈，只有导出 html ……</p><h3 id="note-的数据大小问题"><a href="#note-的数据大小问题" class="headerlink" title="note 的数据大小问题"></a>note 的数据大小问题</h3><p>一般而言，jupyterhub 要使用域名，就会在前面挡一层 nginx，我们也用的这种方式，但没有配置上传的 body 大小限制，默认是 1MB，超过就会报 413 错误，具体可以参考 <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">nginx 官方文档</a> ，可以设置为 20MB，大点的 note 也差不多在这之内。</p><h3 id="导出的-html-有点丑"><a href="#导出的-html-有点丑" class="headerlink" title="导出的 html 有点丑"></a>导出的 html 有点丑</h3><p>jupyter 导出的 html 既有 code 块 也有 输出块 (eg: 图表) 也有 文本块 (markdown)，但实际上对外分享时不需要 code 块，隐藏的方式在网上有一些用 plugin 的，简单尝试了下有点难搞，于是就在 html 的样式上下功夫，为了去掉 code 部分，添加了如下 style:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jp-CodeMirrorEditor</span><span class="hljs-selector-class">.jp-Editor</span><span class="hljs-selector-class">.jp-InputArea-editor</span> &#123;<span class="hljs-attribute">display</span>: none;&#125;<br><span class="hljs-selector-class">.jp-InputArea</span><span class="hljs-selector-class">.jp-Cell-inputArea</span> &#123;<span class="hljs-attribute">display</span>: none;&#125;<br><span class="hljs-selector-class">.jp-OutputArea-child</span><span class="hljs-selector-pseudo">:has</span>(pre) &#123;<span class="hljs-attribute">display</span>: none;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不得不说， css 选择器中加了 has 这种能力后，父节点选择直接方便了不少</p></blockquote><p>另外，默认的字体大小为 14px，改了下 css 变量 <code>--jp-content-font-size1: 18px</code>，好看多了。</p><h3 id="sql-中直接做分组也挺方便"><a href="#sql-中直接做分组也挺方便" class="headerlink" title="sql 中直接做分组也挺方便"></a>sql 中直接做分组也挺方便</h3><p>除了常用的 <code>to_char(created_at::DATE, &#39;YYYY-MM-DD&#39;) as day</code> 、<code>date_trunc(&#39;week&#39;, created_at::date) as week</code> 这种时间分组操作外，还可以使用 <code>cross join lateral (values (max_kb / 1024)) xx (size_mb) GROUP BY xx.size_mb</code> 这种横向 join 的能力。</p><p>之前还有一些分组是在 python 脚本里手写的，但其实 sql、python 的 numpy 库中都可以直接做分组聚合，挺方便。</p><h3 id="结合-AI-？"><a href="#结合-AI-？" class="headerlink" title="结合 AI ？"></a>结合 AI ？</h3><p>很多数据分析其实都是很常规的，比如统计信息，一定程度上算得上是 <code>机械重复的工作</code> ，那么结合 AI 就是一个比较容易的事了。 相信很多团队都会在这个方向搞些事情，尤其是那些专门做 BI 工具的公司。(比如: power BI、tableau、神策？等)</p><p>从结合的方式来看，如果结合 AGI 例如 GPT，小团队使用还好，大团队的安全担忧会比较大。如果使用特定领域的 AI，那么问题就会变成 如何让 AI 理解业务结构的问题。会存在结构化或非结构化的方式，非结构化对应类似 GPT 的 prompt。</p><h3 id="jupyter-的-runtime-模式有点意思"><a href="#jupyter-的-runtime-模式有点意思" class="headerlink" title="jupyter 的 runtime 模式有点意思"></a>jupyter 的 runtime 模式有点意思</h3><p>jupyter 的特点主要是 code 和 markdown 的结合。当另外一点我认为也很有价值： runtime 保持。这对我们学习脚本语言的体验有很大提升，相当于一直处于断点模式，并且还可以随意修改下一个断点前的代码。</p><h3 id="其他的工具"><a href="#其他的工具" class="headerlink" title="其他的工具"></a>其他的工具</h3><p>在准备做这项事之前，花了一小段时间去调研用什么方式管理要做的事，最简单的例如：excel 图表 + 文档 的方式，这种方式管理起来很麻烦。于是想到了可以直接进行代码交互的方案，例如  jupyter notebook。 其实，这种工作属于 数据分析，而数据分析有更多专门的工具，主要的诉求有如下：</p><ol><li>连接各类数据库</li><li>对连接的数据源进行查询，并对结果做处理</li><li>生成图表</li><li>结果的分析记录</li><li>对外分享分析结论</li></ol><p>jupyter 算是一个比较通用的 python / nodejs 工具，但在数据分析方面的使用成本还是挺高的，例如连接数据库等等 (当然也有一些 jupyter 的插件能做到这件事)。</p><p>上面提到过的 power BI、tableau 在上手难度上很低，都属于面向分析人员的低代码方案。</p><p>不得不说，这其中还是存在一些需求的，市面上也确实看到过一些类似于 jupyter ，但是提升了在数据分析方面能力的工具，比如:  <a href="https://hex.tech/">hex</a>  <a href="https://observablehq.com/">observablehq</a> 。 <a href="https://count.co/">count</a> 直接在 canvas 上操作，交互体验更有意思。还有开源的方案 <a href="https://github.com/apache/zeppelin">zeppelin</a> 。</p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><h3 id="熟悉-numpy-的使用"><a href="#熟悉-numpy-的使用" class="headerlink" title="熟悉 numpy 的使用"></a>熟悉 numpy 的使用</h3><p>数据分析领域比较常用 python，主要是 python 下科学计算的库比较完善，比如 numpy，这次的分析中由于对 numpy 不熟悉，所以有些数据处理都是手写的，拉低了效率。</p><p>之后可以在 numpy 等工具应用上多看一下，同理 plotly。</p><h3 id="了解更多的数据分析方案"><a href="#了解更多的数据分析方案" class="headerlink" title="了解更多的数据分析方案"></a>了解更多的数据分析方案</h3><p>用 OLTP 关系数据库分析在少量数据时挺好用，但大数据量下性能就不大行了，比如千万级以上的数据，这种时候得使用其他方案了。</p><ul><li>数据库: clickhouse、hive、cassandra、hbase、mongodb、redis、rds……</li><li>分布式存储: hadoop(hdfs)、s3</li><li>stream: kafka、rocketmq、flume</li><li>任务与计算: flink、spark</li></ul><p>在数据分析之后，还有 AI 算法和模型训练，然后才能接上 AI</p><blockquote><p>调研过程中发现 <a href="https://www.smartbi.com.cn/">smartbi</a> 在做类似的接入了~</p></blockquote><p>未来 20 年是 AI 的时代，拥抱数据分析、拥抱 AI </p><p><img src="https://static.longalong.cn/img/20230413135436.png"></p><hr><blockquote><p>Ignorance never settles a question.<br>— <cite>Benjamin Disraeli</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>jupyter</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于职业规划的一些思考</title>
    <link href="/longblog/posts/23_04_06_21_41_some_questions_about_majors_in_university.html"/>
    <url>/longblog/posts/23_04_06_21_41_some_questions_about_majors_in_university.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>叔叔的仔明年高考，向我询问关于专业选择的看法，我做了一些梳理记录于此。</p><h2 id="Q1-该选什么专业？"><a href="#Q1-该选什么专业？" class="headerlink" title="Q1: 该选什么专业？"></a>Q1: 该选什么专业？</h2><p>现在选专业，是为未来 8 年以后做准备的，因此，不能以现在的行业情况来判断该选什么。事实上，每一个领域的快速发展期大都只有 5 年，因此一定不能追当前热门的专业，这意味着当毕业以后，一定会是一个走下坡路的行业。例如，03年开始学外贸、外语，08 年开始学土木、建筑，14 年开始学财会、金融等等，这些都是典型的失败选择…… (另外，计算机是个例外，持续火了十几年)</p><p>因此，专业的选择要考虑两个主要问题：</p><ol><li>个人的兴趣及爱好</li><li>未来 8 年以后的行业更迭</li></ol><p>以下简单梳理一些我对一些领域的看法：</p><p>新能源、生物、化学、新材料 这些，都是属于高精尖的领域，需要往博士阶段奋斗，需要有很明确的志向才能选择。</p><p>医学，现在竞争比较激烈，所以目前就业方面比较难，但几年以后来看，是个还可以的方向，尤其是保健护理、神经医学、心理学。 </p><p>法学，长期来看始终会有机会，如果对法律方向有兴趣，可以考虑。</p><p>金融财会类，金融方向需要的是人脉、资源、背景，普通人进入就是销售岗位。财会方向几年以后会直接被计算机替代，一定不能选。 </p><p>土木工程类，这是前10年的热门专业，但热门的原因是中国在大搞基建，目前基建已经饱和，未来土木、桥梁、电力、煤炭、钢铁 这些领域都会持续走下坡路。</p><p>交通类，交通运输管理、交通运输工程、汽车工程、飞行器等，这些领域算是很专业的领域，汽车方向在走下坡路，航空航天、交通运输工程 这些持续会有机会，但一定要走高精尖路线。</p><p>电气自动化、电子机械，这是未来 10 年以后一定会大量需要的岗位，伴随着全面工业 4.0 推进、人体机械领域的发展，会出现一波很大的人才需求。</p><p>计算机科学、软件工程，现在看起来人才有些饱和，实际是全球经济遭受冲击，对大量还无法盈利的互联网产业冲击较大，加上 AI 对基础岗位的替代作用很明显，因此近两年互联网企业的裁员较多。但实际上，全球经济冲击对每个行业都非常巨大，只是很多行业在互联网和媒体上都发不出声音，没被大家看到。 </p><p>从未来来看，计算机知识是基础知识，在具备计算机知识的基础上，可以转向很多领域，比如 计算机 + 机械、计算机 + 财会、计算机 + 教育 等等，我比较相信一个理念：最后一个被 AI 替代的行业是程序员，倒数第二个是服务员。</p><p>教育学，教育是一个会有剧变的领域，目前看不清楚未来的发展情况。幼儿教育领域的变化不会太大，会持续朝着精细化发展。中学教育会受到 AI 的大冲击。</p><p>传媒方向，数字媒体从长期来看还是有机会，但目前还看不清楚 AI 的冲击会让这个领域成为什么样。</p><p>农林畜牧，没有太多背景资源的话，机会比较少。但小领域还是有一些机会，比如动物医学。没较强的兴趣不建议。</p><p>经济学、管理学、哲学、社会学、历史学，这些领域如果不是具备很强的兴趣和使命，就不要选，人文学科精神会很富足，但就业不大好。</p><p>语言类专业都不能选，未来一定会被 AI 替代。</p><p>军工类，如果有比较强的军人情结可以考虑。但军工类的进入方法，在没有一定背景的情况下，最好以技术类工种进入，比如学习 航空、导弹、计算机、机械，从这些专业进入。</p><h2 id="Q2-大学专业和从事行业是什么关系？"><a href="#Q2-大学专业和从事行业是什么关系？" class="headerlink" title="Q2: 大学专业和从事行业是什么关系？"></a>Q2: 大学专业和从事行业是什么关系？</h2><p>一定要记住，大学专业只是你认识这个世界的一个入口，选好了专业不代表一定能从事好的行业，行业更迭速度很快，只有保持持续的学习、保持持续的思考、保持开放的心态，才能跟上时代的发展，才能有机会获得更高的投入产出比，也才能拥有更多的时间和心力来享受生命。</p><h2 id="Q3-高三学生现在该做什么？"><a href="#Q3-高三学生现在该做什么？" class="headerlink" title="Q3: 高三学生现在该做什么？"></a>Q3: 高三学生现在该做什么？</h2><p>战略上轻视应试教育，战术上极其重视应试教育。</p><p>尽可能地把考试分数当做自己的追求，极尽一切去体会解题带给你的乐趣，去体会对知识的掌控感带给你的乐趣，让你的脑海里充满学科知识点，用你自己的视角去关联这些知识，让一切会占用你注意力的其他事物都从你的生活中消失！！</p><p>请相信，如果你这样做了，未来的你一定会对现在的你感激涕零，是那种对从死亡边缘把你拉回来的救命恩人的那种感激。</p><p>……未完待续</p><hr><blockquote><p>This is the whole point of technology. It creates an appetite for immortality on the one hand. It threatens universal extinction on the other. Technology is lust removed from nature.<br>— <cite>Don DeLillo</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>职业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能是什么？</title>
    <link href="/longblog/posts/23_04_01_10_43_some_discuss_about_inteligence.html"/>
    <url>/longblog/posts/23_04_01_10_43_some_discuss_about_inteligence.html</url>
    
    <content type="html"><![CDATA[<h3 id="如何看待AI兴起"><a href="#如何看待AI兴起" class="headerlink" title="如何看待AI兴起"></a>如何看待AI兴起</h3><p>中短期来看，和工业革命一样，会极大地改变人们的生产方式，这是大势，不可与之抗衡，顺应趋势，把它当做一个大变革下的工具去使用，真正把 AI 应用到各个领域。</p><p>就像工业革命时期，同样存在 “反对工业的手工业者” 和 “积极拥抱工业的小作坊主”，前者本能地反对工业，最后被工业清了场，而支持工业的，拥有了所在领域的所有资源。</p><p>从中短期来看，AI 是提升生产力的重要方式，生产力提升是一件好事， 能带来生活的便利和生活水平的提升。</p><p>大家对 AI 的担心，大多站在两个视角：资源分配，害怕 AI 改变了自己现有的资源分配方式； 种族安全，害怕 AI 构建起了与人类利益不一致的价值体系。</p><p>所以，对于国家而言，保持社会稳定以及公平公正的方法，是做好资源分配。对于个人而言，提升生活质量的方式，是拥抱 AI，寻找能获得资源分配倾斜的途径，比如，把 AI 引入某个细分领域并实现效率的极大升级。</p><p>站在人类种族视角，如果以种族延续为最基本诉求的话，确实应该好好梳理一下怎么处理好安全问题，至少推迟硅基生物的降临时间，或者做好平稳过渡。</p><p>不过，世界如此割裂的情况下，很难说还有没有 “人类种族” 这个意识……</p><hr><h3 id="一个视角下的智能"><a href="#一个视角下的智能" class="headerlink" title="一个视角下的智能"></a>一个视角下的智能</h3><p>工业化 体系下，我们可以这样延伸：<br>(标准化）、信息化、自动化、智能化</p><p>信息化 体系下，精简成了这两个环节：<br>信息化 =&gt; 智能化</p><p>信息化 和 智能化 的差异体现在 决策上。</p><p>什么是决策？</p><ol><li>目标 (价值判断)</li><li>信息</li><li>推演</li><li>价值选择</li></ol><p>什么是价值？</p><ul><li>利益</li></ul><p>谁的利益？</p><ul><li>群体利益</li><li>个人利益</li><li>？</li></ul><p>所以，选择没有绝对的对错，只有屁股。或者，对错的评判标准是 “选择与屁股是否相符”。</p><p>群体利益，由 社会伦理、组织文化 等保障<br>个人利益，由 群体利益 和 个人思想与行为 保障</p><p>那么，？</p><hr><h3 id="有意思的语句"><a href="#有意思的语句" class="headerlink" title="有意思的语句"></a>有意思的语句</h3><p>想到一些有意思的句子，你细品：</p><ul><li>非我族类，其心必异</li><li>兽人永不为奴</li><li>黑，真特么的黑</li><li>人类终于创造出了神</li></ul><hr><blockquote><p>Eternal nothingness is fine if you happen to be dressed for it.<br>— <cite>Woody Allen</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>智能</tag>
      
      <tag>inteligence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次在团队内的数据库分享</title>
    <link href="/longblog/posts/23_03_28_15_01_a_record_of_sharing_of_database.html"/>
    <url>/longblog/posts/23_03_28_15_01_a_record_of_sharing_of_database.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>简单从一个视角去看数据库 ~</p><p>手写一个简单的 map 数据库 ~</p><p>回头把 视频/音频/文字稿 整理一下附上 ~</p><p>这是一个比较有意思的项目，目前还没有完成，之后一段时间也会推进一些地方的改进，具体可以关注 github 的更新情况 ~</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><iframe src="https://blog.longalong.cn/slides/easy_talk_of_db/index.html#/" width="100%" height="800px">记一次对数据库的简单分享</iframe><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>对应的 github 项目地址为:  <a href="https://github.com/iamlongalong/imagine">imagine</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>share</tag>
      
      <tag>数据库</tag>
      
      <tag>团队分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次对可恶站点的抗争</title>
    <link href="/longblog/posts/23_03_12_12_16_a_fight_for_some_disgust_sites.html"/>
    <url>/longblog/posts/23_03_12_12_16_a_fight_for_some_disgust_sites.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有些网站本身有挺多高质量的内容，但非得走上让人恶心 🤮 的道路，所以在这里记录一下跟他们抗争的历程。</p><h2 id="某书"><a href="#某书" class="headerlink" title="某书"></a>某书</h2><p>最近想查一些树形结构存储方案，看到一篇某书上的文章，打开一看，简直是震惊啊龙几十年！</p><p>用几个词来形容： 内容被忽视，广告粗劣，小黄文占领了主体……</p><p>大致如下：</p><p><img src="https://static.longalong.cn/img/20230312123403.png"></p><p>之前某书是一个多么干净、沉浸的文字平台啊，很多程序猿、小文艺都喜欢在上面写写文章，如今……</p><p>但无可奈何，这个平台上还是有一些知识遗产，之前积累起来的中文搜索关键词还被这个平台占据着，有时候搜索一些东西还是会被引导这个平台上来，所以……得净化一下……</p><h3 id="简单的净化方案"><a href="#简单的净化方案" class="headerlink" title="简单的净化方案"></a>简单的净化方案</h3><h4 id="uBlock"><a href="#uBlock" class="headerlink" title="uBlock"></a>uBlock</h4><p>这是一个 chrome 插件，可以用于 元素过滤、脚本过滤、多媒体过滤等</p><p>插件地址： <a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a></p><ul><li>使用元素选择器，把一些恶心的模块干掉<br><img src="https://static.longalong.cn/img/20230312124737.png"></li></ul><p>这种方式对 顶部广告、底部广告、底部恶心推荐 都很有效。</p><p>但是对右侧的 热门故事 模块几乎无效。因为选择器直接选择时候的选择器是 class 选择器，而 class 名经常可能会发生变化，导致失效，所以我们得找一个更好的元素选择路径。</p><ul><li>扒一下前端页面的结构</li></ul><p><img src="https://static.longalong.cn/img/20230312125633.png"></p><p>可以发现，这个网站的生成应该是 next.js 做的服务端渲染，结构很鲜明，role=”main” 的块为页面主体， aside 为侧边栏。</p><ul><li>于是我们可以这样操作</li></ul><p>选择器为 <code>##div[role=main] &gt; aside</code> ，效果是这样的：</p><p><img src="https://static.longalong.cn/img/20230312130928.png"></p><ul><li>探索一下另一条路</li></ul><p>由于页面的主体是静态的，而页面的推荐内容是动态的，也就意味着一定会发送对应的请求出去，那么 block 这些请求也是一个不错的方式。</p><p>于是扒了一下页面请求：</p><p><img src="https://static.longalong.cn/img/20230312130408.png"></p><p>可以发现，这些就是我们最不喜欢的东西，有广告的、恶心推荐的、行为上报的……</p><p>之后可以玩一下接口过滤</p><p>一番操作下来，舒服多了…… 可以继续看文章了</p><p><img src="https://static.longalong.cn/img/20230312150852.png"></p><ul><li>后记</li></ul><p>uBlock 很强大，默认会做一些关键词过滤，例如 <code>ad</code> ，但这个粒度相对较大，有时候会误把一些需要的信息给屏蔽掉，导致个别网站访问失败，或者操作报错 之类的，一般发现你的浏览器 和 别人的浏览器 对某个页面的表现不一致时，建议把 uBlock 关上试试，如果真是因为 uBlock 过滤的问题，那就把这个站点加个白名单。</p><p>另外，也可以用下面这种方式 👇👇👇</p><h4 id="TamperMonkey"><a href="#TamperMonkey" class="headerlink" title="TamperMonkey"></a>TamperMonkey</h4><p>油猴是一个页面脚本管理工具，可以自定义任何的 js， 这需要写一些简单的 js 代码，实现的逻辑和 uBlock 一样，去除一些页面特定的元素。 </p><p>找了一下<a href="https://www.tampermonkey.net/scripts.php">油猴的脚本社区</a>，搜了一下，发现之前有一个哥们儿用 jquery + class 选择器做的，估计已经用不了了，我顺手写一个吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         RemoveJianShuNauseaThings</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @version      0.1</span><br><span class="hljs-comment">// @description  简书之堕落，让人遗憾，哀其不幸，怒其不争，为了不让广大作者的资产跟着陪葬，去除污染源，以正视听。 简书去广告。简书。广告。去除热门推荐。jianshu。JianShu。</span><br><span class="hljs-comment">// @author       longalong</span><br><span class="hljs-comment">// @match        *://www.jianshu.com/p/*</span><br><span class="hljs-comment">// @icon         https://www.google.com/s2/favicons?sz=64&amp;domain=jianshu.com</span><br><span class="hljs-comment">// @grant        none</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">do_track</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// remove baidu ads</span><br>        <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;iframe&quot;</span>).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;iframe&quot;</span>).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (i.src.includes(<span class="hljs-string">&quot;pos.baidu.com&quot;</span>)) &#123;<br>                    i.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>                &#125;<br>            &#125;);<br>        &#125;);<br><br>        <span class="hljs-comment">// remove aside recommend</span><br>        <span class="hljs-keyword">let</span> asideModle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div[role=main] &gt; aside &gt; div&quot;</span>);<br>        <span class="hljs-keyword">if</span> (asideModle) &#123;<br>            asideModle.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// remove under recommend</span><br>        <span class="hljs-keyword">let</span> unserModle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div[role=main] &gt; div &gt; section:nth-child(2)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (unserModle) &#123;<br>            unserModle.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> message_box = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div#__next&quot;</span>);<br>        <span class="hljs-comment">// listen element change</span><br>        <span class="hljs-keyword">let</span> MutationObserver = <span class="hljs-built_in">window</span>.MutationObserver || <span class="hljs-built_in">window</span>.WebKitMutationObserver;<br>        <span class="hljs-keyword">if</span> (MutationObserver) &#123;<br>            <span class="hljs-keyword">let</span> MutationObserverConfig = &#123;<br>                <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>,<br>            &#125;;<br>            <span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mutations</span>) </span>&#123;<br>                do_track();<br>            &#125;);<br>            observer.observe(message_box, MutationObserverConfig);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message_box.addEventListener) &#123;<br>            message_box.addEventListener(<span class="hljs-string">&quot;DOMSubtreeModified&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>&#123;<br>                do_track();<br>            &#125;, <span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                do_track();<br>            &#125;, <span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listen event fail&quot;</span>, error);<br>    &#125;<br><br>&#125;)();<br></code></pre></td></tr></table></figure><p>这个也发布到 <a href="https://greasyfork.org/zh-CN/scripts/461677-removejianshunauseathings">Greasy Fork</a> 社区了，有同样诉求的同学可以自行获取。</p><h2 id="某SDN"><a href="#某SDN" class="headerlink" title="某SDN"></a>某SDN</h2><p>……目前用了 uBlock 做推荐拦截，用了 简悦 做 copy ，先解决了问题，以后有什么特别的恶心的地方再做梳理吧……</p><h2 id="某书后续"><a href="#某书后续" class="headerlink" title="某书后续"></a>某书后续</h2><ul><li><input disabled="" type="checkbox"> 外链跳转优化</li><li><input disabled="" type="checkbox"> 生成文章目录层级</li></ul><hr><blockquote><p>We can only learn to love by loving.<br>— <cite>Iris Murdoch</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>tampermonkey</tag>
      
      <tag>油猴</tag>
      
      <tag>js script</tag>
      
      <tag>chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于文件存储的一些调研</title>
    <link href="/longblog/posts/23_03_09_12_53_some_research_of_file_storage.html"/>
    <url>/longblog/posts/23_03_09_12_53_some_research_of_file_storage.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做 <a href="/notpublish/index.html" name="如何做一个分布式截图服务" >如何做一个分布式截图服务</a> 的准备，因此需要调研一下文件存储上都有些什么方案。</p><p>主要需要调研以下内容：</p><ul><li>基础设施层，主要调研 机械硬盘、ssd、闪存、网卡、lvm、raid</li><li>本地文件系统及网络文件系统，主要调研 fat、exfat、ntfs (windows)、hfs(mac)、zfs、xfs、ext、nfs、smb</li><li>分布式存储主要调研 oss、kodo、fastDFS、glusterFS、ceph、minio、longhorn、ipfs、hdfs</li><li>相关应用主要参考 mongodb、etcd、群晖</li></ul><h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><ul><li>ssd ： <a href="https://www.zhihu.com/question/47544675/answer/670562224">SSD的随机读写与顺序读写</a></li><li><a href="https://zhuanlan.zhihu.com/p/443342432">几个ssd接口类型</a></li><li><a href="https://zhuanlan.zhihu.com/p/429260253">企业级SSD寿命要怎么看</a></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>参考文档：</p><ul><li><a href="https://www.cnblogs.com/lilpig/p/16858611.html">文件系统的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/44267768">深入理解 ext4 等 linux 文件系统</a></li><li><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">ext4 的 wiki</a></li><li><a href="https://github.com/openzfs/zfs">github openzfs</a></li><li><a href="https://www.zhihu.com/question/21034296">exfat 系统的一些讨论</a></li><li><a href="https://zhuanlan.zhihu.com/p/571235218">Linux下几种常用文件系统Ext4、XFS、ZFS以及Btrfs的简介及优缺点对比</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="minio"><a href="#minio" class="headerlink" title="minio"></a>minio</h3><p>github 地址: <a href="https://github.com/minio/minio">minio</a><br>官方文档：<a href="https://docs.min.io/">minio</a><br>中文文档：<a href="http://docs.minio.org.cn/docs/">minio</a></p><ol><li>不使用中央式 meta 存储</li><li>底层采用文件存储</li><li>大量小文件性能较差</li><li>分布式通过 EC 方案保证高可用</li><li>集群内无法扩容，仅能通过扩充集群组联邦实现</li><li>minio 作者也是 glusterFS 的创始人</li><li>minio 采用的开源协议是 GNU AGPLv3，商用有隐患</li></ol><p>可以参考的文档：</p><ul><li><a href="https://blog.csdn.net/agonie201218/article/details/128245433">minio 介绍</a></li></ul><h3 id="ceph"><a href="#ceph" class="headerlink" title="ceph"></a>ceph</h3><ol><li>提供 块存储、文件存储、对象存储 三种方式</li><li>元数据存储在 MDS 组件集群中</li><li>MON 组件负责集群信息同步和处理</li><li>OSD 是集群中真正处理存储的模块 (一个磁盘区对应一个 osd daemon，多个 osd daemon 组成了 osd 集群)</li><li>radosgw 对象存储网关，用来兼容 S3 和 swift 协议</li><li>ceph 读写文件都是按照一个固定文件大小进行的，例如 2MB，因此对大量非常小的文件而言有较大空间和性能损耗</li><li>在 openstack 的后端存储统计中，ceph 占比 81%， lvm 8%，nfs 5%，glusterfs 1%</li></ol><p>ceph 还是不错的，值得一试。</p><p>可以参考的文档：</p><ul><li><a href="https://www.jianshu.com/p/cc3ece850433">ceph 介绍及原理</a></li><li><a href="http://c.biancheng.net/view/9852.html">ceph分布式存储介绍</a></li></ul><h3 id="glusterFS"><a href="#glusterFS" class="headerlink" title="glusterFS"></a>glusterFS</h3><ol><li>通过挂载操作系统的 vfs 进行交互</li><li>通过 复制卷 的方式保证数据安全</li><li>和 lvm 类似，可以组条带化的方案提升性能</li><li>没有中央的 meta 管理，这点和 minio 一样，保持简单，对查询不友好</li></ol><p>可以参考的文档：</p><ul><li><a href="https://blog.csdn.net/zyy1020075955/article/details/127313156">glusterFS</a></li></ul><h3 id="fastdfs"><a href="#fastdfs" class="headerlink" title="fastdfs"></a>fastdfs</h3><p>项目代码地址： <a href="https://github.com/happyfish100/fastdfs">fastdfs</a></p><ol><li>文件直接存储，没有做分块</li><li>大文件要做安全性只有通过复制集，存储量比较大</li><li>C 语言开发</li></ol><h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><ol><li>适合大文件，流式读</li><li>具有强容错能力和扩展能力</li><li>不适合要求延时低的场景</li><li>不适合大量小文件</li></ol><p>可以参考的文档：</p><ul><li><a href="https://www.jianshu.com/p/b3270d74d5fe">hdfs 介绍</a></li></ul><hr><blockquote><p>Neither a lofty degree of intelligence nor imagination nor both together go to the making of genius. Love, love, love, that is the soul of genius.<br>— <cite>Wolfgang Amadeus Mozart</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>minio</tag>
      
      <tag>file storage</tag>
      
      <tag>disk</tag>
      
      <tag>file system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次扒 nginx ingress 的过程</title>
    <link href="/longblog/posts/23_03_06_13_40_nginx_ingress_dig_process.html"/>
    <url>/longblog/posts/23_03_06_13_40_nginx_ingress_dig_process.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近因为 nginx 网关的问题，导致服务有诸多不稳定的风险，因此需要更近一步去做网关的工作。</p><p>之前预判过将来会因无法自定义负载均衡而达不到目标，于是探索过 nginx-ingress 增加自定义负载均衡的方案，详情参见 <a href="/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html" name="记一次有状态服务的负载均衡方案探索" >记一次有状态服务的负载均衡方案探索</a> ，但由于当时业务还没有真正遇到问题，所以也没继续去推这个事儿。</p><p>不过当时的探索比较粗浅，是抱着 <code>能简单解决问题</code> 的目的做的，现在，需要有更多的梳理，以降低大家对这件事的认知复杂度。</p><h2 id="nginx-ingress"><a href="#nginx-ingress" class="headerlink" title="nginx ingress"></a>nginx ingress</h2><p>在 k8s 中，我们有多种提供对外访问的方式，其中业务中用的最多的，就是 ingress controller。 市面上提供的各类 ingress controller 非常多，例如 envoy、treafik、apisix、openresty 等等，我们选用的，是运维同学都比较熟悉的 nginx-ingress-controller。</p><blockquote><p>nginx 的官网参考 <a href="https://nginx.org/en/docs/">nginx.org</a><br>nginx ingress controller 的官网参考 <a href="https://kubernetes.github.io/ingress-nginx/">ingress-nginx</a> , <a href="https://github.com/kubernetes/ingress-nginx">github ingress-nginx</a></p></blockquote><p>先看一下 nginx ingress controller 的工作原理<br><img src="https://static.longalong.cn/img/20230306234451.png"></p><p>在这个过程中，ingress-nginx 的职责是 <strong>接收 api-server 中的资源变化，并转化成 nginx 需要的格式，通过 http 发送给 nginx</strong></p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx 依然是我们熟悉的那个 nginx，但是和传统我们使用的方式不同，所有资源变化的处理，全都是交给  <code>xxx_by_lua</code> ，包括我们本次最需要被扒的 <code>balancer</code> 。</p><p>balancer 的入口文件是 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer.lua">lua/balancer.lua</a> ，可以看到有这样的内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ngx_balancer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ngx.balancer&quot;</span>)<br><span class="hljs-keyword">local</span> round_robin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.round_robin&quot;</span>)<br><span class="hljs-keyword">local</span> chash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.chash&quot;</span>)<br><span class="hljs-keyword">local</span> chashsubset = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.chashsubset&quot;</span>)<br><span class="hljs-keyword">local</span> sticky_balanced = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.sticky_balanced&quot;</span>)<br><span class="hljs-keyword">local</span> sticky_persistent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.sticky_persistent&quot;</span>)<br><span class="hljs-keyword">local</span> ewma = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.ewma&quot;</span>)<br><br><span class="hljs-keyword">local</span> DEFAULT_LB_ALG = <span class="hljs-string">&quot;round_robin&quot;</span><br><span class="hljs-keyword">local</span> IMPLEMENTATIONS = &#123;<br>  round_robin = round_robin,<br>  chash = chash,<br>  chashsubset = chashsubset,<br>  sticky_balanced = sticky_balanced,<br>  sticky_persistent = sticky_persistent,<br>  ewma = ewma,<br>&#125;<br><br><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><span class="hljs-keyword">local</span> balancers = &#123;&#125;<br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_implementation</span><span class="hljs-params">(backend)</span></span><br>  <span class="hljs-keyword">local</span> name = backend[<span class="hljs-string">&quot;load-balance&quot;</span>] <span class="hljs-keyword">or</span> DEFAULT_LB_ALG<br><br>  <span class="hljs-keyword">if</span> backend[<span class="hljs-string">&quot;sessionAffinityConfig&quot;</span>] <span class="hljs-keyword">and</span><br>     backend[<span class="hljs-string">&quot;sessionAffinityConfig&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>] == <span class="hljs-string">&quot;cookie&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> backend[<span class="hljs-string">&quot;sessionAffinityConfig&quot;</span>][<span class="hljs-string">&quot;mode&quot;</span>] == <span class="hljs-string">&quot;persistent&quot;</span> <span class="hljs-keyword">then</span><br>      name = <span class="hljs-string">&quot;sticky_persistent&quot;</span><br>    <span class="hljs-keyword">else</span><br>      name = <span class="hljs-string">&quot;sticky_balanced&quot;</span><br>    <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">elseif</span> backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>] <span class="hljs-keyword">and</span><br>         backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>][<span class="hljs-string">&quot;upstream-hash-by&quot;</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>][<span class="hljs-string">&quot;upstream-hash-by-subset&quot;</span>] <span class="hljs-keyword">then</span><br>      name = <span class="hljs-string">&quot;chashsubset&quot;</span><br>    <span class="hljs-keyword">else</span><br>      name = <span class="hljs-string">&quot;chash&quot;</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> implementation = IMPLEMENTATIONS[name]<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> implementation <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.WARN, backend[<span class="hljs-string">&quot;load-balance&quot;</span>], <span class="hljs-string">&quot; is not supported, &quot;</span>,<br>            <span class="hljs-string">&quot;falling back to &quot;</span>, DEFAULT_LB_ALG)<br>    implementation = IMPLEMENTATIONS[DEFAULT_LB_ALG]<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">return</span> implementation<br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-built_in">setmetatable</span>(_M, &#123;<span class="hljs-built_in">__index</span> = &#123;<br>  get_implementation = get_implementation,<br>  sync_backend = sync_backend,<br>  route_to_alternative_balancer = route_to_alternative_balancer,<br>  get_balancer = get_balancer,<br>  get_balancer_by_upstream_name = get_balancer_by_upstream_name,<br>&#125;&#125;)<br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>其核心作用，就是做 balancer 的注册及获取。</p><p>我们用的是 chash 的方式，对应的代码在 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer/chash.lua">lua/balancer/chash.lua</a> ，内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> balancer_resty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.resty&quot;</span>)<br><span class="hljs-keyword">local</span> resty_chash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;resty.chash&quot;</span>)<br><span class="hljs-keyword">local</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>)<br><span class="hljs-keyword">local</span> ngx_log = ngx.<span class="hljs-built_in">log</span><br><span class="hljs-keyword">local</span> ngx_ERR = ngx.ERR<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><br><span class="hljs-keyword">local</span> _M = balancer_resty:new(&#123; factory = resty_chash, name = <span class="hljs-string">&quot;chash&quot;</span> &#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(self, backend)</span></span><br>  <span class="hljs-keyword">local</span> nodes = util.get_nodes(backend.endpoints)<br>  <span class="hljs-keyword">local</span> complex_val, err =<br>    util.parse_complex_value(backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>][<span class="hljs-string">&quot;upstream-hash-by&quot;</span>])<br>  <span class="hljs-keyword">if</span> err ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>    ngx_log(ngx_ERR, <span class="hljs-string">&quot;could not parse the value of the upstream-hash-by: &quot;</span>, err)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> o = &#123;<br>    instance = <span class="hljs-built_in">self</span>.factory:new(nodes),<br>    hash_by = complex_val,<br>    traffic_shaping_policy = backend.trafficShapingPolicy,<br>    alternative_backends = backend.alternativeBackends,<br>  &#125;<br>  <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br>  <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>  <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.balance</span><span class="hljs-params">(self)</span></span><br>  <span class="hljs-keyword">local</span> key = util.generate_var_value(<span class="hljs-built_in">self</span>.hash_by)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.instance:<span class="hljs-built_in">find</span>(key)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>其实这里面什么都没做，就是封装了一下 resty.chash ，继续扒一下这个库的源码 <a href="https://github.com/openresty/lua-resty-balancer/blob/master/lib/resty/chash.lua">openresty/lua-resty-balancer/lib/resty/chash.lua</a>，内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs lua">ffi.cdef<span class="hljs-string">[[</span><br><span class="hljs-string">typedef unsigned int uint32_t;</span><br><span class="hljs-string"></span><br><span class="hljs-string">typedef struct &#123;</span><br><span class="hljs-string">    uint32_t hash;</span><br><span class="hljs-string">    uint32_t id;</span><br><span class="hljs-string">&#125; chash_point_t;</span><br><span class="hljs-string"></span><br><span class="hljs-string">void chash_point_init(chash_point_t *points, uint32_t base_hash, uint32_t start,</span><br><span class="hljs-string">    uint32_t num, uint32_t id);</span><br><span class="hljs-string">int chash_point_sort(chash_point_t *points, uint32_t size);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int chash_point_add(chash_point_t *old_points, uint32_t old_length,</span><br><span class="hljs-string">    uint32_t base_hash, uint32_t from, uint32_t num, uint32_t id,</span><br><span class="hljs-string">    chash_point_t *new_points);</span><br><span class="hljs-string">int chash_point_reduce(chash_point_t *old_points, uint32_t old_length,</span><br><span class="hljs-string">    uint32_t base_hash, uint32_t from, uint32_t num, uint32_t id);</span><br><span class="hljs-string">void chash_point_delete(chash_point_t *old_points, uint32_t old_length,</span><br><span class="hljs-string">    uint32_t id);</span><br><span class="hljs-string">]]</span><br><br><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><br><span class="hljs-keyword">local</span> clib = load_shared_lib(<span class="hljs-string">&quot;librestychash&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> clib <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;can not load librestychash&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> CONSISTENT_POINTS = <span class="hljs-number">160</span>   <span class="hljs-comment">-- points per server</span><br><span class="hljs-keyword">local</span> pow32 = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>)<br><br><span class="hljs-keyword">local</span> chash_point_t = ffi.typeof(<span class="hljs-string">&quot;chash_point_t[?]&quot;</span>)<br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_precompute</span><span class="hljs-params">(nodes)</span></span><br>// 省略<br>    <span class="hljs-keyword">for</span> id, weight <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(nodes) <span class="hljs-keyword">do</span><br>// 省略<br>        clib.chash_point_init(points, base_hash, start, num, index)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> clib.chash_point_sort(points, npoints) ~= CHASH_OK <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;no memory&quot;</span>)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> ids, points, npoints, newnodes<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(_, nodes)</span></span><br>// 省略<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.reinit</span><span class="hljs-params">(self, nodes)</span></span><br>// 省略<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_delete</span><span class="hljs-params">(self, id)</span></span><br>// 省略<br>    clib.chash_point_delete(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, index)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_incr</span><span class="hljs-params">(self, id, weight)</span></span><br>// 省略<br>    <span class="hljs-keyword">local</span> base_hash = bxor(crc32(<span class="hljs-built_in">tostring</span>(id)), <span class="hljs-number">0xffffffff</span>)<br>    <span class="hljs-keyword">local</span> rc = clib.chash_point_add(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, base_hash,old_weight * CONSISTENT_POINTS, weight * CONSISTENT_POINTS,index, new_points)<br>// 省略<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_decr</span><span class="hljs-params">(self, id, weight)</span></span><br>// 省略<br>    <span class="hljs-keyword">local</span> rc = clib.chash_point_reduce(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, base_hash,from, num, index)<br><span class="hljs-keyword">end</span><br><br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_find_id</span><span class="hljs-params">(points, npoints, hash)</span></span><br>    <span class="hljs-keyword">local</span> step = pow32 / npoints<br>    <span class="hljs-keyword">local</span> index = <span class="hljs-built_in">floor</span>(hash / step)<br><br>    <span class="hljs-keyword">local</span> max_index = npoints - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">-- it seems safer to do this</span><br>    <span class="hljs-keyword">if</span> index &gt; max_index <span class="hljs-keyword">then</span><br>        index = max_index<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">-- find the first points &gt;= hash</span><br>    <span class="hljs-keyword">if</span> points[index].hash &gt;= hash <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">for</span> i = index, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span> <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">if</span> points[i - <span class="hljs-number">1</span>].hash &lt; hash <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> points[i].id, i<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">return</span> points[<span class="hljs-number">0</span>].id, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">for</span> i = index + <span class="hljs-number">1</span>, max_index <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> hash &lt;= points[i].hash <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> points[i].id, i<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> points[<span class="hljs-number">0</span>].id, <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.find</span><span class="hljs-params">(self, key)</span></span><br>    <span class="hljs-keyword">local</span> hash = crc32(<span class="hljs-built_in">tostring</span>(key))<br><br>    <span class="hljs-keyword">local</span> id, index = _find_id(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, hash)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.ids[id], index<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>可以看到，这个文件实现了 <code>find</code> 的方法，而底层 hash 环维护的事交给了 <code>librestychash</code> 这个 clib，继续看一下 <a href="https://github.com/openresty/lua-resty-balancer/blob/master/chash.c">openresty/lua-resty-balancer/chash.c</a>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint32_t</span> crc32_table256[] = &#123;<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x77073096</span>, <span class="hljs-number">0xee0e612c</span>, <span class="hljs-number">0x990951ba</span><br>    <span class="hljs-comment">// 省略……</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">crc32_update</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *crc, u_char *p, <span class="hljs-keyword">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>  c;<br><br>    c = *crc;<br><br>    <span class="hljs-keyword">while</span> (len--) &#123;<br>        c = crc32_table256[(c ^ *p++) &amp; <span class="hljs-number">0xff</span>] ^ (c &gt;&gt; <span class="hljs-number">8</span>);<br>    &#125;<br><br>    *crc = c;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_init_crc</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *arr, <span class="hljs-keyword">uint32_t</span> start, <span class="hljs-keyword">uint32_t</span> base_hash,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> from, <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">chash_point_t</span> *node;<br>    <span class="hljs-keyword">uint32_t</span> i, hash;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">uint32_t</span>                        value;<br>        u_char                          byte[<span class="hljs-number">4</span>];<br>    &#125; prev_hash;<br><br>    prev_hash.value = <span class="hljs-number">0</span>;<br>    node = &amp;arr[start];<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; from + num; i++) &#123;<br>        hash = base_hash;<br>        crc32_update(&amp;hash, prev_hash.byte, <span class="hljs-number">4</span>);<br>        crc32_final(hash);<br><br>        <span class="hljs-keyword">if</span> (i &gt;= from) &#123;<br>            node-&gt;hash = hash;<br>            node-&gt;id = id;<br>            node = node + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* no big performace different in my test */</span><br><br>        <span class="hljs-comment">/* this only works when have little endian */</span><br>        <span class="hljs-comment">// prev_hash.value = hash;</span><br><br>        prev_hash.byte[<span class="hljs-number">0</span>] = (u_char) (hash &amp; <span class="hljs-number">0xff</span>);<br>        prev_hash.byte[<span class="hljs-number">1</span>] = (u_char) ((hash &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>);<br>        prev_hash.byte[<span class="hljs-number">2</span>] = (u_char) ((hash &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>);<br>        prev_hash.byte[<span class="hljs-number">3</span>] = (u_char) ((hash &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_init</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *arr, <span class="hljs-keyword">uint32_t</span> base_hash, <span class="hljs-keyword">uint32_t</span> start,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    chash_point_init_crc(arr, start, base_hash, <span class="hljs-number">0</span>, num, id);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_sort</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> arr[], <span class="hljs-keyword">uint32_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">chash_point_t</span> *points;<br>    <span class="hljs-keyword">chash_point_t</span> *node;<br>    <span class="hljs-keyword">int</span> i, j, index, start, end;<br>    <span class="hljs-keyword">uint32_t</span> min_sz, m, step;<br><br>    <span class="hljs-comment">/* not sure 1.6 is the best */</span><br>    min_sz = n * <span class="hljs-number">1.6</span>;<br>    m = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">while</span> (m &lt;= min_sz) &#123;<br>        m *= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    step = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>) / m;<br><br>    points = (<span class="hljs-keyword">chash_point_t</span> *) <span class="hljs-built_in">calloc</span>(m, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">chash_point_t</span>));<br>    <span class="hljs-keyword">if</span> (points == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        node = &amp;arr[i];<br>        index = node-&gt;hash / step;<br><br>        assert(index &lt; m); <span class="hljs-comment">// index must less than m</span><br><br>        <span class="hljs-keyword">for</span> (end = index; end &gt;= <span class="hljs-number">0</span>; end--) &#123;<br>            <span class="hljs-keyword">if</span> (points[end].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> insert;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (node-&gt;hash &gt;= points[end].hash) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (start = end - <span class="hljs-number">1</span>; start &gt;= <span class="hljs-number">0</span>; start--) &#123;<br>            <span class="hljs-keyword">if</span> (points[start].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">/* left shift before end */</span><br>                <span class="hljs-keyword">for</span> (j = start; j &lt; end; j++) &#123;<br>                    points[j].hash = points[j + <span class="hljs-number">1</span>].hash;<br>                    points[j].id = points[j + <span class="hljs-number">1</span>].id;<br>                &#125;<br><br>                <span class="hljs-comment">/* points[end] is empty now */</span><br><br>                <span class="hljs-comment">/* left shift after end when node-&gt;hash is bigger than them */</span><br>                <span class="hljs-comment">/* only end == index can match this */</span><br>                <span class="hljs-keyword">while</span> (end + <span class="hljs-number">1</span> &lt; m<br>                       &amp;&amp; points[end + <span class="hljs-number">1</span>].id != <span class="hljs-number">0</span><br>                       &amp;&amp; points[end + <span class="hljs-number">1</span>].hash &lt; node-&gt;hash)<br>                &#123;<br>                    points[end].hash = points[end + <span class="hljs-number">1</span>].hash;<br>                    points[end].id = points[end + <span class="hljs-number">1</span>].id;<br>                    end += <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">goto</span> insert;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* full before index, try to append */</span><br><br>        <span class="hljs-keyword">for</span> (end = end + <span class="hljs-number">1</span>; end &lt; m; end++) &#123;<br>            <span class="hljs-keyword">if</span> (points[end].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> insert;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (node-&gt;hash &lt; points[end].hash) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (start = end + <span class="hljs-number">1</span>; start &lt; m; start++) &#123;<br>            <span class="hljs-keyword">if</span> (points[start].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* right shift */</span><br>        <span class="hljs-keyword">for</span> (j = start; j &gt; end; j--) &#123;<br>            points[j].hash = points[j - <span class="hljs-number">1</span>].hash;<br>            points[j].id = points[j - <span class="hljs-number">1</span>].id;<br>        &#125;<br><br>insert:<br>        assert(end &lt; m &amp;&amp; end &gt;= <span class="hljs-number">0</span>);<br><br>        points[end].id = node-&gt;id;<br>        points[end].hash = node-&gt;hash;<br>    &#125;<br><br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (points[i].id != <span class="hljs-number">0</span>) &#123;<br>            arr[j].id = points[i].id;<br>            arr[j].hash = points[i].hash;<br>            j++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(points);<br><br>    <span class="hljs-keyword">return</span> CHASH_OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_add</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *old_points, <span class="hljs-keyword">uint32_t</span> old_length,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> base_hash, <span class="hljs-keyword">uint32_t</span> from, <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">chash_point_t</span> *new_points)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, j, k;<br>    <span class="hljs-keyword">chash_point_t</span> *tmp_points;<br><br>    tmp_points = (<span class="hljs-keyword">chash_point_t</span> *) <span class="hljs-built_in">calloc</span>(num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">chash_point_t</span>));<br>    <span class="hljs-keyword">if</span> (tmp_points == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    chash_point_init_crc(tmp_points, <span class="hljs-number">0</span>, base_hash, from, num, id);<br><br>    <span class="hljs-keyword">if</span> (chash_point_sort(tmp_points, num) != CHASH_OK) &#123;<br>        <span class="hljs-built_in">free</span>(tmp_points);<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    j = num - <span class="hljs-number">1</span>;<br>    k = old_length + num - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (i = old_length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, k--) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp_points[j].hash &gt; old_points[i].hash) &#123;<br>            new_points[k].hash = tmp_points[j].hash;<br>            new_points[k].id = tmp_points[j].id;<br><br>            j--;<br>            k--;<br>        &#125;<br><br>        new_points[k].hash = old_points[i].hash;<br>        new_points[k].id = old_points[i].id;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; j--, k--) &#123;<br>        new_points[k].hash = tmp_points[j].hash;<br>        new_points[k].id = tmp_points[j].id;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(tmp_points);<br><br>    <span class="hljs-keyword">return</span> CHASH_OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_reduce</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *old_points, <span class="hljs-keyword">uint32_t</span> old_length,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> base_hash, <span class="hljs-keyword">uint32_t</span> from, <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, j, k;<br>    <span class="hljs-keyword">chash_point_t</span> *tmp_points;<br><br>    tmp_points = (<span class="hljs-keyword">chash_point_t</span> *) <span class="hljs-built_in">calloc</span>(num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">chash_point_t</span>));<br><br>    chash_point_init_crc(tmp_points, <span class="hljs-number">0</span>, base_hash, from, num, id);<br><br>    <span class="hljs-keyword">if</span> (chash_point_sort(tmp_points, num) != CHASH_OK) &#123;<br>        <span class="hljs-built_in">free</span>(tmp_points);<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; i &lt; old_length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; num<br>            &amp;&amp; old_points[i].hash == tmp_points[j].hash<br>            &amp;&amp; old_points[i].id == id)<br>        &#123;<br>            j++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i != k) &#123;<br>            old_points[k].hash = old_points[i].hash;<br>            old_points[k].id = old_points[i].id;<br>        &#125;<br>        k++;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(tmp_points);<br><br>    <span class="hljs-keyword">return</span> CHASH_OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_delete</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *old_points, <span class="hljs-keyword">uint32_t</span> old_length, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, j;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; old_length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (old_points[i].id == id) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i != j) &#123;<br>            old_points[j].hash = old_points[i].hash;<br>            old_points[j].id = old_points[i].id;<br>        &#125;<br>        j++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是 chash 本身的实现了，比较简单，主要的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> hash;<br>    <span class="hljs-keyword">uint32_t</span> id;<br>&#125; <span class="hljs-keyword">chash_point_t</span>;<br></code></pre></td></tr></table></figure><p>这是一个 point，理解成是 hash 环上的每一个桩就行了，整个 hash 环使用数组来实现。</p><h2 id="我们遇到的问题"><a href="#我们遇到的问题" class="headerlink" title="我们遇到的问题"></a>我们遇到的问题</h2><h3 id="背景场景"><a href="#背景场景" class="headerlink" title="背景场景"></a>背景场景</h3><p>使用的 ingress-nginx 做应用网关，应用中有一个 websocket 的服务，会有大量的连接保持着。 同时，为了让缓存发挥作用，我们使用了 <a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash">nginx consistent hash</a> 的方式让同一个 room 下的连接在同一个 pod 上。</p><p>存在隐患的场景有如下 2 个:</p><ol><li><p>当 ingress 发生变化，<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#worker-shutdown-timeout">ingress-nginx</a>会在<a href="https://nginx.org/en/docs/ngx_core_module.html#worker_shutdown_timeout">一段时间后</a>强制停止 worker 进程。这会导致短时间内大量 websocket 重新连接，无异于一次攻击 🐶 ……</p></li><li><p>当服务进行更新部署时，若采用大批量更新，则会导致短时间大量重连，和场景 1 有异曲同工之效；若采用小批量滚动更新，则会导致部分用户会进行多次重连。</p></li></ol><h3 id="可能的思路"><a href="#可能的思路" class="headerlink" title="可能的思路"></a>可能的思路</h3><h4 id="能否让-hash-环不发生变化？"><a href="#能否让-hash-环不发生变化？" class="headerlink" title="能否让 hash 环不发生变化？"></a>能否让 hash 环不发生变化？</h4><p>从 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer/chash.lua">nginx-ingress/lua/chash.lua</a> 中可以看到，hash 环生成的方式是以 endpoints 为基准的，如果 endpoints 不发生改变，则 hash 环不会发生改变。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(self, backend)</span></span><br>  <span class="hljs-keyword">local</span> nodes = util.get_nodes(backend.endpoints)<br>  // 省略……<br>  <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>ep 是每一个 pod 的 ip，会随着 pod 的更新而更新，所以答案几乎是否定的。(当然还是有一些奇怪的操作可以达到目标，但不常规操作还是少搞的好，不然就是大坑一个)</p><h4 id="能否让负载均衡可控？"><a href="#能否让负载均衡可控？" class="headerlink" title="能否让负载均衡可控？"></a>能否让负载均衡可控？</h4><p>嗯，这个自然是可以的，基本 demo 可以查看 <a href="/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html" name="记一次有状态服务的负载均衡方案探索" >记一次有状态服务的负载均衡方案探索</a></p><p>当然，为了让整套体系能够起作用，还需要做大量的体系性工作，之前有一个简单的 demo，可以查看 <a href="/longblog/posts/23_03_05_23_01_a_record_of_sharing_of_k8s.html#part2: 如何用 operator 玩点有意思的事 " name="记录一次在团队内的k8s分享" > 用 operator 做点有趣的事</a> </p><p>这里可以更细致地做一些原型出来</p><h4 id="能不能让网关重启不会导致连接断掉？"><a href="#能不能让网关重启不会导致连接断掉？" class="headerlink" title="能不能让网关重启不会导致连接断掉？"></a>能不能让网关重启不会导致连接断掉？</h4><p>按照调研，目前市面上能看到 mosn 是做了连接平滑迁移的，这里去看一下，它具体是怎么做到的，有什么优劣？</p><p>mosn 的代码地址： <a href="https://github.com/mosn/mosn">https://github.com/mosn/mosn</a><br>一篇关于 mosn 是怎么做的迁移： <a href="https://mosn.io/blog/posts/nginx-envoy-mosn-hot-upgrade/">nginx vs envoy vs mosn 平滑升级原理</a></p><p>基本结论是： mosn 和 envoy 都使用了 UDS (unix domain sockets) 的技术，这是在 linux 内核 3.5+ 支持的一种文件描述符传递的方案。</p><p>追了一下 mosn 的代码，核心逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// transferHandler is called on recv transfer request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transferHandler</span><span class="hljs-params">(c net.Conn, handler types.ConnectionHandler, transferMap *sync.Map)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferHandler panic %v&quot;</span>, r)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">defer</span> c.Close()<br><br>uc, ok := c.(*net.UnixConn)<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] unexpected FileConn type; expected UnixConn, got %T&quot;</span>, c)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// recv type</span><br>conn, err := transferRecvType(uc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferRecvType error :%v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> conn != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// transfer read</span><br><span class="hljs-comment">// recv header + buffer</span><br>dataBuf, tlsBuf, err := transferReadRecvData(uc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferRecvData error :%v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>connection := transferNewConn(conn, dataBuf, tlsBuf, handler, transferMap)<br><span class="hljs-keyword">if</span> connection != <span class="hljs-literal">nil</span> &#123;<br>transferSendID(uc, connection.id)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>transferSendID(uc, transferErr)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// transfer write</span><br><span class="hljs-comment">// recv header + buffer</span><br>id, buf, err := transferWriteRecvData(uc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferRecvData error :%v&quot;</span>, err)<br>&#125;<br>connection := transferFindConnection(transferMap, <span class="hljs-keyword">uint64</span>(id))<br><span class="hljs-keyword">if</span> connection == <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferFindConnection failed, id = %d&quot;</span>, id)<br><span class="hljs-keyword">return</span><br>&#125;<br>err = transferWriteBuffer(connection, buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferWriteBuffer error :%v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于具体细节的问题，可以再细致看一下代码，或者调试一下。</p><p>关于转移连接描述符的操作，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 老的，发送 fd</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transferSendFD</span><span class="hljs-params">(uc *net.UnixConn, file *os.File)</span> <span class="hljs-title">error</span></span> &#123;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// transfer read</span><br>buf[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> file == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;transferSendFD conn is nil&quot;</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>rights := syscall.UnixRights(<span class="hljs-keyword">int</span>(file.Fd()))<br>n, oobn, err := uc.WriteMsgUnix(buf, rights, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;WriteMsgUnix: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> n != <span class="hljs-built_in">len</span>(buf) || oobn != <span class="hljs-built_in">len</span>(rights) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;WriteMsgUnix = %d, %d; want 1, %d&quot;</span>, n, oobn, <span class="hljs-built_in">len</span>(rights))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 新的，接收 fd</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transferRecvFD</span><span class="hljs-params">(oob []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(net.Conn, error)</span></span> &#123;<br>scms, err := unix.ParseSocketControlMessage(oob)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;ParseSocketControlMessage: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(scms) != <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;expected 1 SocketControlMessage; got scms = %#v&quot;</span>, scms)<br>&#125;<br>scm := scms[<span class="hljs-number">0</span>]<br>gotFds, err := unix.ParseUnixRights(&amp;scm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unix.ParseUnixRights: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(gotFds) != <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;wanted 1 fd; got %#v&quot;</span>, gotFds)<br>&#125;<br>f := os.NewFile(<span class="hljs-keyword">uintptr</span>(gotFds[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;fd-from-old&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br>conn, err := net.FileConn(f)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;FileConn error :%v&quot;</span>, gotFds)<br>&#125;<br><span class="hljs-keyword">return</span> conn, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以画一下流程图，可能更好理解一些。</p><h4 id="能否使用-UDS-解决业务升级问题？"><a href="#能否使用-UDS-解决业务升级问题？" class="headerlink" title="能否使用 UDS 解决业务升级问题？"></a>能否使用 UDS 解决业务升级问题？</h4><p>实现上当然是 ok 的，但不建议这么搞，主要有以下原因：</p><ul><li>业务不是网关，代码的稳定性是很不好的，需要经常变更，为了满足隐藏的一些需求，还是在业务层做特定机制的建设更好。</li><li>我们的服务都运行在容器中，对 k8s 而言，镜像是不可变的，平滑升级导致我们在不可变的镜像中使用了可变的进程，容易出问题。</li></ul><h3 id="我们究竟要解决什么问题？"><a href="#我们究竟要解决什么问题？" class="headerlink" title="我们究竟要解决什么问题？"></a>我们究竟要解决什么问题？</h3><ul><li>让大规模重连尽量不要发生<ul><li>网关独立，不被其他对网关的改动而影响</li><li>使用能平滑迁移的网关，如 mosn</li><li>业务应用平滑启动<ul><li>少量 pod 滚动更新<ul><li>坏处: 部分连接会多次重连(这里涉及 ws 服务目前均衡的具体实现，需要再细看代码) ； </li><li>好处: 对数据库的压力较小 ； </li><li>要解决的问题: ws 服务本身会不会被突然重连的压力搞出问题 =&gt; 加多一些 vnode</li></ul></li><li>蓝绿发布、连接迁移</li></ul></li></ul></li><li>让大规模重连也不会引发重大问题<ul><li>session 机制 (这个我觉得还是很有效的)</li><li>考虑用 redis、甚至内存 的方式做连接信息管理</li><li>限流降级熔断机制<ul><li>网关层限流等</li><li>业务层限流等</li><li>前端自身限流等 (至少不要疯狂重连吧 😂 )</li></ul></li></ul></li><li>其他可能的问题<ul><li>再细致地查一查，经常断掉是怎么发生的，会不会是心跳机制的问题</li><li>内存泄漏和协程泄漏往往是同时发生的，是不是可以把协程池弄上，然后监控起来</li><li>前端的策略还是有很多可讨论的，比如 长期在后台的页面，是不是把连接断了不要连了</li><li>多个连接的价值需不需要再探讨一下？ (不一定，紧要性不高)</li><li>每天晚上的几千个连接还是有点问题的，查一查心里稳妥些</li></ul></li></ul><blockquote><p>实际上，我们可能主要的问题还是 mongodb 索引少建了一个，在此基础上或许一切的问题都是可以堆一点资源就解决的 🐶 ……<br>业务有时候就是这样，解决问题或许比牛逼的技术有更大业务价值……</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>openresty 库中还有很多实用的工具，之后有机会可以详细扒一下，例如:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs text">├── aes.lua<br>├── chash.lua<br>├── cookie.lua<br>├── core<br>│   ├── base.lua<br>│   ├── base64.lua<br>│   ├── ctx.lua<br>│   ├── exit.lua<br>│   ├── hash.lua<br>│   ├── misc.lua<br>│   ├── ndk.lua<br>│   ├── phase.lua<br>│   ├── regex.lua<br>│   ├── request.lua<br>│   ├── response.lua<br>│   ├── shdict.lua<br>│   ├── time.lua<br>│   ├── uri.lua<br>│   ├── utils.lua<br>│   ├── var.lua<br>│   └── worker.lua<br>├── core.lua<br>├── limit<br>│   ├── conn.lua<br>│   ├── count.lua<br>│   ├── req.lua<br>│   └── traffic.lua<br>├── md5.lua<br>├── random.lua<br>├── roundrobin.lua<br>├── sha.lua<br>├── sha1.lua<br>├── sha224.lua<br>├── sha256.lua<br>├── sha384.lua<br>├── sha512.lua<br>├── string.lua<br>└── upload.lua<br></code></pre></td></tr></table></figure><ol start="2"><li><p>另一个常用的负载方式是 chashsubset ，实现在 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer/chashsubset.lua">chashsubset.lua</a> ，后续可以继续扒一下</p></li><li><p>mosn 的实现中还有很多可以参考的地方，比如 wasm 的扩展方式、xprotocal 的扩展方式，看看还是有价值的</p></li></ol><hr><blockquote><p>Anticipate the difficult by managing the easy.<br>— <cite>Laozi</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>code reading</tag>
      
      <tag>nginx</tag>
      
      <tag>nginx ingress</tag>
      
      <tag>ingress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次在团队内的k8s分享</title>
    <link href="/longblog/posts/23_03_05_23_01_a_record_of_sharing_of_k8s.html"/>
    <url>/longblog/posts/23_03_05_23_01_a_record_of_sharing_of_k8s.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天在后端团队中分享了一下 k8s ，之前也有过好几次 k8s 的专题分享，例如 用 devspace 优化开发环境、k8s pod 的生命周期、抓包看看 k8s 网络实现原理…… 都可以算得上是对 k8s 的 「现状」 做的分享。</p><p>这一次换个视角，从 k8s 的 「前世」做分享，企图从 k8s 诞生的历史使命角度，认识 k8s 设计的背景以及原因。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>整个分享分成了 2 part，前半部分从理论上对 k8s 产生的背景 以及 建模设计 做了分享，后半部分分享了用 client-go 实现一个高可扩展的游戏服务器，有几个有意思的技术点。</p><p>分享的视频就先不放了，分享的 PPT 可以通过👇🏻 这个查看，不过光看 ppt 确实有点跳跃，之后时间空点了再把分享的文字稿弄一下。</p><h3 id="part1-站在女娲的视角看-k8s"><a href="#part1-站在女娲的视角看-k8s" class="headerlink" title="part1: 站在女娲的视角看 k8s"></a>part1: 站在女娲的视角看 k8s</h3><iframe src="https://blog.longalong.cn/slides/learn_k8s_on_the_view_of_nvwa/index.html#/" width="100%" height="800px"> 一次 k8s 的分享</iframe><h3 id="part2-如何用-operator-玩点有意思的事"><a href="#part2-如何用-operator-玩点有意思的事" class="headerlink" title="part2: 如何用 operator 玩点有意思的事"></a>part2: 如何用 operator 玩点有意思的事</h3><p>之后玩了一下周末做的游戏 (服务端开发 + 前端接口重新适配)</p><iframe src="https://blog.longalong.cn/slides/play_something_interesting_with_k8s/index.html#/" width="100%" height="800px"> 一次 k8s 的分享</iframe><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整体氛围还是不错的，实践部分的游戏环节也为整个无聊的分享增加了一些趣味 😂 </p><p>另外，上面这个 ppt 是用 <a href="https://github.com/MSzturc/obsidian-advanced-slides">slides</a> 制作的，用 markdown 写的内容，很简洁，可以让我们把精力聚焦到 内容本身 上，值得推荐。 (和以前的 webppt 类似)</p><hr><blockquote><p>Sometimes being a friend means mastering the art of timing. There is a time for silence. A time to let go and allow people to hurl themselves into their own destiny. And a time to prepare to pick up the pieces when it’s all over.<br>— <cite>Octavia E. Butler</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>share</tag>
      
      <tag>团队分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prometheus代码走读</title>
    <link href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html"/>
    <url>/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>prometheus 还是很牛逼的，作为云原生监控系统的事实标准，值得一读。</p><p>生态中对应的还有  AlertManager、pushgateway、operator，之前已经走读过 alertManager 的代码，详见 <a href="/longblog/posts/23_02_09_15_15_code_reading_of_alert_manager.html" name="alertmanager等监控项目源码走读" >alertmanager等监控项目源码走读</a>， 这里，走读一下 pushgateway 和 prometheus 的代码。</p><h2 id="代码走读"><a href="#代码走读" class="headerlink" title="代码走读"></a>代码走读</h2><h3 id="pushgateway"><a href="#pushgateway" class="headerlink" title="pushgateway"></a>pushgateway</h3><ul><li>main.go : 解析参数，启动 server。 http server 用的 promethues 包中的，这在 alertManager 中是一样的。</li><li>handler : 实现各种接口处理, 用闭包的方式，避免了一些全局变量的使用，例如 logger。<ul><li>支持 protobuf 的 encoding 方式，model 在 prometheus 的 client 中定义的 MetricFamily</li><li>使用 parser.TextToMetricFamilies 解析 prometheus 的值</li><li>status.go 中使用了 tempate，并注入了 func，这种方式在一些简单的场景下很好用，毕竟不是所有项目都适合上一套前端框架。</li></ul></li><li>storage : 存储的实现，用的 disk 做存储，存储格式直接用的 gob，在直接存储对象上，非常方便。</li><li>asset : 将 ui 打包到二进制中。</li></ul><p>这个项目的功能和结构虽然都非常简单，但却有很多值得参考的地方，尤其是 使用 gob 直接存对象的方式、直接在 http 接口中使用 protobuf 做解析、将 asset 直接打包到 二进制中、简单场景直接使用 template……</p><h3 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h3><ul><li>cmd : 入口文件，处理 config bind、validate、init，启动服务等。 promtool 提供了 cli 和 prometheus 交互的方式。</li><li>discovery : 抓取的 targets 管理<ul><li>targetGroup 代表一组 target endpoint，而在 scrape.target 中的 Target 则是一个具体的 endpoint。这里可能比较难理解 target 的 url 从哪里来，在 scrape.target.Target.URL() 中可以看到，host、metrics_path 都在 label 中，是特定的 label。</li><li>manager.go : manager 管理接收到的新的 endpoints (map[poolKey]map[string]*targetgroup.Group)，在 startProvider 中对接管道。 provider 是实际的 metrics 的提供者，他们关心 endpoints 的变化。discovery 是发现变化的，例如 file、k8s、zk、http 等。</li><li>registry.go : 使用注册方式，由 config 生成实际的 discovery，然后注册到中心的 hub 中。 类似于 builder 的方式，生成的 discovery 通过 Run() 方法启动。 这种做法很通用，在 grpc 的各种包里也有同样的操作。 </li><li>kubernetes.go<ul><li>使用 cache informer 可以减轻对 k8s api server 的压力，这里的代码参考有价值</li><li>使用 workqueue，把接收到的消息异步处理，避免 event 处理的时序错误。</li></ul></li><li>xds.go : 说是 xds，实际上是 kuma，因为 kuma 是基于 envoy 的，而 xds 则是 envoy 的 discoverys。 这块儿可以进一步看下 envoy 的东西。</li><li>在类似于 http、dns、docker 等方式中，因为没有<code>监听</code>的能力，因此抽象了一个 refresh 的 discovery wrapper。</li></ul></li><li>model : 在业务中使用的模型，包括处理方法。 核心模型定义在 prompb 中。<ul><li>rulefmt : 告警规则的模型</li><li>textparse : 有三种格式，text 格式、proto buffer、openmetrics。结合 go_client 可以拿到 metrics_family。 text 格式的代码是一个不错的词法解析器的参考，另外的参考可以看 go-zero 对 proto 文件的解析。 (当然 promql 也是)</li><li>histogram : 一个 histogram 的实现。</li></ul></li><li>prompb : 核心模型定义</li><li>notifier<ul><li>对 alertmanager 的管理，也有 discovery 的能力，具体在 discovery.legacymanager 中。</li><li>逻辑很简单，Send() 方法吧所有 alerts 存到 queue 中，然后触发 sendall() 。</li><li>接受来自 rule 包的 alerts。</li></ul></li><li>plugins : 目前是注册 discovery 的。</li><li>rules<ul><li>告警规则管理，连接 promql 和 alertmanager。</li><li>分组 (Group)，每个组有一系列具体的监控规则 (rule)，使用 interval 做周期控制，使用 promql 做判断。</li><li>recording.go : 具体的判断 rule (expr)</li><li>alerting.go : alert 的具体状态</li></ul></li><li>scrape<ul><li>抓取 metrics 的具体实现。分 scrape pool 进行抓取，具体的控制过程在 scrapeLoop.scrapeAndReport 中。</li><li>用了 buffer pool 做 bytes 复用。毕竟发起的请求数量很多，可以减少 gc 压力。 具体的 pool 实现在 util.pool 中，可以参考下，这个 pool 做了分 bucket。</li><li>用了 label cache 来保证同一个指标的 label 可以复用而不用重新初始化。</li><li>抓取到数据后的具体的处理逻辑在 scrape.scrapeLoop.append 中，主要是解析指标，并且给 appender 发送数据， appender 是从 scrape.Manager 中传进来的，具体实现在 storage.fanout 中。</li></ul></li><li>util : 一些常用的方法函数， treecache 用 zk 作为具体实现比较有意思。</li><li>web : 提供了 rest api 和 ui。<ul><li>alertmanager 和 pushgateway 都用了把静态资源打包的做法 (http.FS)，但 prometheus 却没有这么做，奇怪。 (更新，还是有的，只是和之前的代码写法有些不一样，用的是 go 的 //go:embed 注释)</li><li>对互联网后端开发而言，很多时候把写 api 作为工作的主体了，但实际上，web 的可能是最简单的部分……</li></ul></li></ul><blockquote><p>最重要的部分放在最后~~</p></blockquote><ul><li>promql : parse 和 query ，具体没怎么看细节。</li><li>storage : tsdb 的接口层，可以对接 remote ，也可以直接使用本地 tsdb。</li><li>tsdb<ul><li>db.go : 启动 tsdb 的入口</li><li>head.go : 插入数据的入口，series 的内存结构等。 是理解数据写入过程的最重要的文件。实际上，head 数据可以看做是 block 在内存中的展开状态，head 中的 chunk 写到一定阶段后就会由 compact 变成 block 存到磁盘中。</li><li>wal.go : 任何的数据操作，都会先写到 log 中，用于保证数据的安全，调用方为 head.Commit。使用 wal 和 checkpoint 是内存数据库非常通用的方法。 checkpoint 的逻辑 和 日志监听的逻辑 在 wlog 中。</li><li>record : 写入 wal 的具体事件的定义。</li><li>compact.go : 处理把数据写入 文件系统 成为一个 block 的过程，包括两类: 把内存中的 head 写入 block；把多个 block 合并，实际调用 index.Writer 和 chunks.Writer 等做实际写入操作。</li><li>block.go : 数据块的定义和操作，管理 读取、写入 block。一个数据块就是 一段时间内的所有数据的集合，包括 采集的指标值 和 指标本身的信息。 是数据最终的存在形态，数据通路是 db =&gt; head =&gt; chunk =&gt; block 。</li><li>chunks 和 chunkenc : chunk 的定义和操作。 chunkenc 中包含了几种 chunk 的序列化方法。</li><li>fileutil : 一些 file 的操作封装<ul><li>mmap : 文件内存映射。是读取 chunk 的方式，保证了低内存占用。</li></ul></li><li>index<ul><li>是理解 <code>持久化</code> 和 <code>查询</code> 最好的方式，分为 符号表 (用于压缩空间)、序列表(用于关联 chunks)、label表和posting表 (用于查询及关联 label 和 name) 以及 TOC (用于定位上述几张表)</li></ul></li><li>有几个重点：<ul><li>理解 series 的概念: 特定的 label 集合。 (series =&gt; labels.Labels)</li><li>理解 series 在内存中的状态 (stripeSeries =&gt; memSeries =&gt; headChunk =&gt; mmapchunk)</li><li>理解 block 的生成流程: series.headchunk =&gt; mmapchunk =&gt; compact/index/meta =&gt; block</li><li>理解一个数据写入的流程: labels+val =&gt; series + val =&gt; chunk</li></ul></li></ul></li></ul><p>设计上的想法:</p><ul><li>对于稍微复杂点的项目，一定会走上分层的道路，分层之后有逐渐会形成以 接口 为传递方式的调用 (而不是实例，否则要写 n 多类似的方法来兼容不同的type)。 接口化之后的好处是 单层内代码更简洁了；坏处是 想要跨层走一次流程会很懵，因为不知道具体的实现方是谁 (一般分层后每层都可能实现相同的方法)。</li></ul><h2 id="一些非常好的参考资料"><a href="#一些非常好的参考资料" class="headerlink" title="一些非常好的参考资料"></a>一些非常好的参考资料</h2><ul><li><a href="https://github.com/prometheus/prometheus/tree/main/tsdb/docs/format">官方文档 tsdb 的序列化结构</a> </li><li><a href="https://ganeshvernekar.com/blog/prometheus-tsdb-the-head-block">prometheus TSDB</a></li><li><a href="https://web.archive.org/web/20210622211933/https://fabxc.org/tsdb/">prometheus 发起人的博客</a></li></ul><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="你想要什么？"><a href="#你想要什么？" class="headerlink" title="你想要什么？"></a>你想要什么？</h3><ul><li>数据库具体究竟是怎么工作的？<ul><li>wal 的具体实现</li><li>block 的具体实现</li></ul></li><li>为什么我们现在脱离了数据库就没法写代码了一样？</li><li>一个这种级别的项目会花多少精力？<ul><li>prometheus 的发起人开始也是自己就发布了版本，而且还做了好多其他项目，这些牛逼的人为什么牛逼？</li></ul></li><li>项目成功的要素有哪些？<ul><li>能力、生态</li></ul></li><li>如何让读源码的收益最大化？<ul><li>通过: 阅读代码<ul><li>知道各自的职能是什么</li><li>知道各自是怎么实现的</li><li>知道相互是怎么连接的</li></ul></li><li>得到: 数据结构 + 过程演变</li><li>最好能: 临摹代码</li><li>如何把这件事做好?<ul><li>先可以大量实践一下，找到一些好的形态</li></ul></li><li>如何像一台机器一样阅读源码？<ul><li>主线流程跑一次</li><li>用 debug</li></ul></li></ul></li><li>LSM tree 和 其他数据库存储模型</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>找一个 LSM tree 的数据库实现看一下 <a href="/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html" name="golevelDB源码走读" >golevelDB源码走读</a></li><li>找一个 B+ tree 的数据库实现看一下 <a href="/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html" name="golevelDB源码走读" >golevelDB源码走读</a></li><li>对 k8s 的部分代码走读一下 <a href="/notpublish/index.html" name="k8s部分源码走读" >k8s部分源码走读</a></li></ul><hr><blockquote><p>We may encounter many defeats, but we must not be defeated.<br>— <cite>Maya Angelou</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>code reading</tag>
      
      <tag>monitor</tag>
      
      <tag>prometheus</tag>
      
      <tag>pushgateway</tag>
      
      <tag>代码走读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于磁盘和网络的性能的问题</title>
    <link href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html"/>
    <url>/longblog/posts/22_11_23_23_02_disk_performance_and_network.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一般我们在两种场景下关心磁盘的性能：</p><ul><li>pc 机拷贝文件时</li><li>服务器运行有磁盘 io 的服务时</li></ul><p>在 pc 机上，windows 下有各种磁盘跑分工具，一搜就有。</p><p>在服务器上，也有一系列工具。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>iops</li><li>throughput</li><li>latency</li><li>capacity</li><li>块存储和文件系统</li></ul><p>关于 iops、throughput、latency 之间的关系，可以直接认为 throughput = iops * 块大小。 latency 是另一个方面的参数。</p><p>关于一些概念的基本认识，可以参考 <a href="https://louwrentius.com/understanding-storage-performance-iops-and-latency.html">这篇文章</a></p><blockquote><p>还可以参考文章：<br><a href="https://www.brentozar.com/archive/2021/12/how-do-you-test-iops-latency-and-throughput/">参考1</a> 、<a href="https://www.site24x7.com/learn/linux/iops-throughput.html">参考2</a></p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>块存储的测试可以使用 fio，使用方式可以参考 <a href="https://help.aliyun.com/document_detail/147897.html">aliyun 磁盘性能测试</a></p><p>其他测试工具可以使用 dd、sysbench 等，可以参考 <a href="https://linuxhint.com/benchmark_hard_disks_linux/">How to Benchmark Hard Disks in Linux</a></p><p>可以使用 iostat、iotop 等方式进行磁盘 io 观测</p><p>之前用 sysbench 做了阿里云 ECS 自带的磁盘，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs text">sysbench 1.0.18 (using system LuaJIT 2.1.0-beta3)<br><br>Running the test with following options:<br>Number of threads: 1<br>Initializing random number generator from current time<br><br><br>Extra file open flags: (none)<br>128 files, 16MiB each<br>2GiB total file size<br>Block size 16KiB<br>Number of IO requests: 0<br>Read/Write ratio for combined random IO test: 1.50<br>Periodic FSYNC enabled, calling fsync() each 100 requests.<br>Calling fsync() at the end of test, Enabled.<br>Using synchronous I/O mode<br>Doing random r/w test<br>Initializing worker threads...<br><br>Threads started!<br><br><br>File operations:<br>    reads/s:                      2897.98<br>    writes/s:                     1931.98<br>    fsyncs/s:                     6182.45<br><br>Throughput:<br>    read, MiB/s:                  45.28<br>    written, MiB/s:               30.19<br><br>General statistics:<br>    total time:                          10.0192s<br>    total number of events:              110225<br><br>Latency (ms):<br>         min:                                    0.00<br>         avg:                                    0.09<br>         max:                                   25.22<br>         95th percentile:                        0.45<br>         sum:                                 9979.91<br><br>Threads fairness:<br>    events (avg/stddev):           110225.0000/0.00<br>    execution time (avg/stddev):   9.9799/0.00<br></code></pre></td></tr></table></figure><blockquote><p>还可以参考的文章<br><a href="https://fio.readthedocs.io/en/latest/index.html">fio 官方文档</a><br><a href="https://cloud.tencent.com/developer/article/1500430">一个腾讯用户的fio使用记录</a></p></blockquote><h2 id="感性数据"><a href="#感性数据" class="headerlink" title="感性数据"></a>感性数据</h2><p>对于 hdd 而言，延迟大约为 10ms，throughput 在 100MB ~ 500MB<br>对于 ssd 而言，延迟大约为 1ms，throughput 可达到 500MB ~ 2000MB</p><p>容量上<br>常见的 hdd 目前基本都在 1TB 以上，高的可达到 10TB<br>常见的 ssd 容量有 128GB、256GB、512GB、1TGB</p><h2 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h2><p>提升 ssd 性能的好方式是： 换更高性能的设备<br>提升 hdd 性能的好方式是： 组 raid ，可以参考 <a href="/longblog/posts/21_12_02_operation_of_raid_with_lvm.html" name="使用lvm实现raid能力" >使用lvm实现raid能力</a></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>磁盘性能的监控，可以使用 prometheus 的 node exporter ，可以参考 <a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html" name="简单的集群监控方案" >简单的集群监控方案</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>关于网络 io 的性能，可以使用 <a href="https://github.com/esnet/iperf">iperf</a><ul><li>另外，百度的 <a href="https://github.com/baidu/dperf/blob/main/README-CN.md">dperf</a> 也可以参考下</li></ul></li><li>cpu 的性能测试比较复杂，可以参考 <a href="https://www.cpubenchmark.net/cpu_test_info.html">这个文档</a></li></ul><h2 id="iperf-测试"><a href="#iperf-测试" class="headerlink" title="iperf 测试"></a>iperf 测试</h2><ul><li><p>centos安装 iperf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ih ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/fedora/linux/updates/24/x86_64/i/iperf3-3.1.3-1.fc24.x86_64.rpm<br></code></pre></td></tr></table></figure></li><li><p>一台机器上跑server端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -s -p 8800<br></code></pre></td></tr></table></figure></li><li><p>另一台机器跑 client 端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -c 172.24.33.3 -p 8800<br></code></pre></td></tr></table></figure></li><li><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">[  4] local 172.24.33.4 port 39594 connected to 172.24.33.3 port 8800<br>[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd<br>[  4]   0.00-1.00   sec   236 MBytes  1.98 Gbits/sec  1315    543 KBytes<br>[  4]   1.00-2.00   sec  96.9 MBytes   813 Mbits/sec  1471    549 KBytes<br>[  4]   2.00-3.00   sec   117 MBytes   981 Mbits/sec  1845    168 KBytes<br>[  4]   3.00-4.00   sec   139 MBytes  1.16 Gbits/sec  2251    433 KBytes<br>[  4]   4.00-5.00   sec   111 MBytes   931 Mbits/sec  1891    298 KBytes<br>[  4]   5.00-6.00   sec   123 MBytes  1.03 Gbits/sec  1370    414 KBytes<br>[  4]   6.00-7.00   sec   117 MBytes   979 Mbits/sec  1860   93.3 KBytes<br>[  4]   7.00-8.00   sec   108 MBytes   905 Mbits/sec  1766    614 KBytes<br>[  4]   8.00-9.00   sec   109 MBytes   917 Mbits/sec  1141    614 KBytes<br>[  4]   9.00-10.00  sec   111 MBytes   927 Mbits/sec  1782   1.41 KBytes<br>- - - - - - - - - - - - - - - - - - - - - - - - -<br>[ ID] Interval           Transfer     Bandwidth       Retr<br>[  4]   0.00-10.00  sec  1.24 GBytes  1.06 Gbits/sec  16692             sender<br>[  4]   0.00-10.00  sec  1.23 GBytes  1.06 Gbits/sec                  receiver<br><br>iperf Done.<br></code></pre></td></tr></table></figure><p>这是阿里云下某规格机器的内网带宽，大概 1Gbits/s</p></li><li><p>测试一下 udp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -c 172.24.33.3 -p 8800 -u<br></code></pre></td></tr></table></figure></li><li><p>额 结果不大懂了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">Accepted connection from 172.24.33.3, port 50166<br>[  5] local 172.24.33.4 port 8800 connected to 172.24.33.3 port 48329<br>[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams<br>[  5]   0.00-1.00   sec   116 KBytes   950 Kbits/sec  0.006 ms  0/116 (0%)<br>[  5]   1.00-2.00   sec   128 KBytes  1.05 Mbits/sec  0.007 ms  0/128 (0%)<br>[  5]   2.00-3.00   sec   128 KBytes  1.05 Mbits/sec  0.003 ms  0/128 (0%)<br>[  5]   3.00-4.00   sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]   4.00-5.00   sec   128 KBytes  1.05 Mbits/sec  0.004 ms  0/128 (0%)<br>[  5]   5.00-6.00   sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]   6.00-7.00   sec   128 KBytes  1.05 Mbits/sec  0.004 ms  0/128 (0%)<br>[  5]   7.00-8.00   sec   128 KBytes  1.05 Mbits/sec  0.006 ms  0/128 (0%)<br>[  5]   8.00-9.00   sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]   9.00-10.00  sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]  10.00-10.04  sec  0.00 Bytes  0.00 bits/sec  0.005 ms  0/0 (0%)<br>- - - - - - - - - - - - - - - - - - - - - - - - -<br>[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams<br>[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec  0.005 ms  0/1268 (0%)<br></code></pre></td></tr></table></figure></li><li><p>抓了下 udp 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump <span class="hljs-string">&quot;udp port 8800&quot;</span> -vv<br></code></pre></td></tr></table></figure></li><li><p>发现全是报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">00:22:50.287602 IP (tos 0x0, ttl 64, id 38886, offset 0, flags [+], proto UDP (17), length 1500)<br>    172.24.33.3.35427 &gt; iZj6c50uwswovavwjj5dqoZ.sunwebadmin: UDP, bad length 8192 &gt; 1472<br>00:22:50.287677 IP (tos 0x0, ttl 64, id 38887, offset 0, flags [+], proto UDP (17), length 1500)<br>    172.24.33.3.35427 &gt; iZj6c50uwswovavwjj5dqoZ.sunwebadmin: UDP, <br></code></pre></td></tr></table></figure></li><li><p>查了下，发现是包大小限制了，<a href="https://iota.stackexchange.com/questions/756/possible-udp-mtu-problems-udp-bad-length-1650-1368-in-tcpdump">可以参考这个</a></p></li><li><p>iperf 默认的 udp 包大小是 8k， 可以通过 <code>-l</code> 修改</p></li><li><p>修改大小为 1k</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -c 172.24.33.3 -p 8800 -u -l 1024<br></code></pre></td></tr></table></figure></li><li><p>虽然抓包没问题了，但是结果还是不大行，原因未知，回头再看吧</p><ul><li>似乎只能看 udp 的丢包率</li></ul></li></ul><h3 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h3><ul><li><a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html" name="WIP-kafka的高吞吐原因" >WIP-kafka的高吞吐原因</a></li><li><a href="/longblog/posts/22_11_06_01_47_some_thought_of_performance.html" name="压测的一些思考" >压测的一些思考</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/longblog/posts/21_12_02_how_to_do_load_test.html" name="如何做好压测" >如何做好压测</a></li><li><a href="/longblog/posts/22_11_06_01_49_some_thought_about_performance.html" name="关于压测本身的梳理" >关于压测本身的梳理</a></li><li><a href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html" name="记一次服务性能的调优排查" >记一次服务性能的调优排查</a></li></ul><hr><blockquote><p>Love is the only force capable of transforming an enemy into a friend.<br>— <cite>Martin Luther King Jr.</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>磁盘</tag>
      
      <tag>disk</tag>
      
      <tag>performance</tag>
      
      <tag>fio</tag>
      
      <tag>sysbench</tag>
      
      <tag>iperf</tag>
      
      <tag>iperf3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次有状态服务的负载均衡方案探索</title>
    <link href="/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html"/>
    <url>/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的服务是有状态服务，服务在提供对外访问时，需要负载到特定节点。</p><h2 id="基本方案"><a href="#基本方案" class="headerlink" title="基本方案"></a>基本方案</h2><p>一般来说，这种特定节点的负载均衡有两种基本方案：</p><ol><li>重定向</li><li>代理模式</li></ol><p>一起来看一下几个有状态服务的集群处理方式：</p><ul><li>Redis 在 6.0 以前是直接的采用 重定向 的方式，6.0 也提供了集群内代理的模式。 </li><li>Redis 的 codis 版集群，采用的是 代理模式。</li><li>Mycat 数据库代理采用的是 代理模式。</li><li>Mongodb cluster 采用的是 mongos 代理。</li><li>Kafka 采用的是客户端自定义的负载均衡方式，整体来看是 重定向方式 (根据 partition 的位置决定地址)。</li></ul><p>基本可以认为，负载均衡的这两种策略没有太大的优劣之分，只要实现好 client，对业务方来说，区别不大。</p><p>由于代理模式对机器资源的消耗更多，并且将来维护更加复杂，于是我选择先采用 重定向 的策略，这需要有两方面改动：</p><ol><li>所有节点均知道特定的 key 应该到哪一个具体的 节点。</li><li>返回的重定向数据，能够达到正确的节点。</li></ol><p>下面分别解决这两个问题。</p><h2 id="解决负载信息同步问题"><a href="#解决负载信息同步问题" class="headerlink" title="解决负载信息同步问题"></a>解决负载信息同步问题</h2><p>在业务侧，需要通过类似于 注册中心的机制，用于确定不同的 key 对应的 节点地址。这个注册中心有两种可供参考的模式： ① 无状态的包，所有状态通过中央存储( eg: redis/etcd ) 进行共享。② 状态交由特定的服务进行维护，其他 client 通过调用这个服务的接口获取信息。</p><p>第一种方案，类似于 k8s 的设计，所有源信息全在 etcd 中，各模块均通过监听 etcd 中的元信息变化做出自己的动作，这样做的好处是 轻量化，仅需要约定好数据结构即可，不用维护单独的服务，但为避免误用，需要提供 SDK。</p><p>第二种方案，类似于 mongodb 中的 config-server ，所有元信息交由 config-server 维护，其他节点 (mongos)通过本地缓存的方式提升性能。 这种方式的好处在于 权责分明，在没有太多精力维护 sdk 的情况下，这种方式更不容易出错。</p><p>其实，也可以认为还有第三种方案： 去中心化方案。类似于 redis 的集群通信方式，每个节点都存着一份整个集群的信息，并且通过一定的方式保证集群内数据一致性。但这种方式的实现更加复杂，也没有看到有什么更大的价值，暂不考虑。</p><p>在我的基本实现中，采用 抢占式 的模式，用 redis 做状态同步，整个流程类似于 “分布式锁” 的过程，可以达到负载到特定节点的目的，但整体比较粗糙，将来的可扩展性也不是很好。</p><p>不过值得参考的是，该实现中，采用了 redis 的 watch 机制，可以在各节点做本地缓存，有更新后也能更新缓存。这是一个很不错的技术点。</p><p>在将来要实现的版本中，应当是由一个服务来做负载均衡的策略，包括收集节点状态、新节点启动、老节点清理、数据迁移 等操作。 这部分可以更多参考 mongodb 的 config-server 相关设计。</p><p>在保证了注册中心机制后，就是网络路由问题了。</p><h2 id="解决-nginx-定向路由问题"><a href="#解决-nginx-定向路由问题" class="headerlink" title="解决 nginx 定向路由问题"></a>解决 nginx 定向路由问题</h2><p>由于服务是在内网中，也不能将内网服务的 ip 直接暴露在公网上，因此，要有从公网路由到内网特定节点的能力。</p><p>我们目前采用的是 k8s 的部署方式，网关处使用 nginx-ingress 进行路由 和 负载均衡。nginx-ingress 默认提供了 轮询、加权、hash、一致性hash 的负载均衡策略，且 hash 函数不是我们能指定的。因此，这些策略无法满足我们的需求。</p><p>不过 nginx-ingress 提供了自定义负载均衡策略的方式(通过 lua 脚本)，也就意味着我们能够自定义负载均衡策略。</p><p>以下是基本实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- file longbalancer.lua</span><br><span class="hljs-keyword">local</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>)<br><br><span class="hljs-keyword">local</span> string_format = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span><br><span class="hljs-keyword">local</span> ngx_log = ngx.<span class="hljs-built_in">log</span><br><span class="hljs-keyword">local</span> INFO = ngx.INFO<br><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(self, backend)</span></span><br>  <span class="hljs-keyword">local</span> o = &#123;<br>    name = <span class="hljs-string">&quot;longbalance&quot;</span><br>  &#125;<br>  o.addrs, o.addrList, o.nums = util.get_addrs(backend.endpoints)<br>  o.eps = util.get_nodes(backend.endpoints)<br>  o.nowLen = <span class="hljs-number">0</span><br><br>  <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br><br>  <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>  <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.sync</span><span class="hljs-params">(self, backend)</span></span><br><br>  <span class="hljs-keyword">local</span> eps = util.get_nodes(backend.endpoints)<br>  <span class="hljs-keyword">local</span> changed = <span class="hljs-keyword">not</span> util.deep_compare(<span class="hljs-built_in">self</span>.eps, eps)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> changed <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  ngx_log(INFO, string_format(<span class="hljs-string">&quot;nodes have changed for backend %s&quot;</span>, backend.name))<br><br>  <span class="hljs-built_in">self</span>.addrs, <span class="hljs-built_in">self</span>.addrList, <span class="hljs-built_in">self</span>.nums= util.get_addrs(backend.endpoints)<br>  <span class="hljs-built_in">self</span>.eps = eps<br>  <span class="hljs-built_in">self</span>.nowLen = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.balance</span><span class="hljs-params">(self)</span></span><br>  <span class="hljs-keyword">local</span> balance_by = ngx.var[<span class="hljs-string">&quot;balance_by&quot;</span>]<br>  <span class="hljs-keyword">if</span> balance_by == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>    balance_by = <span class="hljs-string">&quot;$docdoc&quot;</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> balance_val = util.lua_ngx_var(balance_by)<br><br>  ngx_log(INFO, string_format(<span class="hljs-string">&quot;balance key is : %s, val is : %s&quot;</span>, balance_by,balance_val))<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">self</span>, balance_val)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.getnext</span><span class="hljs-params">(self)</span></span> <br>    <span class="hljs-keyword">local</span> addr = <span class="hljs-built_in">self</span>.addrList[<span class="hljs-built_in">self</span>.nowLen]<br><br>    <span class="hljs-built_in">self</span>.nowLen = <span class="hljs-built_in">self</span>.nowLen + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.nowLen == <span class="hljs-built_in">self</span>.nums <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">self</span>.nowLen = <span class="hljs-number">0</span>    <br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> addr<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.find</span><span class="hljs-params">(self, balance_val)</span></span><br>  <span class="hljs-keyword">local</span> addr<br><br>  <span class="hljs-keyword">if</span> balance_val == <span class="hljs-literal">nil</span> <span class="hljs-keyword">or</span> balance_val == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">or</span> balance_val == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    addr = <span class="hljs-built_in">self</span>.getnext(<span class="hljs-built_in">self</span>)  <br>    <span class="hljs-keyword">return</span> addr<br>  <span class="hljs-keyword">end</span><br><br>  addr = <span class="hljs-built_in">self</span>.addrs[balance_val]<br>  <span class="hljs-keyword">if</span> addr == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>    addr = <span class="hljs-built_in">self</span>.getnext(<span class="hljs-built_in">self</span>)  <br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">return</span> addr<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br><br><span class="hljs-comment">-- file util.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.get_addrs</span><span class="hljs-params">(endpoints)</span></span><br>  <span class="hljs-keyword">local</span> addrs = &#123;&#125;<br>  <span class="hljs-keyword">local</span> addrList = &#123;&#125;<br>  <span class="hljs-keyword">local</span> nums = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">for</span> _, endpoint <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(endpoints) <span class="hljs-keyword">do</span><br>    addrs[endpoint.address] = endpoint.address .. <span class="hljs-string">&quot;:&quot;</span> .. endpoint.port<br>    addrList[nums] = endpoint.address .. <span class="hljs-string">&quot;:&quot;</span> .. endpoint.port<br>    nums = nums + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">return</span> addrs, addrList, nums<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>然后在 balancer.lua 文件中导入 longbalancer 即可。</p><p>另外，为了服务能够使用正确的负载均衡策略，需要在 服务的 ingress 中添加如下注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">nginx.ingress.kubernetes.io/configuration-snippet: |<br>      set $docdoc $arg_insip; # 设置负载均衡参数<br>nginx.ingress.kubernetes.io/load-balance: longbalance  # 选择负载均衡策略<br></code></pre></td></tr></table></figure><p>自此，nginx 拥有了根据特定的参数进行定向路由的能力。<br>[鼓掌 ！ 👏]</p><p>这里实际上是有优化空间的，有两个方向：</p><ol><li>添加 缓存 =&gt; documentID : insip 在nginx进行缓存，没有传 insip 的参数时，先通过缓存判断，没有再走轮询。</li><li>直接接入向 config-server 访问的能力，在网关层直接定位到确定的节点，而不是靠重定向。</li></ol><p>各有优劣，之后再做分析</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>gateway</tag>
      
      <tag>nginx</tag>
      
      <tag>load balancer</tag>
      
      <tag>stateful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质量保证梳理</title>
    <link href="/longblog/posts/22_07_16_20_02_some_thing_about_qa.html"/>
    <url>/longblog/posts/22_07_16_20_02_some_thing_about_qa.html</url>
    
    <content type="html"><![CDATA[<p>对于一些需求的实现，使用checklist的方式，回答清楚每一个跟质量相关的问题，帮助开发人员梳理清楚对于质量保证而言最重要的事是什么，做到质量保证“能落地”。</p><h3 id="问题列表："><a href="#问题列表：" class="headerlink" title="问题列表："></a>问题列表：</h3><h4 id="如何保证质量？"><a href="#如何保证质量？" class="headerlink" title="如何保证质量？"></a>如何保证质量？</h4><p>首先得定义质量，要能对质量进行衡量</p><p>对于一个软件项目而言，质量意味着什么</p><h5 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h5><ul><li>以当前的资源部署下，在业务上，能支撑多少业务量 (tps/qps)？</li><li>最早遇到性能瓶颈的模块是什么 ？</li><li>最简单能解决该性能瓶颈的方法是什么，解决成本怎么样？</li><li>从设计上，需要达到20-100倍的设计标准，当前的方案能否达到目标？</li><li>扩容/缩容的成本如何？</li></ul><h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><ul><li>当前设计是否存在单点故障？</li><li>极端情况下，是否能够正常提供共服务(流量突增、恶意刷接口)？</li><li>节点故障是否会影响到正常使用(部分节点宕机)？</li><li>功能是否具备 feature toggle？</li><li>功能是否具备回滚能力？</li><li>若发生错误，是否能第一时间得到通知？</li><li>若发生错误，是否任何人都能快速定位到问题？</li></ul><h5 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h5><ul><li>预计可能的功能拓展有些什么？可能的功能需要增加哪些内容？</li><li>是否是插件化设计，组件的替换成本如何？</li><li>对于较大的功能模块，是否有比较明显的设计模式说明？</li><li>功能是否具有两个以上的人熟悉，做到维护人员冗余？</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>是否有详细的说明文档、设计文档、沟通文档、项目过程文档？</li><li>是否有针对于项目结构/模块设计/代码风格与他人进行沟通讨论？</li><li>是否有完善的单元测试及集成测试？</li><li>是否进行过技术探讨与反思？例如当前项目的主要问题是什么？解决的优先级是怎样的？当前的解决方案是否具有通用性？能否有所沉淀以成为通用组件？等</li></ul><h4 id="如何用测试来保障质量？"><a href="#如何用测试来保障质量？" class="headerlink" title="如何用测试来保障质量？"></a>如何用测试来保障质量？</h4><p>测试 是更接近实际的一种质量保证手段。</p><h5 id="2-1-如何保证功能的正确性？"><a href="#2-1-如何保证功能的正确性？" class="headerlink" title="2.1 如何保证功能的正确性？"></a>2.1 如何保证功能的正确性？</h5><h6 id="单元测试-集成测试"><a href="#单元测试-集成测试" class="headerlink" title="单元测试/集成测试"></a>单元测试/集成测试</h6><ul><li><p>如何保证(自动化)单元测试的覆盖率</p></li><li><p>学习QA如何写测试用例</p></li><li><p>做测试的代码覆盖率检查</p><h6 id="如何能快速管理集成测试"><a href="#如何能快速管理集成测试" class="headerlink" title="如何能快速管理集成测试"></a>如何能快速管理集成测试</h6></li><li><p>super_test 项目</p></li></ul><h6 id="如何保证集成测试的场景覆盖率"><a href="#如何保证集成测试的场景覆盖率" class="headerlink" title="如何保证集成测试的场景覆盖率"></a>如何保证集成测试的场景覆盖率</h6><ul><li>学习 QA 如何写测试用例</li><li>先以一系列场景为例，实际写一堆用例再来回答这个问题</li></ul><h5 id="2-2-如何保证性能和可扩展性？"><a href="#2-2-如何保证性能和可扩展性？" class="headerlink" title="2.2 如何保证性能和可扩展性？"></a>2.2 如何保证性能和可扩展性？</h5><h6 id="性能测试、故障演练-性能瓶颈"><a href="#性能测试、故障演练-性能瓶颈" class="headerlink" title="性能测试、故障演练(性能瓶颈)"></a>性能测试、故障演练(性能瓶颈)</h6><p>性能测试主要为 <code>单模块性能测试</code> 和 <code>链路集成测试</code></p><p>对于模块的测试，可以先站在基础架构的角度，考虑模块的可扩展性，再站在实际使用的角度，从业务角度测试性能。</p><p>例如，对于messenger的压测，可以先考虑当前使用的 redis、mongo、kafka 的本身的拓展能力，得到在不同流量级别下这些模块的性能。</p><p>然后，考虑 messenger 目前提供的服务内容，针对每个业务内容，进行单独的测试，类似于单接口测试。然后对多接口进行测试，考虑不同接口之间的相互影响因素。</p><p>对于链路压测，需要考虑 1. 链路范围界定 2. mock 服务。(ps: 可以考虑 mock 为正常服务的一个切面)</p><h5 id="2-3-自动化性能测试平台的构想"><a href="#2-3-自动化性能测试平台的构想" class="headerlink" title="2.3 自动化性能测试平台的构想"></a>2.3 自动化性能测试平台的构想</h5><p>对于业务的性能测试，压测的情况越接近于真实业务情况的压测约具有说服力。因此，性能测试是要尽量模拟真实的业务场景。</p><p>但对于一个变化较快的业务，或者一个新的业务，是很难准确估计真实的业务流量模型的。</p><p>这种时候最好的方式是对多个可能的变量进行笛卡尔积，然后对每种情况进行压测。</p><p>举个例子，messenger 可能面临的业务流量模型有很多，其中 总连接数、单个房间人数、房间个数、首页关注人数、changeset 发送频率、changeset 大小、广播消息类型/频率 等都是可能的变量</p><p>例如，平均一个房间10个人，单实例上 100 个房间，总连接 5000 时，用户以 6帧/s 的速度发送 800 byte 大小的 changeset，那么，对于资源的耗用情况如何？</p><p>如果要对每一种情况进行手工压测，那么其成本是巨大的。</p><p>从 do not repeat yourself 的角度出发，这应该是一个可以自动化的流程。</p><p>对于压测人员，需要做的是： 1. 找出约束的变量，配置关注的变量值。 2. 对结果进行分析并做近一步的确认。</p><p>自动化性能测试平台最好是一个可以适应多种场景的通用化平台，支持自定义的压测脚本、自定义的压测报告、自定义的压测策略，</p><p>应该支持多种消息格式，例如 http、https、ws、wss、grpc、mqtt 等。</p><p>对于这个平台的搭建，一定要仔细去分析 jmeter、metersphere 这两个平台的逻辑以及设计。</p><h5 id="2-4-如何保证可靠性？"><a href="#2-4-如何保证可靠性？" class="headerlink" title="2.4 如何保证可靠性？"></a>2.4 如何保证可靠性？</h5><ul><li>  边界测试、极端测试、混沌测试、故障演练(错误故障)</li></ul><h6 id="可以考虑以下内容："><a href="#可以考虑以下内容：" class="headerlink" title="可以考虑以下内容："></a>可以考虑以下内容：</h6><ul><li>  api的边界测试交给中间件来进行。</li><li>  梳理可能的错误点，并考虑故障注入的方式。</li><li>  跳出代码逻辑去考虑错误故障，目标是得到尽可能全的故障类型，并针对每个可能的故障进行故障排查及恢复演练。</li></ul><h6 id="当前最紧要的事："><a href="#当前最紧要的事：" class="headerlink" title="当前最紧要的事："></a>当前最紧要的事：</h6><ul><li>  故障演练的规范化。</li></ul><h5 id="2-5-如何保证用户角度的正确性？"><a href="#2-5-如何保证用户角度的正确性？" class="headerlink" title="2.5 如何保证用户角度的正确性？"></a>2.5 如何保证用户角度的正确性？</h5><ul><li>  视觉感知测试/e2e测试</li></ul><p>e2e测试的成本相对较高，需要测试人员写相应的代码，且每当业务逻辑产生变化，则需要维护这些用例代码。</p><p>视觉感知测试是另一种和e2e测试类似的测试，一般来说不需要写代码，但由于测试是基于“图片对比”的，因此灵活性不如 e2e。</p><p>视觉感知测试的优点是“直观”，在考虑操作录制的情况下，测试人员仅需要对“用例场景”进行定义即可，要求相对较低。</p><h4 id="视觉感知测试怎么做？"><a href="#视觉感知测试怎么做？" class="headerlink" title="视觉感知测试怎么做？"></a>视觉感知测试怎么做？</h4><p>最基础的方式，是进行图片对比，有一系列的操作逻辑，每一步操作后，都有一个截图，用于展示当前操作状态。</p><p>只要一个功能的逻辑没有改动，则特定操作会产生特定的结果。</p><p>只要重复这样的操作逻辑，并对每次的图片进行比对，就能得出特定的结论。</p><p>划分应当以 功能 区分开。</p><p>在某一个功能下，有一些具体的场景。</p><p>每个场景都有特定的操作与逻辑。</p><p>很多场景是相关联的，这些场景应当可以进行参数化配置。</p><p>场景中的很多流程是相似的，这些流程应当可以复用。</p><p>由于运行与截图需要对测试人员透明，因此需要提供录制场景的方法。</p><p>考虑到功能可能频繁变更，因此要增加快速处理比对失败的场景的能力。</p><p>考虑到测试的后台运行属性，因此需要具备报警与通知的功能。</p><p>考虑到素材的可变更性，需要标注可变素材块。</p><p>考虑到h5的布局对内容的影响，可以考虑对于布局的视觉感知测试。</p><h6 id="当前最紧要的事：-1"><a href="#当前最紧要的事：-1" class="headerlink" title="当前最紧要的事："></a>当前最紧要的事：</h6><p>以一个功能需求为实际场景，进行MVP实验</p><h4 id="考虑当前-master-项目的整体质量保证措施"><a href="#考虑当前-master-项目的整体质量保证措施" class="headerlink" title="考虑当前 master 项目的整体质量保证措施"></a>考虑当前 master 项目的整体质量保证措施</h4><ul><li>  以瑞阳牵头的发布流程的保证</li><li>  各小组进行的code review</li><li>  写轮眼项目</li><li>  前端项目的e2e模块</li><li>  后端的api接口自动化测试</li><li>  监控报警</li><li>  基于用户反馈的 oncall 机制</li></ul><p>文档直通车：</p><p><a href="/longblog/posts/22_07_16_20_00_something_about_qa.html" name="关于质量保证的探讨" >关于质量保证的探讨</a></p><hr><blockquote><p>The greatest achievement of humanity is not its works of art, science, or technology, but the recognition of its own dysfunction.<br>— <cite>Eckhart Tolle</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>质量保证</tag>
      
      <tag>qa</tag>
      
      <tag>quality</tag>
      
      <tag>项目工程</tag>
      
      <tag>质量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于质量保证的探讨</title>
    <link href="/longblog/posts/22_07_16_20_00_something_about_qa.html"/>
    <url>/longblog/posts/22_07_16_20_00_something_about_qa.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是质量？"><a href="#什么是质量？" class="headerlink" title="什么是质量？"></a>什么是质量？</h2><p>系统质量，首先保证系统的正常运行，包括功能正确、系统稳定性。其次，要保证系统的健壮性，包括系统的容错能力、报警能力、自恢复能力。还要保证系统的可维护性和可扩展性，包括系统功能增加/修改的难易程度、系统横向扩展的能力。</p><h2 id="我们主要关注哪些点？"><a href="#我们主要关注哪些点？" class="headerlink" title="我们主要关注哪些点？"></a>我们主要关注哪些点？</h2><ol><li> 保证正确的业务逻辑</li></ol><p>任意一个功能都是符合业务预期的，覆盖业务所需要的所有场景。</p><ol start="2"><li> 保证可维护性</li></ol><p>考虑功能规划，确保在之后的新业务需求开发时，能流程地接入系统，而不是做trick兼容。</p><p>新老功能的替换时，确保在数据转换上的可实施。</p><p>在新老功能替换时，确保平滑迁移。</p><ol start="3"><li> 保证容错性(健壮性)</li></ol><p>确保程序有充分的错误处理机制，不会出现程序崩溃宕机的情况。</p><p>确保有明确的监控指标和告警措施，能在程序出现问题时第一时间感知。</p><p>确保有明确的应急方案，例如流量切换，降级、熔断，feature toggle等方案</p><ol start="4"><li> 保证可扩展性</li></ol><p>程序的设计尽量是无状态的，可以水平扩展的。</p><p>如果无法做到无状态，就要做到分治，最终达到可以无限扩展的能力。</p><ol start="5"><li> 保证性能</li></ol><p>选择合适的处理流程，能够异步处理的尽量异步，尽量保证主流程上没有较大的阻塞操作。</p><p>尽量保证程序逻辑层面的不冗余，再保证代码结构设计层面的性能优化。</p><p>由于数据库往往是最终瓶颈，因此要始终保持sql的高效，主要是 分页、批量、索引、独立 几个方式。</p><ol start="6"><li> 安全性？</li></ol><h2 id="如何保证："><a href="#如何保证：" class="headerlink" title="如何保证："></a>如何保证：</h2><ol><li> 代码规范(命令规范、职责单一、分层清晰等)</li><li> 写代码时的高标准(设计模式、面向对象、依赖注入、结构清晰)</li><li> 复杂问题的方案设计与review</li><li> 代码质量保证工具(如sonar、go vet)</li><li> 测试(单元测试、接口测试、集成测试、e2e测试、性能测试)</li><li> 不断重构(小步持续性重构)</li></ol><h2 id="如何执行："><a href="#如何执行：" class="headerlink" title="如何执行："></a>如何执行：</h2><ol><li> [代码规范] =&gt; 有规范、有review</li><li> [高要求] =&gt; 梳理流程、整理文档、先设计再执行、拉人探讨</li><li> [方案设计与review] =&gt; 有文档、有review流程</li><li> [代码质量工具] =&gt; CI/CD 步骤</li><li> [不断重构] =&gt; 每个月自查代码问题</li><li> [测试] =&gt; 见下方</li></ol><h4 id="单元测试的要求"><a href="#单元测试的要求" class="headerlink" title="单元测试的要求"></a>单元测试的要求</h4><ol><li> 所有库方法，必须有正确性单元测试用例。</li><li> 复杂的库方法，需要有多种边界情况测试用例。</li><li> 单元测试用例管理直接在当前模块下的 xxx_test.go 文件中。</li></ol><h4 id="接口测试要求"><a href="#接口测试要求" class="headerlink" title="接口测试要求"></a>接口测试要求</h4><p>目的：保证单个接口的输入输出的正确性</p><p>主要内容： 1. 输入值的边界参数传入。 2. 确保输出值的schema。</p><h4 id="集成测试要求"><a href="#集成测试要求" class="headerlink" title="集成测试要求"></a>集成测试要求</h4><p>目的：从用户行为的角度，保证功能的正确性。</p><p>主要内容：</p><ol><li> 从场景出发，进行数据准备。</li><li> 实际测试，对返回值进行断言。</li></ol><h4 id="e2e测试要求"><a href="#e2e测试要求" class="headerlink" title="e2e测试要求"></a>e2e测试要求</h4><ol><li> 重要流程的场景测试，例如，登录、注册、创建team、创建project、打开文档等。</li><li> 可以考虑基于图片对比的测试。(视觉感知测试)</li></ol><h4 id="性能测试要求"><a href="#性能测试要求" class="headerlink" title="性能测试要求"></a>性能测试要求</h4><ol><li> 单服务性能测试</li></ol><ul><li>  将所有服务拆分，对其进行性能测试。</li><li>  将服务的依赖项进行拆分，mock。</li></ul><ol start="2"><li> 集成服务性能测试</li></ol><ul><li>  全链路数据压测，数据准备与压测。</li><li>  数据来源可采用流量录制。</li></ul><ol start="3"><li> 数据库性能测试</li></ol><ul><li>  对业务场景进行数据库操作过程排查</li><li>  对单个sql语句进行查询分析</li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>服务质量的保证主要应当从</p><ol><li> 团队开发人员意识培养</li><li> 团队质量保证规范与流程</li><li> 测试</li></ol><p>这三个方面入手。</p><p>我当前从 测试 入手，主要有以下几个方面的内容：</p><h4 id="完成-api-接口测试框架搭建与开发"><a href="#完成-api-接口测试框架搭建与开发" class="headerlink" title="完成 api 接口测试框架搭建与开发"></a>完成 api 接口测试框架搭建与开发</h4><p>super-test 项目，目标是让团队成员写 <code>接口测试</code> 的难度降低，现在已经做到：</p><ol><li> 使用 json 配置文件进行测试</li><li> 具有简单的测试触发页面</li></ol><h4 id="考虑-websocket-的功能测试"><a href="#考虑-websocket-的功能测试" class="headerlink" title="考虑 websocket 的功能测试"></a>考虑 websocket 的功能测试</h4><p>[TODO]</p><h4 id="考虑-性能测试-框架"><a href="#考虑-性能测试-框架" class="headerlink" title="考虑 性能测试 框架"></a>考虑 性能测试 框架</h4><ol><li> 项目性能</li><li> 中间件性能</li><li> 数据库性能</li></ol><p>文档直通车：<br><a href="/longblog/posts/22_07_16_20_02_some_thing_about_qa.html" name="质量保证梳理" >质量保证梳理</a></p><hr><blockquote><p>A man’s growth is seen in the successive choirs of his friends<br>— <cite>Ralph Waldo Emerson</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>质量保证</tag>
      
      <tag>qa</tag>
      
      <tag>quality</tag>
      
      <tag>项目工程</tag>
      
      <tag>质量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务化演进的一些问题探讨</title>
    <link href="/longblog/posts/22_07_19_21_44_some_discuss_about_microservice.html"/>
    <url>/longblog/posts/22_07_19_21_44_some_discuss_about_microservice.html</url>
    
    <content type="html"><![CDATA[<p>前两天在 go-krotas 的微信群里，看到一哥们儿提问: </p><blockquote><p>在 k8s 中，不理解为啥还需要 registry ? 直接用 service 不就行了吗？</p></blockquote><p>我回答道:</p><blockquote><p>我觉得直接用 service 主要的问题是 扩展性问题。业务上会有各种对服务分组的需求，比如版本、地域等等。 但是四层的负载均衡比较难做到。所以基于注册中心 + subset 的方式就有了生存空间。<br>不过，如果是比较简单的场景，直接用 service 也是够了的。</p></blockquote><p>之后，一哥们儿回到：</p><blockquote><p>把这些需求沉到 istio 运维层，如果你用 registry，那就是开发者自己管了</p></blockquote><p>这个问题其实很多人都会问到，之前和文浩也讨论过这个话题，当时我的想法大概是，把很多东西下沉到 运维层 当然没问题，但实际上这是一个需要看 成本 和 公司阶段 的问题。</p><p>对于一个初期的项目来说，使用最原始的 <code>单体结构</code> 实际上是成本最低的，毕竟一个项目能发展到什么阶段，对于绝大多数项目而言，都是玄学，难以参透，所以 <code>保持软件架构的简洁</code> 是非常重要的。进，可以按模块拆分；退，可以推倒重来；大不了项目一黄，扔掉完事儿。</p><p>当产品流量不错，服务逻辑也开始逐渐膨胀，就该有所规划地进行 模块的解耦设计，表现在代码侧，就是把不同 类型的<code>接口 区分前缀</code>、把实现逻辑<code>独立成包</code>、把 model <code>内联查询拆开</code>等等。</p><p>回到上面的问题，我们又该如何抉择 使用 registry 还是 使用 istio 呢？<br>我认为还是应当比较成本。 isito 等一系列服务治理的体系，在运维上的成本是不低的，如果要用其去替换 registry ，至少需要考虑以下几点：</p><ol><li>我们是否有人才能够做好 istio 的维护 甚至开发？</li><li>假设我们能维护好，那么这套体系是否真的能够降低 业务开发同学的心智负担？<ul><li>使用 registry 的时候，他们需要花多少精力去关注 服务治理 的东西？</li><li>他们是否真的能够做到不用再关心  服务分组(负载均衡)、认证、限流 等等？</li><li>这些价值，是否能 cover 住有专人去维护另一套复杂的体系带来的成本？</li></ul></li></ol><p>不得不说，当我们重新审视完上面几点，就会发现实际上两者很难说谁优谁劣，对小点的公司而言，几乎毫不犹豫选择使用 <code>registry</code> ( 当然，如果业务简单，会毫不犹豫地使用 service  )； 对于很大的公司而言，可能会考虑使用 <code>side car</code> 的流量治理模式；对于中等大小的公司，可能就处于摇摆状态了……</p><p>一个很实际的例子，如果一家原来是用的 dubbo 或者 <code>spring cloud</code> 这一套的公司，他们已经有非常完善的生态了，不论是 服务注册发现 还是 降级限流熔断，或者是 负载均衡策略 等等，本就是业务开发同学应当知道的，成本也没有很高。 和上面说的这一套 ( side car ) 相比，他们又有什么动力转到这个方向上去呢？</p><p>毛剑老师 之前在一场直播中也简要回答过这个问题:  B站几乎是统一语言的(golang)，用的统一的框架( go-kratos )，任何服务治理上的问题，都只需要在框架层改动即可，几乎都是一次性工作，一劳永逸的事。</p><p>总结一下，技术的发展日新月异，<code>云原生</code>、<code>service mesh</code>、<code>side car</code>、<code>istio</code>、<code>服务运行时</code> 等等概念如日中天，甚至于有些年轻人生来就在 微服务 + 云原生 的环境中，认为 <code>单体架构</code> 甚至 <code>SOA</code> 已经是上个时代的产物了。</p><p>诚然，技术的发展给 社会生产力 带来了更高的效率，因此我们应当崇敬技术，应当拥抱新技术，甚至推动新技术的发展。但在工程上时，也需要考虑新技术的场景适用性，对比成本和收益，姑且压制住  技术人对于新技术的好奇和冲动，用更理性的思维去做抉择。</p><p>我实际上也是一个比较有技术人普标性格的人，<code>好奇</code>、<code>爱折腾</code>、<code>喜欢尝试新技术</code>、<code>较真</code>……，之所以会有上面的想法，可能也和一些经历有关。</p><p>公司有一个前端的项目，做的是官网，用的是 nuxt 框架，为的是用 <code>服务端渲染(SSR)</code> 。之后我们有一波比较大型的推广活动，就需要组织各端同学做压测，以保证容量和服务稳定性。这个服务没有太引起我的关注，因为按以往对官网的理解，就是一个静态页，只要资源往 CDN 一扔，啥事儿都不会有。</p><p>但出乎意料的是，组织压测的各小组汇报情况，官网的 qps 到 5k 左右时怎么都上不去了，各 pod 资源利用率也不高，就是不知道啥情况。搞了很久，踩了很多坑，最后还是没解决。</p><p>主要的坑有： </p><ul><li>① 前端同学对压测的工具和流程不熟悉，花费较多时间学习相关操作  </li><li>② 前端同学对在 linux 容器中如何排查问题不熟悉  </li><li>③ 前端同学对服务间调用的网络链路等不熟悉</li><li>④ 基于 vue3 的 nuxt 会有 .mjs 文件格式，这在一些网关或者浏览器中会有坑( 需要设置特定的 mime type )</li><li>⑤ 没有同学能够 hold 住 ssr 的常见问题。</li></ul><p>倒不是在踩前端同学有多菜，我也是从前端转过来的，我明白从日常工作的技能上来看，熟练掌握 linux 操作能进行问题排查 以及 提前预测方案问题 的同学毕竟是更少的。</p><p>后来勉强过了这次活动，总结复盘时，有同学也提出了，官网的场景 似乎 用 全站静态化 + 懒加载 的方式更加合适。 后面听说要改成静态化的方式，不过我也没继续跟了。</p><p>再举一个后端这边的例子。</p><p>我们有一个业务场景，是把 cavas 画布内的各项操作，进行合并，并转发给协同者。这条链路上，我们原来是  一个 <code>消息服务</code>  + 一个 <code>合并服务</code> ，前者处理 <code>客户端连接</code>、<code>鉴权</code>、<code>消息分发</code> 等功能，后者承担 <code>画布数据合并</code> 的功能。</p><p>画布的合并实际上有两个步骤，一个是 索引，用来校验操作的合法性以及落盘，另一个是 合并，用来做真实的数据合并操作。 某一次规划索引的功能时，这个服务被拆成了两个服务，把 索引 和 数据合并 分开了。</p><p>由于我不是直接负责这块儿的，也没有怎么太关注具体的内容。</p><p>后来做压测，我负责这条链路的性能测试 以及 调优工作，才细致地去看了里面的设计与实现，之后也通过压测去验证一些想法，大致的情况是这样的：</p><p>服务被拆分成两个，他们之间通过 <code>kafka</code> 进行异步通信，由于 kafka 消息大小的限制，他们之间使用了 <code>mongodb</code> 做大消息存储；由于 <code>版本的强约束</code>，两个服务之间又用了 mysql 做统一版本管理；由于 <code>索引服务</code> 在一些情况下，需要使用 <code>全量数据</code>，他们之间又提供了 <code>rpc 调用</code>，以获取数据。</p><p>当我去询问这样的价值时，得到的回答是 <code>解耦</code> 、<code>错误隔离</code>、<code>异步提升性能</code> 、<code>定向优化</code> 等等理由…… </p><p>当我表明我的想法，认为他们合在一个进程中更合理时，得到的回答是： 你要更 open 一些、大家都在做微服务，合在一起是<code>反模式的</code>、他们现在运行得很好…… </p><p>可能由于应对这种场景的经验比较欠缺，我一时也不知道该怎么说这事儿。 但我心里非常清楚，合在一起对 <code>性能</code>、<code>稳定性</code>、<code>成本</code>、<code>开发负担</code> 等各方面都有非常大的价值。然后也不管一些反对的声音，花了几个周末的时间，在独立的环境中，对两个服务做合并，做优化，然后做压测…… ，最后的结果是 我所预期的 和 压测的结果 几乎一样，性能提升超过 10 倍，代码删减了接近一半，数据库调用从 4 次 降到 1 次，同样 qps 下，资源占用降低到原来的 40% ……</p><p>后来一次会议上我提出，<code>微服务</code> 是需要遵循一些原则的，我们对微服务的理解不能仅停留在 “微服务” 这个 名词 上，不是所有能拆的服务都该被拆分，至少要基于 <code>DDD</code> 的一些基本原则。</p><p>后来，看到一个架构的设计原则，认为： </p><blockquote><p>我们做系统架构设计，宗旨就是 <code>降低服务复杂性</code> ，复杂性是万恶之源！</p></blockquote><p>这和 istio 从原来的微服务模型 回归到 单体服务时，<a href="https://docs.google.com/document/d/1v8BxI07u-mby5f5rCruwF7odSXgb9G8-C9W5hQtSIAg/edit#heading=h.ra1vuew9eiv1">官方设计文档</a>的第一句话不谋而和</p><blockquote><p><strong>Complexity is the root of all evil or: How I Learned to Stop Worrying and Love the Monolith</strong><br>复杂性是万恶之源，不然我怎么会爱上单体，并且从此不再焦虑呢？</p></blockquote><blockquote><p>更多信息可以参考 <a href="https://blog.christianposta.com/microservices/istio-as-an-example-of-when-not-to-do-microservices/">istio-as-an-example-of-when-not-to-do-microservices</a><br>中文翻译可以参考 <a href="https://www.infoq.cn/article/VtfJLLvqDIOzglwBpqPk">istio 为什么不再使用微服务</a></p></blockquote><p>用一句很让人警醒的话来结束这篇文章，希望我们能以此共勉: </p><blockquote><p>真正的大佬，都是能把复杂问题简单化的人</p></blockquote><hr><blockquote><p>Wisdom begins at the end.<br>— <cite>Daniel Webster</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>云原生</tag>
      
      <tag>istio</tag>
      
      <tag>微服务</tag>
      
      <tag>服务治理</tag>
      
      <tag>反微服务</tag>
      
      <tag>microservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serverless_究竟是何方神圣？</title>
    <link href="/longblog/posts/22_07_11_what_is_serverless.html"/>
    <url>/longblog/posts/22_07_11_what_is_serverless.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-serverless"><a href="#什么是-serverless" class="headerlink" title="什么是 serverless"></a>什么是 serverless</h2><p>顾名思义，<code>serverless</code> 就是 <code>server-less</code>，也就是 <code>别话时间去搞服务器</code> =&gt; <code>把精力全都放到业务开发上</code> !</p><p>在传统的开发流程中，一个团队的标准配置是： 前端工程师 * x + 后端工程师 * y + 运维工程师 * z 。 前端写交互，后端写数据逻辑与存储，运维就搞服务部署、灰度、日志、监控等等。每个岗位各司其职，看起来十分完美。</p><p>但有时候也没有那么完美，人越多、职责分的越细，岗位间的鸿沟就越大，沟通的成本在组织内就会急剧增加。 通常的表现就是 会越来越多、参会的人也越拉越多，有时候可能一个简单的 <code>上新服务进行调试</code> 的工作，都需要大动干戈搞十来个人拉会各种同步和对齐。</p><p>这种时候我们可能就会想： 能不能不要这么多麻烦的服务器的问题？由一个统一的平台去解决 网关配置、服务发现、服务调用、日志、告警、数据库、中间件、CICD、负载均衡、动态扩缩容 等等……</p><p>实际上，不论是传统的各种 cmdb，还是各种微服务框架，还是各种服务引擎，都是在为了解决上面列出的这个问题，只是他们选择的方案不同而已。 其中 serverless，是最晚出现的一种方案，是在 微服务架构之后出现的另一种架构风格。</p><p>有一种论调是 serverless = faas + baas。其中 faas 是主计算的，而 baas 是主存储的。实际上我们对服务器的需求本质上就这两类： 计算 + 存储。</p><p>而泛 IT 领域内，大家常说起 serverless 的时候，总喜欢把 AWS 的 lambda 计算作为例子，或者把 阿里云 的 函数计算 作为例子。容易让人误以为 serverless 就是 <code>函数计算</code> 。</p><p>而我认为 serverless ，除了包括 机器视角下 的 faas 以及 baas 外，还包括 开发流 视角下的 serverless 开发工具链 + 管理平台 + 编排系统 + 监控系统。 这是站在 serverless 的终极目标上得出的结论。</p><p>云服务上更关心 机器视角，例如 baas 要包含哪些产品？kv？文档存储？对象存储？table存储？ 例如 faas 有哪些形式的延伸？微服务场景？任务触发场景？</p><p>开发者更关心 开发流视角，例如 如何部署一段程序？如何管理一段程序？如何监控程序运行？</p><h2 id="serverless-解决了什么问题？"><a href="#serverless-解决了什么问题？" class="headerlink" title="serverless 解决了什么问题？"></a>serverless 解决了什么问题？</h2><ol><li>开发和部署工具链</li><li>弹性扩缩容 (按量付费)</li></ol><h2 id="使用-serverless-的场景是什么？"><a href="#使用-serverless-的场景是什么？" class="headerlink" title="使用 serverless 的场景是什么？"></a>使用 serverless 的场景是什么？</h2><ol><li>异步 (事件触发)</li><li>无状态 (少依赖)</li><li>突发性</li></ol><h2 id="serverless-的技术点有哪些？"><a href="#serverless-的技术点有哪些？" class="headerlink" title="serverless 的技术点有哪些？"></a>serverless 的技术点有哪些？</h2><ol><li>如何触发 serverless？(events)</li><li>如何解决弹性扩缩容？<ol><li>基于 kubernetes</li></ol></li><li>如何解决路由绑定？(负载均衡)</li><li>如何解决快速启动？</li><li>如何解决程序运行？(build 过程)</li><li>如何解决服务编排？</li></ol><h2 id="serverless-比较难搞定什么？"><a href="#serverless-比较难搞定什么？" class="headerlink" title="serverless 比较难搞定什么？"></a>serverless 比较难搞定什么？</h2><ol><li><p>状态保持 (本地缓存、长连接)</p></li><li><p>事务</p></li><li><p>编排</p></li><li><p>冷启动</p></li><li><p>黑盒排查问题</p></li><li><p>服务商绑定</p></li></ol><h2 id="阿里云的几款-serverless-产品的异同"><a href="#阿里云的几款-serverless-产品的异同" class="headerlink" title="阿里云的几款 serverless 产品的异同"></a>阿里云的几款 serverless 产品的异同</h2><ol><li>FC</li><li>SAE</li><li>MSE</li><li>ASK</li></ol><p>当我们纵眼观察 阿里云 提供了几类和 serverless 有关的产品时，往往容易犯迷糊。<br>FC 是函数计算，主要目的是提供计算能力，运行的资源粒度可以非常小 (128MB * 0.08 C)，可以运行任意你想要的程序。在使用场景上，类似于 <code>任务</code> 的概念。(当然你也可以把他用于 http server)</p><p>SAE 是 serverless 应用引擎，提供的能力和 FC 类似，都是计算能力。在场景上，类似于 <code>service</code> 的概念，例如启动一个 auth 服务。 相比于传统的自己部署一个服务，SAE 提供了 网关、弹性伸缩、监控 等能力。(其实，MSE 有逐渐替代 SAE 的倾向，毕竟他们的重合度太高了)</p><p>MSE 是 微服务引擎，提供的是 服务治理 的能力。是 注册/配置中心、网关、分布式事务、流量治理、开发测试 的集合体。实际就是把原来 阿里云 提供的各类单个的产品，在 微服务 的应用场景下进行了组合。</p><p>ASK 是 弹性 k8s 集群，也就是 k8s 集群的按量付费版本，提供的是 k8s 基础设施。</p><h2 id="我们对-serverless-抱有什么样的期待？"><a href="#我们对-serverless-抱有什么样的期待？" class="headerlink" title="我们对 serverless 抱有什么样的期待？"></a>我们对 serverless 抱有什么样的期待？</h2><ol><li>完全无运维 <ul><li>一套完善的开发和部署平台</li></ul></li><li>友好一致的开发体验<ul><li>开发者无需关注除 业务需求 之外的一切 (比如 k8s、注册中心、服务发现、CICD 等等)</li></ul></li><li>省钱<ul><li>按需付费，不用为每个不怎么使用的应用都花着钱</li></ul></li></ol><h2 id="一些常见的-serverless-应用"><a href="#一些常见的-serverless-应用" class="headerlink" title="一些常见的 serverless 应用"></a>一些常见的 serverless 应用</h2><ul><li><input disabled="" type="checkbox"> 举一些具体的例子</li></ul><ol><li>音视频行业的转码需求</li><li>设计、图形等领域相关的渲染需求</li><li>推荐系统相关的机器学习需求</li></ol><p>分为 2 类：</p><ol><li>微服务场景</li><li>弹性任务场景</li></ol><h2 id="serverless-平台有哪些？"><a href="#serverless-平台有哪些？" class="headerlink" title="serverless 平台有哪些？"></a>serverless 平台有哪些？</h2><ul><li><input disabled="" type="checkbox"> 对比各家的产品，看看他们都在解决什么问题？</li></ul><ol><li>openfaas</li><li>knative</li><li>kubeless</li><li>阿里云相关产品</li><li>腾讯云相关产品</li><li>AWS 相关产品</li></ol><h2 id="我会怎么选？"><a href="#我会怎么选？" class="headerlink" title="我会怎么选？"></a>我会怎么选？</h2><ul><li><input disabled="" type="checkbox"> 列举一些场景，分别在这些场景下我会如何决策？</li></ul><p>如果我是团队 TL，我会如何选择？</p><h2 id="可以参考的文档"><a href="#可以参考的文档" class="headerlink" title="可以参考的文档"></a>可以参考的文档</h2><ol><li><a href="https://www.aliyun.com/product/aliware/fnf">阿里云 serverless 工作流</a></li><li><a href="https://help.aliyun.com/document_detail/97792.html">阿里云 serverless 应用引擎</a></li><li><a href="https://www.aliyun.com/product/fc">阿里云 FC 函数计算</a></li><li><a href="https://www.aliyun.com/product/cs/ask">阿里云 ASK 容器服务</a></li><li><a href="https://cloud.tencent.com/document/product/583/9199">腾讯云函数</a></li><li><a href="https://cloud.tencent.com/document/product/1154">腾讯云 serverless 应用中心</a></li><li><a href="https://cloud.tencent.com/document/product/1371">腾讯云 弹性微服务</a></li><li><a href="https://firebase.google.com/">firebase</a></li></ol><hr><blockquote><p>Through meditation and by giving full attention to one thing at a time, we can learn to direct attention where we choose.<br>— <cite>Eknath Easwaran</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>serverless</tag>
      
      <tag>faas</tag>
      
      <tag>baas</tag>
      
      <tag>cloud native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何做好压测</title>
    <link href="/longblog/posts/21_12_02_how_to_do_load_test.html"/>
    <url>/longblog/posts/21_12_02_how_to_do_load_test.html</url>
    
    <content type="html"><![CDATA[<h3 id="压测的目标是什么？"><a href="#压测的目标是什么？" class="headerlink" title="压测的目标是什么？"></a>压测的目标是什么？</h3><p>压测的目标有两个：</p><ol><li>通过对模块的压测，找到模块的性能瓶颈，分析其资源耗用合理性、架构可扩展性，找到优化方向。</li><li>通过对链路的压测，找到链路的性能瓶颈，回答线上资源容量。</li></ol><h3 id="压测的技能栈有什么？"><a href="#压测的技能栈有什么？" class="headerlink" title="压测的技能栈有什么？"></a>压测的技能栈有什么？</h3><p>压测的技能栈要求非常广泛，整体来说，需要具备这些技能：</p><ol><li>测试人员的思维习惯和方法论。找到合适的测试模型，并准备好/管理好这些数据。</li><li>运维人员的对系统的认识。能够根据需要配置合适的系统资源，能够一定程度上进行系统问题排查。</li><li>开发人员的开发能力。往往在数据准备过程、测试过程中，需要有较多的工具类开发。</li><li>数据分析人员的分析能力。在数据准备和压测过程中，需要提前预规划各类指标与数据，用于分析系统状态，有时需要比较强的数据分析能力。</li><li>对业务系统熟悉。能够在一定程度上进行问题排查。</li><li>对常用的中间件熟悉。能够进行常规中间件的性能评估与异常分析，例如 <code>kafka</code>、<code>mongodb</code>、<code>mysql</code>、<code>redis</code> 等。</li></ol><p>具体的技能，需要根据业务情况而定。但也有一些通用的技能：</p><ol><li>工作规划能力。由于压测的工作往往十分庞杂，因此要能规划好工作内容，各个阶段的安排要合理。</li><li>文档书写能力。压测的过程十分庞杂，因此每个阶段的工作都应该有比较好的记录和分析，用于指导下一环节的工作。常写的文档包括： 1.  压测规划书  2. 压测结果记录   3. 压测分析报告  4. 系统结构分析图。</li><li>沟通能力。由于压测涉及到的范围很广，尤其是一个比较大的链路压测时，压测人员基本无法对整个系统有较强的掌控能力，需要 1. 市场/运营人员  2. 模块开发负责人员  3. 运维人员  的参与，因此协调这些人员的工作就会十分重要。</li></ol><h3 id="压测的形态是怎样的？"><a href="#压测的形态是怎样的？" class="headerlink" title="压测的形态是怎样的？"></a>压测的形态是怎样的？</h3><ol><li>压测可以分为基准测试和链路测试。基准测试是对单个模块的压测。链路压测是对一条业务流程的压测。</li><li>对于一个常规的压测流程，应当先对模块进行基准测试，在得到每个模块的性能指标后，再进行链路压测。</li></ol><h3 id="压测的结论有哪些？"><a href="#压测的结论有哪些？" class="headerlink" title="压测的结论有哪些？"></a>压测的结论有哪些？</h3><ol><li>回答压测的模型是怎样的，说明为什么选择这样的压测模型</li><li>回答在目标QPS下，当前的系统瓶颈是什么</li><li>给出压测过程中发现的不合理之处</li></ol><h3 id="压测的流程是怎样的？"><a href="#压测的流程是怎样的？" class="headerlink" title="压测的流程是怎样的？"></a>压测的流程是怎样的？</h3><ol><li>分析业务形态，系统形态</li><li>根据业务需求，确定合适的压测模型</li><li>准备压测环境</li><li>准备压测数据、压测工具</li><li>确定系统可观测性，确定测试终止条件</li><li>压测执行，处理过程中的问题</li><li>根据压测过程，形成压测报告</li><li>根据压测报告进行分析，形成分析报告</li></ol><h3 id="压测的工程化实践"><a href="#压测的工程化实践" class="headerlink" title="压测的工程化实践"></a>压测的工程化实践</h3><p>业务系统的压测(从链路来看)，往往可以分为这两类：</p><ol><li>http 请求</li><li>其他类 TCP 请求</li></ol><p>由于业务系统主要面向用户，因此对于 http 请求的压测是最多的，这也是市场上生态最好的类型。常规的例如 <code>jmeter</code>、<code>locust</code>、<code>k6</code>、<code>PTS</code>、<code>loadrunner</code> ，这是用于系统性压测的工具。另外，在开发人员保障的性能测试中，<code>ab</code> 、<code>wrk</code> 、<code>go-stress-testing</code>  这几个工具被经常使用，用于快速验证。</p><p>其他类的请求相对较少，例如 <code>rpc</code>、<code>websocket</code> 这类。即使有一些实现，但真正结合到业务中时，会发现各种不满足需求。实际上，这类测试最好还是自己根据业务情况写项目实现。</p><p>压测项目是一个比较具有通用性的项目，因此可以考虑将其平台化，但目前来看，在最通用的 http 压测上，是比较容易平台化的，市场上也有很多，例如上面提到的 <code>jmeter</code>、<code>loadrunner</code> 等。不过，市面上的这类工具基本都是用来进行 压力管理 的，而测试计划、测试脚本、测试报告 等方面的管理是比较弱的，因此，也有企业在开始做云端化的压测管理平台，比如 <code>metersphere</code>，现在做得也基本可用了。</p><p>对于接口类的测试，通用性是非常强的，例如和 接口管理 结合，可以实现类似于：<code>自动化生成测试用例</code>、<code>流量录制</code>、<code>测试跟踪(bug管理等)</code>、<code>基于接口测试的性能测试</code>等等。实际上，这些功能 <code>metersphere</code> 也支持了，不过有部分是企业版的(如项目管理平台集成)。</p><p>对于接口类测试，我们当前使用的是自己开发的一个项目 <code>super-apitest</code> ，这个项目的最大亮点在于 基于json的模板化用例 ，这点可以认为和 jmeter 的 jmx 格式类比，不过基于 json 的格式，对开发者更加友好。</p><p>现在这个项目仅有一些简单的功能，例如适配了简单的触发界面、结果报告、结果通知，但想要真正做到平台化，还有非常长的路要走。</p><p>当前来看，这个项目可以在一定程度上进行平台化，主要的功能点有 3 个：</p><ol><li>支持所有用例使用数据库管理 =&gt; 一切演进的前提</li><li>支持测试用例录制 =&gt; 极大简化用例生成方式</li><li>支持测试用例通过率统计 =&gt; 极大增强测试跟踪</li></ol><p>如果做到这 3 点，这个接口测试平台已经基本可用了。</p><p>对于其他类型的功能测试，主要包括</p><ol><li>工具库的单测和覆盖度测试</li><li>模块的功能测试</li><li>非 http 类的接口测试 (例如 rpc、ws、异步消息)</li></ol><p>这些测试基本不具备很好的通用性，平台化的效率比较低，对于这类测试，平台的作用其实主要有:</p><ol><li>测试触发</li><li>测试用例元信息管理</li><li>测试结果展示</li></ol><p>基于此，可以认为，平台仅需要提供特定的接口，由各测试项目自行实现测试触发、测试结果反馈即可。</p><p>对于性能测试，如果全为 http 类接口，则平台化的效率较高，可以直接和 接口测试 模块相结合，由接口测试提供用例，由性能测试模块提供压测控制。</p><p>同样，对于非 http 类接口而言，性能测试的通用性就比较弱了，比如各个项目的性能。那么平台依然可以提供测试管理接口，由平台来做触发和结果采集，实际的测试执行由各业务项目自行处理。</p><h3 id="功能测试和性能测试的关系"><a href="#功能测试和性能测试的关系" class="headerlink" title="功能测试和性能测试的关系"></a>功能测试和性能测试的关系</h3><p>功能测试的目的在于保证功能的正确性，有时会有比较复杂的校验逻辑，测试用例集的组织形式经常为一个功能。</p><p>性能测试的目的在于摸清一些功能或场景的最大(合适)并发度，用于排查性能瓶颈和做线上资源容量规划，校验逻辑往往比较轻量，着重在压力 ，测试用例集的组织形式尝尝是一系列场景，并且十分关注各场景的比例，目的模拟真实用户的请求。</p><h3 id="压测项目的价值有多大"><a href="#压测项目的价值有多大" class="headerlink" title="压测项目的价值有多大"></a>压测项目的价值有多大</h3><p>根据压测的两大目标来看： 1. 发现系统瓶颈，提供优化建议  2. 回答线上容量问题</p><p>对于第 1 点，这是项目开发时需要的，例如开发一个通用的库，需要根据压测的结果进行优化。实际上，这是任何一个开发工程师都需要具备的能力，尤其是写中间件的工程师。</p><p>这种情况下，压测基本上是驱动这个项目进化的源动力之一。也是业务方评判这个项目的优劣及适用性的一个很重要的标准，业界流行的 <code>redis</code>、<code>kafka</code>、<code>mongo</code>、<code>mysql</code>等这类中间件，都是直接在发行版中自带 benchmark 工具。</p><p>对于第 2 个问题，大多数时候需要链路压测。最常见的系统压测是基于 http 这类 “request/response” 的，而这也是测试工程师最常接触的。目标在于找到整个链路的性能峰值。</p><p>毫无疑问，在项目开发过程中，我们需要回答第 1 个问题，而往往这个问题需要研发工程师自己回答。但从实际的情况来看，对于大多数业务场景，这类问题是比较基础的问题，如果项目中有比较高级一些的研发工程师在技术评审时下点功夫，基本就能将这些问题扼杀在摇篮里。</p><p>也就意味着，业务系统做这类压测，原因往往有两个： 1. 技术管理体系不成熟，代码质量得不到保障。 2. 跟其他业务有所关联，需要自证。</p><p>如果要回答第 2 个问题，就需要链路压测，这也是最被大家所熟悉的压测，这类压测往往需要一个团队来执行，主要包含： 1. <code>测试工程师</code>  2. <code>运维工程师</code>  3. <code>研发工程师</code>  4. <code>业务人员(运营/产品)</code>。 在新项目上线、大促活动等情况下，一般需要做这类测试，用于保障线上不会被打垮。</p><h3 id="业界做的比较好的容量是怎样的"><a href="#业界做的比较好的容量是怎样的" class="headerlink" title="业界做的比较好的容量是怎样的"></a>业界做的比较好的容量是怎样的</h3><p>根据一些公开资料，有了解到使用机器学习的方式，得出各条件下对于机器资源的需求量。机器学习的来源，一方面是通过多次(很多)压测得到，另一方面，是通过线上实际数据反馈进行修正。</p><p>这样一套容量的机器学习方案确实是一个不错的选择，尤其是对于业务较多的企业，还是有不错的收益，例如阿里的本地生活就有这么一套。</p><h3 id="性能保障的职责"><a href="#性能保障的职责" class="headerlink" title="性能保障的职责"></a>性能保障的职责</h3><ol><li>由测试人员</li><li>由运维人员(sre)</li><li>由开发人员</li><li>由架构师</li></ol><p>对于常规的 http 请求的压测，可以由测试人员负责，凭借测试人员对业务场景的理解，可以构造出符合需求的测试脚本，再使用特定的压测工具，则可进行压测，压测的结果也比较清晰，可以直接交给相关项目的开发人员去进行接口优化。</p><p>针对特殊项目的压测，和普通意义上我们认为的测试工程师所做的工作不太一样，常规认为的测试工程师，大多凭借对业务场景的理解，加上对测试(功能/性能)工具的掌握，能做针对业务场景的测试/压测。这种项目的性能测试需要对这个项目本身比较熟悉，往往需要自行开发一些压测的工具来进行压测，从上述描述的测试工程师所擅长的技能来看，不能很好匹配。</p><p>对于链路压测，一般来说需要准备的内容比较复杂，包含 <code>压测目标确定</code>、<code>环境准备</code>、<code>压测场景构建</code>、<code>压测脚本</code>、<code>压测过程控制</code>、<code>项目配置/环境配置调整</code>、<code>压测资源监控</code>、<code>压测报告</code>、<code>压测结果分析</code> 等一系列环节。</p><p>这些环节过于复杂，对于任意一个工程师而言，都是几乎无法完成的。因此，往往需要一个团队来配合。团队内的分工大致如下：</p><ol><li>业务人员(产品/运营)，负责压测目标的确定(业务侧视角)。</li><li>测试人员，负责压测场景梳理、压测数据准备(协同研发人员)、压测执行、压测结果收集、压测报告</li><li>研发人员，负责standby问题排查、环境配置调整</li><li>运维人员，负责环境准备、协助排查资源问题</li><li>架构师/高级开发人员，负责压测结果报告分析、优化方案</li></ol><h3 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h3><ul><li><a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html" name="WIP-kafka的高吞吐原因" >WIP-kafka的高吞吐原因</a></li><li><a href="/longblog/posts/22_11_06_01_47_some_thought_of_performance.html" name="压测的一些思考" >压测的一些思考</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/notpublish/index.html" name="简单的性能测试方案" >简单的性能测试方案</a></li><li><a href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html" name="关于磁盘和网络的性能的问题" >关于磁盘和网络的性能的问题</a></li><li><a href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html" name="记一次服务性能的调优排查" >记一次服务性能的调优排查</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>压测</tag>
      
      <tag>load test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次服务性能的调优排查</title>
    <link href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html"/>
    <url>/longblog/posts/22_07_16_a_record_of_service_performance_improve.html</url>
    
    <content type="html"><![CDATA[<h3 id="事情起因："><a href="#事情起因：" class="headerlink" title="事情起因："></a>事情起因：</h3><ol><li><p> 某一天，听到浩兄说我们有个告警，是因为 event-tracking 的 cpu 使用超标<br><img src="https://static.longalong.cn/img/warning.png"></p></li><li><p> 我感觉比较奇怪，顺口问了下情况，后来又和 浩兄、窦兄 一起看了下各种监控</p></li></ol><h3 id="查看-cpu、内存、网络-情况"><a href="#查看-cpu、内存、网络-情况" class="headerlink" title="查看 cpu、内存、网络 情况"></a>查看 cpu、内存、网络 情况</h3><p><img src="https://static.longalong.cn/img/asynccode-12.png"></p><p><img src="https://static.longalong.cn/img/asynccode-11.png"></p><p>发现很奇怪，内存和 cpu 是猛增上去的，但网络流量却非常小。</p><p>又听到 浩兄 说当时机器的 socket 连接数被打满了，于是怀疑是 goroutine 的问题，进一步查看 goroutine 监控</p><h3 id="查看-goroutine-监控"><a href="#查看-goroutine-监控" class="headerlink" title="查看 goroutine 监控"></a>查看 goroutine 监控</h3><p><img src="https://static.longalong.cn/img/asynccode-8.png"></p><p>发现确实 goroutine 飙得非常高。 也没多想，怀疑是不是有 for 循环里面起了 协程，导致 goroutine 没控制住？</p><p>于是和 窦兄 一块儿，一通代码查看，……额……，没发现啥问题。</p><p>此事一直耿耿于怀，听相关负责人说，在计划重构 event-tracking ，有点害怕，毕竟私有部署的项目中，我还有些依赖 event-tracking 的 sdk [😱]……</p><p>但由于 ① 没有现场，没法抓各种 profile ② 没有 tracing，不知道究竟卡在哪里了</p><p>毕竟，日志、监控、tracing、pprof 相当于我们的眼睛，没有这些，现在做一切都相当于盲猜……</p><p>为了减轻私有化适配的工作，在浩兄的怂恿下，开始了一番自救操作……</p><h3 id="进一步排查的准备工作"><a href="#进一步排查的准备工作" class="headerlink" title="进一步排查的准备工作"></a>进一步排查的准备工作</h3><ol><li><p> 由于不知道各接口的响应情况，于是初步建了个 metrics 的板子，简单看了下，觉得挖不同接口的响应时长可能没啥意义，这应该是个系统性问题，于是放弃继续做板子，转向其他方向。</p></li><li><p> 由于已经在框架中集成了 tracing 的东西，于是花了半个小时把 event-tracking 的 所有 tracing 接上。(包括 redis、db、kafka、http request)</p></li><li><p> 为了能复现高压力下的场景，在压测机上装了 ab </p></li></ol><h3 id="试下未做调整时的压测情况"><a href="#试下未做调整时的压测情况" class="headerlink" title="试下未做调整时的压测情况"></a>试下未做调整时的压测情况</h3><h4 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h4><p>并发 200， qps 54</p><p><img src="https://static.longalong.cn/img/asynccode-2.png"></p><p><img src="https://static.longalong.cn/img/asynccode-10.png"></p><p>tracing </p><p><img src="https://static.longalong.cn/img/20220716105356.png"></p><p>有四个表现奇怪的地方：</p><ol><li><p> 负载非常不均衡，必定有鬼</p></li><li><p> nginx 到 pod 的时间居然达到数秒</p></li><li><p> Pod 内 produce kafka 的时间 居然和 整个请求的时长一样</p></li><li><p> 在 kafka 队列中，居然卡了这么长时间</p></li></ol><h4 id="先怀疑下-kafka-实例的问题"><a href="#先怀疑下-kafka-实例的问题" class="headerlink" title="先怀疑下 kafka 实例的问题"></a>先怀疑下 kafka 实例的问题</h4><p>kafka 监控 </p><p><img src="https://static.longalong.cn/img/asynccode-6.png"></p><p>就这点量，远远达不到 kafka 的瓶颈，跳过。</p><h4 id="怀疑下-是不是代码中用了-同步发送"><a href="#怀疑下-是不是代码中用了-同步发送" class="headerlink" title="怀疑下 是不是代码中用了 同步发送"></a>怀疑下 是不是代码中用了 同步发送</h4><p><img src="https://static.longalong.cn/img/asynccode.png"></p><p>看来并不是，排除。</p><h4 id="怀疑一下-ikafka-包的问题"><a href="#怀疑一下-ikafka-包的问题" class="headerlink" title="怀疑一下 ikafka 包的问题"></a>怀疑一下 ikafka 包的问题</h4><p>此时发现 ikafka 没有接 metrics ，于是看了下之前写的文档，想把 ikafka 的 metrics 接上。</p><p>然后发现 我想接的是 sarama ，但 ikafka 没有暴露 metrics 出来，也没有把 sarama 的 metrics 接口暴露出来，无果……</p><p>这个问题留到之后再怀疑吧</p><h4 id="怀疑一下-kafka-的配置问题"><a href="#怀疑一下-kafka-的配置问题" class="headerlink" title="怀疑一下 kafka 的配置问题"></a>怀疑一下 kafka 的配置问题</h4><p><img src="https://static.longalong.cn/img/asynccode-1.png"></p><p>果然，看到了一个问题，consumer 的 队列数 居然仅设置了 1 ，这岂不是意味着，消息只能一条条从 kafka 取回来？那不得老慢了……</p><p>另外，看到没有开 autocommit，于是也顺手加上。<br><img src="https://static.longalong.cn/img/20220716105438.png"></p><p>ok，这下顺眼多了。其他也不知道咋样，先压一波试下吧。</p><h3 id="调整-channel-size-后的压测"><a href="#调整-channel-size-后的压测" class="headerlink" title="调整 channel size 后的压测"></a>调整 channel size 后的压测</h3><p>刚准备压的，看了一眼 grafana ，懵了…… </p><p><img src="https://static.longalong.cn/img/asynccode-4.png"></p><p>啥情况？？？ Cpu 直接被拉满了？？？</p><p>吓得我反手就抓了一波 pprofile</p><p><img src="https://static.longalong.cn/img/asynccode-9.png"></p><p>发现居然有大量的 park 方法的调用，这显然就是 goroutine 疯狂切换导致的问题啊。</p><p>按以往的经验，很有可能是 for 循环中的 select 不是全阻塞的。此时跑去搜了一圈 <code>for</code> 的代码。没发现问题，每个 for 循环都还比较规范……</p><p>于是回来接着看 pprofile，注意到 左边 kafka 的调用，按理，这是属于底层包的调用啊，应该不会有啥问题啊。</p><p>跟了一圈代码，由于是直接的 cgo 调用，也很难继续追下去了。</p><p><img src="https://static.longalong.cn/img/origin_img_v2_e59df2f5-be93-4e16-8749-3f500e19ab9g.jpg"></p><p>想到之前 confluent 给我留下的奇奇怪怪的印象 (主要是因为黑盒问题)，再加上对 sarama 做过比较仔细的源码阅读，想着既然 confluent 不好调试，换成 sarama 先试试吧……</p><h3 id="切换-sarama-后的压测"><a href="#切换-sarama-后的压测" class="headerlink" title="切换 sarama 后的压测"></a>切换 sarama 后的压测</h3><p>并发 200， qps 940</p><p><img src="https://static.longalong.cn/img/asynccode-3.png"></p><p>grafana 监控</p><p><img src="https://static.longalong.cn/img/asynccode-7.png"></p><p>时间分布合理</p><p><img src="https://static.longalong.cn/img/asynccode-5.png"></p><p>打完   收工 ！</p><h3 id="结局："><a href="#结局：" class="headerlink" title="结局："></a>结局：</h3><ol><li><p> Event-tracking 的性能问题至少算是解了</p></li><li><p> 如果需要的话，可以再去整理下 confluent 的正确打开方式 ( 还是算了…… ，直接用 sarama 或者 kafka-go 不香吗 )</p></li><li><p> 公共包最好还是提供一些统一的 metrics 接口、提供统一的 tracing 设置</p></li><li><p> 对于我们现在大多数的业务场景，1c 的 cpu 支撑个 1000qps 问题是不大的，大家可能需要更新下对性能的感性认识</p></li></ol><hr><blockquote><p>There are two kinds of failures: those who thought and never did, and those who did and never thought.<br>— <cite>Laurence J. Peter</cite></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>聊聊心力</title>
    <link href="/longblog/posts/22_08_08_16_20_thoughts_of_heart_strength.html"/>
    <url>/longblog/posts/22_08_08_16_20_thoughts_of_heart_strength.html</url>
    
    <content type="html"><![CDATA[<p>当我们后知后觉地找到了一个自认为 “有价值” 的目标后，就开始了漫长的征途，朝着目标前行。就像长跑一样，知道了自己是参加的 10km 跑后，就沿着跑道一步步前行。</p><p>当人有了目标之后，就会产生一系列的精神活动。</p><p>有一种精神活动，是通过想象自己已经达到了目标，产生一些快乐，可以认为是提前享受成功喜悦的快乐。这种快乐很有价值，能激励我们继续向着目标前行，但同样，也容易产生一种错觉，觉得自己很快就能达到目标。</p><p>另一种精神活动是，会经常去对标这个目标，看看自己距离目标还有多远。这种活动的价值，在于认清现状，找到真正该做的事。但也容易产生 心理落差，预期的前进速度和现实的前进速度的差距，就是落差，当一个人的期待越高，落差就会越大，认清现实后，摔下来也就越疼。</p><p>有时候，当我们遭受一些挫折，会有 无力、身心疲惫、累觉不爱 等等感受。我们会本能地选择逃避，只想躺在沙发上，随便刷刷手机；或躺在床上，闷头大睡；或玩游戏、或看肥皂剧；只要能不让自己去想那些烦心事儿，做什么都无所谓……</p><p>走向目标的路上有着种种 挫折，这些都会让我们产生 <code>挫败感</code>。 挫折 是每个人都在每个目标上，都一定会遇到的，但这些挫折会成为你成长道路上的 垫脚石 还是 绊脚石，对不同的人却是不同的，这取决于我们看待问题的 态度。</p><p>趋利避害，是人的天性。但天性很多时候只能解决 眼前的 问题，却无法解决长远的问题，持续的逃避，只能让我们止步不前，无法继续通往期待的彼岸。</p><p>有很多概念都在描述人在处理挫折时的能力，比如 <code>心力</code> 、<code>逆商</code>、<code>钝感力</code> 等等，基本都只有一些感性上的解释，不过不阻碍我们找到一些好的方法，让我们保持持续的活力。</p><p><a href="https://wiki.mbalib.com/wiki/%E9%92%9D%E6%84%9F%E5%8A%9B">钝感力</a>，大概是指 <code>迟钝的力量，能从容面对生活中的挫折和伤痛，坚定地朝着自己的方向前进</code>，是在面对困难时，还能厚着脸皮对抗外界的能力，是一种积极向上的人生态度。</p><p><a href="https://wiki.mbalib.com/wiki/%E9%80%86%E5%95%86">逆商</a>，通常和 智商、情商 并称为 3Q，是指人们在面对挫折、摆脱困境和超越困难的能力。</p><p>心力，我们大致可以用来表示自己当前的精神储备，心力会被消耗，也会被累积。我们可以通过 远离消耗心力的事 来避免心力被消耗殆尽，例如和一些负能量的人保持距离、避免一些没必要的争论、不开无效的会议、少看自己改变不了的社会负面信息 等等。也可以做一些增加心力的事，例如 向正能量的人靠近、和爱的人聊聊开心的事、做自己感兴趣的事、运动、沐浴清风 等等。</p><p>周末心力降到 0 ，没有心思写文章、学算法，甚至不想吃饭。于是我打开了 B 站， 看了下之前一直没看的 《从零开始的异世界生活》，看的过程不细聊了。</p><p>现在回想起来，486 就是一个 心力管理 的典型案例啊。他的心力来源于两个方面： 内在的善良 以及 外在的友人的鼓励。他持续地受到现实的各种打击，也痛苦过，也崩溃过，但在一次一次的痛苦后，又一次一次地爬起来，继续朝着目标前进。</p><p>当我去思考，我们更底层的能量究竟来自于哪里？我发现这和思考 “人生的意义是什么” 一样得不到答案。</p><p>不敢太深究，但在两个维度上，可以用这两个词来解释:  信念、习惯。</p><p>习惯，是日常生活中，保证个人状态的，例如 当你看到散乱的桌面，你是习惯与心烦意乱，还是顺手收拾，还是选择性无视？ 当你受到他人的质疑，你是开始自我怀疑，还是据理力争，还是无力力争，还是自我反思后总结优劣？</p><p>习惯是日常的，也是影响深远的，同时也是我们比较好改变的，改变的关键在于: 识别消耗心力的不良习惯。 </p><p>信念，包含浅层次的 观念，以及深层次的信念。众多的观念构成了一个人价值观的一部分，让他能对遇到的事形成自己的解释，当形成了体系性的解释时，就相当于有了信念。有些人的信念来自于他人，比如追随一个偶像；有些人的信念来自于更抽象的愿景，比如实现共产主义；也有些人的信念来源于一些更靠近每个人的，比如亲情、爱情等。</p><p>当我们看到 一个人很乐观，就不禁去想，他为什么那么乐观？比如前段时间火了的 二舅。当你去问一个乐观的人，你觉得自己不幸吗？你很可能会得到一些共同的回答，比如 我现在健健康康，家人也很和睦，虽然没有太多积蓄，但都在工作，都有收入，跟很多人相比，我已经是很幸运的了。</p><ul><li>佛说，人生有三大苦，怨憎会，爱别离，求不得。</li><li>佛还说，放下，便是拥有。</li><li>道德经中也说，知足者常乐。</li></ul><p>我们可以看到，乐还是苦，有时候是你对自己 所求的 和 所拥有的 之间的比较，当你所求降低，再多关注自己所拥有的，或许会感到更多的幸福。</p><p>有时候我也在想，人活这一生要追求什么？<br>之前看 《凡人》，看到师傅说：活得久了，就愈发觉得，这世上有些东西，比自己的性命还重要。又说：我所修的道，是念头通达。画面内是师傅为了自己所求的道慨然赴死，屏幕前是我内心激动不已，泪光闪动。</p><p>或许，长远来看，我们所追求的是内心的平静，为了守护这份平静，即使拼上一切，即使身死道消，也在所不惜。</p><p>追求内心的平静，并不是 避世 也不是 摆烂，因为内心总有一个声音，虽时强时弱，但你仔细聆听，就一定能听到，它在说着：去做吧，去做你热爱的事，不要害怕，不要胆怯！</p><p>有时候又在想，人活着，不总得拼一拼嘛？才不枉来这世上走了一遭。没拼过，有如何能在夜半十分安然入睡？没拼过，又如何能在垂暮之年笑谈人生？谋事在人，成事在天，不去试一试，谁能知道结果如何？追求自己所热爱的，投入自己的时间、精力、生命，又有何可惜？时间，不总得花在什么事情上吗？</p><p>回看前面几句话，我又有了新的认识。</p><ul><li>求不得，并非让我们 不再求，而是 求，得与不得，得之我幸，不得我命。</li><li>放下的，是执着于结果的心，拥有的，是内心的平静与享受过程的乐趣。</li><li>知足者，对我们不能掌控的事知足，对我们能掌控的事，永不知足！永不停歇！</li></ul><p>究竟要怎么把上面说的这些和当前的状态联系起来，还需要探索，或者说，这是一件需要持续探索的事。</p><hr><blockquote><p>You are the only person on earth who can use your ability.<br>— <cite>Zig Ziglar</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>心力</tag>
      
      <tag>价值观</tag>
      
      <tag>信念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc的源码走读</title>
    <link href="/longblog/posts/22_07_26_17_34_reading_grpc_codes.html"/>
    <url>/longblog/posts/22_07_26_17_34_reading_grpc_codes.html</url>
    
    <content type="html"><![CDATA[<h2 id="各包的作用"><a href="#各包的作用" class="headerlink" title="各包的作用"></a>各包的作用</h2><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><ol><li>初始化了默认的 channelz 监控，详见 channelz</li><li>对外暴露了注册监控 server 的方法</li></ol><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>提供了一个简单封装的 immutable kv store 。</p><h3 id="authz"><a href="#authz" class="headerlink" title="authz"></a>authz</h3><p>认证拦截器，提供了 rbac。<br>rbac 模型，使用的是 “github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3” 这个包，这是 envoy 的模块。</p><p>提供了基于文件的拦截器。<br>可以预见，这部分内容，和 envoy 结合会比较紧密。</p><h3 id="backoff"><a href="#backoff" class="headerlink" title="backoff"></a>backoff</h3><p>提供了失败处理的默认 Config，被全局各处引用。重试延迟配置。</p><h3 id="balancer"><a href="#balancer" class="headerlink" title="balancer"></a>balancer</h3><p>使用 注册 的方式，采用 builder 的模式。<br>balancer 包含两个部分，其一 balancer ， 其二 picker。<br>balancer、picker、resolver 均会被 warpper 包裹，用来保证 grpc 内部新增能力。<br>internal 包中的 balancer ，实现了 优雅切换 的功能，是 wapper 中的重要能力。</p><p>k8s 的 resolver 部分，可以参考 <a href="/notpublish/index.html" name="grpc的负载均衡" >grpc的负载均衡</a> </p><h3 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h3><p>提供了一系列用于做基准测试的程序。</p><h3 id="binarylog"><a href="#binarylog" class="headerlink" title="binarylog"></a>binarylog</h3><p>提供了类似于 mysql 的 binlog 机制。提供了方法过滤机制 (config中)。可以把 binlog 写到一个远端地址 (sink)。</p><p>具体实现在 internal 的 binarylog 中。</p><h3 id="channelz"><a href="#channelz" class="headerlink" title="channelz"></a>channelz</h3><p>对外提供 grpc 服务状态指标，和 metrics 的目标一样，本身也是一个 service (和自己写的 grpc service 一样)，提供了几个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ChannelzServer <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Gets all root channels (i.e. channels the application has directly</span><br><span class="hljs-comment">// created). This does not include subchannels nor non-top level channels.</span><br>GetTopChannels(context.Context, *GetTopChannelsRequest) (*GetTopChannelsResponse, error)<br><span class="hljs-comment">// Gets all servers that exist in the process.</span><br>GetServers(context.Context, *GetServersRequest) (*GetServersResponse, error)<br><span class="hljs-comment">// Returns a single Server, or else a NOT_FOUND code.</span><br>GetServer(context.Context, *GetServerRequest) (*GetServerResponse, error)<br><span class="hljs-comment">// Gets all server sockets that exist in the process.</span><br>GetServerSockets(context.Context, *GetServerSocketsRequest) (*GetServerSocketsResponse, error)<br><span class="hljs-comment">// Returns a single Channel, or else a NOT_FOUND code.</span><br>GetChannel(context.Context, *GetChannelRequest) (*GetChannelResponse, error)<br><span class="hljs-comment">// Returns a single Subchannel, or else a NOT_FOUND code.</span><br>GetSubchannel(context.Context, *GetSubchannelRequest) (*GetSubchannelResponse, error)<br><span class="hljs-comment">// Returns a single Socket or else a NOT_FOUND code.</span><br>GetSocket(context.Context, *GetSocketRequest) (*GetSocketResponse, error)<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的实现在 internal 的 channelz 中。</p><p>有一个 <code>Identifier</code> 的封装，还比较有意思，可以用 数值、字符串、类型 做标识，提供了比较的方法，关键是有 <code>集成关系</code> ，可以用于标识类似于 进程关系 。</p><p>一般用于 监控 和 问题排查 和 调试环节，为了更加直观方便，官方提供了 <a href="https://github.com/grpc/grpc-experiments/tree/master/gdebug">ui 工具</a>。关于 channelz 的设计初衷，可以查看 <a href="https://github.com/grpc/proposal/blob/master/A14-channelz.md">proposal</a></p><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>提供了一个简单的 生成 grpc 代码的工具 – protoc-gen-go-grpc  (核心代码在 google.golang.org/protobuf/compiler/protogen 中)</p><h3 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h3><p>类似于 http 的 200、400、401 等等状态码，提供了 grpc 中的状态码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> strToCode = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]Code&#123;<br><span class="hljs-string">`&quot;OK&quot;`</span>: OK,<br><span class="hljs-string">`&quot;CANCELLED&quot;`</span>:<span class="hljs-comment">/* [sic] */</span> Canceled,<br><span class="hljs-string">`&quot;UNKNOWN&quot;`</span>: Unknown,<br><span class="hljs-string">`&quot;INVALID_ARGUMENT&quot;`</span>: InvalidArgument,<br><span class="hljs-string">`&quot;DEADLINE_EXCEEDED&quot;`</span>: DeadlineExceeded,<br><span class="hljs-string">`&quot;NOT_FOUND&quot;`</span>: NotFound,<br><span class="hljs-string">`&quot;ALREADY_EXISTS&quot;`</span>: AlreadyExists,<br><span class="hljs-string">`&quot;PERMISSION_DENIED&quot;`</span>: PermissionDenied,<br><span class="hljs-string">`&quot;RESOURCE_EXHAUSTED&quot;`</span>: ResourceExhausted,<br><span class="hljs-string">`&quot;FAILED_PRECONDITION&quot;`</span>: FailedPrecondition,<br><span class="hljs-string">`&quot;ABORTED&quot;`</span>: Aborted,<br><span class="hljs-string">`&quot;OUT_OF_RANGE&quot;`</span>: OutOfRange,<br><span class="hljs-string">`&quot;UNIMPLEMENTED&quot;`</span>: Unimplemented,<br><span class="hljs-string">`&quot;INTERNAL&quot;`</span>: Internal,<br><span class="hljs-string">`&quot;UNAVAILABLE&quot;`</span>: Unavailable,<br><span class="hljs-string">`&quot;DATA_LOSS&quot;`</span>: DataLoss,<br><span class="hljs-string">`&quot;UNAUTHENTICATED&quot;`</span>: Unauthenticated,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="connectivity"><a href="#connectivity" class="headerlink" title="connectivity"></a>connectivity</h3><p>连接状态的定义，详见 state 包。</p><h3 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a>credentials</h3><p>提供 grpc 的认证能力。<br>默认有:  tls、<a href="https://www.servicemesher.com/blog/envoy-xds-protocol/">xds</a>、<a href="https://datatracker.ietf.org/doc/html/rfc8693">sts</a>、oauth、<a href="https://cloud.google.com/docs/security/encryption-in-transit/application-layer-transport-security">alts</a>、local、insecure、google cloud 的方式。</p><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>序列化方法 和 压缩方法。 提供了基于 proto 的序列化方法  和  基于 gzip 的压缩方法。</p><h3 id="gcp"><a href="#gcp" class="headerlink" title="gcp"></a>gcp</h3><p>希望提供 OpenCensus 的能力，目前还在测试阶段。</p><h3 id="grpclog"><a href="#grpclog" class="headerlink" title="grpclog"></a>grpclog</h3><p>logger 的使用为在一个包中，这个包初始化一个带 tag 的 logger 实例 (有缓存)。</p><p>其他方面设计中规中矩，使用的 github.com.golang/glog 作为底层 log 包</p><h3 id="health"><a href="#health" class="headerlink" title="health"></a>health</h3><p>提供客户端的健康检查接口，为了解决服务假死的情况。</p><h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h3><p>各种功能的具体实现 以及 一些工具库。</p><h3 id="interop"><a href="#interop" class="headerlink" title="interop"></a>interop</h3><p>一些用于测试的程序</p><h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>保持连接的配置。</p><h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>类似于 http 的 header，一个 <code>map[string][]string</code> ，用来传递元信息，例如 requestID 等。<br>提供注入 ctx 和 从 ctx 提取的方法。</p><h3 id="peer"><a href="#peer" class="headerlink" title="peer"></a>peer</h3><p>用来表示对端的连接信息。用来做认证的信息传输，具体信息可以查看 credentials 部分。</p><h3 id="profiling"><a href="#profiling" class="headerlink" title="profiling"></a>profiling</h3><p>性能工具，和上面的 channelz 类似，也是一个提供接口的 service，可以记录每个接口的时长等。<br>提供了 json 转义工具。<br>目前使用较少。</p><p>提供了一个 buffer.go 的文件，主要实现了一个 ring buffer，使用 atomic 实现的无锁 buffer ，值得参考 。[TODO]</p><h3 id="reflection"><a href="#reflection" class="headerlink" title="reflection"></a>reflection</h3><p>提供各 service 的反射，也是一个提供接口的 service，能够获取到每个 service 的入参与出参的格式。<br>一个最常规的用法是用于 <a href="https://github.com/fullstorydev/grpcurl">grpcurl</a></p><h3 id="resolver"><a href="#resolver" class="headerlink" title="resolver"></a>resolver</h3><p>用于处理 <code>service name 解析</code>  ，默认不做解析 (由更底层的 net 包做解析)，除非自己指定 resolver 方法。<br>关于 name 的定义详情，可以参考 <a href="https://github.com/grpc/grpc/blob/master/doc/naming.md">grpc 官方文档</a>，URI 规范用的 <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a></p><p>从代码模式上看，使用了 建造者 模式，接口为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Builder <span class="hljs-keyword">interface</span> &#123;<br>Build(xxx, xxx, opts BuildOptions) (Resolver, error)<br>Scheme() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>resovler 从预期看，应该只需要一次调用，然后给 resolver 提供回调的能力 ( <code>ClientConn.UpdateState()</code> )。</p><p>建造者模式 相比于直接实例化，提供了 需要时再实例化 的能力。</p><h3 id="security"><a href="#security" class="headerlink" title="security"></a>security</h3><ol><li>提供了基于 rbac 的授权工具。</li><li>提供了 tls 工具，验证证书。</li></ol><p>具体可以参考 credentials</p><p>使用了 <a href="https://github.com/google/cel-go">cel-go</a> 这个规则引擎。值得进一步看下。可以参考<a href="https://cloud.tencent.com/developer/article/2025423">这篇文章</a> 。规则引擎的语言定义可以查看<a href="https://github.com/google/cel-spec/blob/master/doc/langdef.md">官方文档</a></p><h3 id="serviceconfig"><a href="#serviceconfig" class="headerlink" title="serviceconfig"></a>serviceconfig</h3><p>config 的类型接口定义。不知道用作什么目的。</p><h3 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h3><p>用于统计请求信息，类似于 tracing 和 metrics，在初始化 server 时，通过 options 注入。</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>和 http 的状态码相似，不过支持自定义的 msg 信息，通过 error 传递。</p><h3 id="stress"><a href="#stress" class="headerlink" title="stress"></a>stress</h3><p>压测脚本</p><h3 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h3><p>xxx</p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>大量集中性单元测试</p><h3 id="xds"><a href="#xds" class="headerlink" title="xds"></a>xds</h3><p><a href="https://www.servicemesher.com/blog/envoy-xds-protocol/">xds的介绍</a> 、 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol">envoy 官方文档</a> 、<a href="https://github.com/grpc/proposal/blob/master/A40-csds-support.md">grpc proposal</a><br>这是一系列资源发现服务的接口集合。<br>这个包是一套庞大的 xds 工具集，包括 client 和 server 。</p><p>因为还庞大的一套体系，没细读，之后找时间和 envoy 等一起阅读。【TODO】</p><h2 id="整体的一些感受"><a href="#整体的一些感受" class="headerlink" title="整体的一些感受"></a>整体的一些感受</h2><p>grpc  是一个很大的体系，对于 grpc 的使用也有很多的技巧，初始使用时，会觉得很简单，尤其是以后加接口做维护啥的。 但实际上，grpc 也有很多细节，甚至很多同学都不知道。<br>例如， grpc 有自己的一套 error code 方式、grpc 的 resolver 可以实现多种类型的 uri 、grpc 默认使用 pickfirst 的 lb 策略、grpc 有很多认证方式、grpc 可以用 admin 做调试、stats 做 metrics 监控 等等。</p><p>后续需要去看一下别人都是怎么使用 grpc 的，看看一些最佳实践。</p><h2 id="对于代码走读"><a href="#对于代码走读" class="headerlink" title="对于代码走读"></a>对于代码走读</h2><p>#readingcodes </p><p>代码的走读有 3 个层次：</p><ol><li>理解项目的整体模型</li><li>理解各个包解决了什么问题，大致怎么实现的</li><li>分析一些包的设计，找其亮点，想想如果自己写，会怎么写</li></ol><p>从产出的角度看，可以有：</p><ol><li>走读记录 (包的作用、设计好的地方)</li><li>代码结构图 ( 包结构、类关系、时序 )  </li></ol><p>如果能把 类关系图 和 时序图 画出来，那就很不错了。</p><hr><blockquote><p>My best friend is the one who brings out the best in me.<br>— <cite>Henry Ford</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>readingcodes</tag>
      
      <tag>grpc</tag>
      
      <tag>xds</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种后端通信方式的杂谈</title>
    <link href="/longblog/posts/22_3_25_some_kinds_of_communication_in_backends.html"/>
    <url>/longblog/posts/22_3_25_some_kinds_of_communication_in_backends.html</url>
    
    <content type="html"><![CDATA[<h2 id="计算机的几种通信方式"><a href="#计算机的几种通信方式" class="headerlink" title="计算机的几种通信方式"></a>计算机的几种通信方式</h2><p>对于计算机而言，通信 是一件永远不可能被忽视的事情。通信 基本可以分为 进程内通信 和 进程间通信。 进程内通信的方式大致有： <code>① 共享内存</code>  <code>② 变量传递</code>。进程间通信又需要分为 在同一操作系统上 和 在不同操作系统上，同一操作系统上的进程间通信主要有 <code>① 共享内存</code>  <code>② 共享存储</code> <code>③ 管道(命名)</code> <code>④ 信号量</code> <code>⑤ 消息队列</code> <code>⑥ socket</code> 通信。不同操作系统上，则只能使用 <code>socket</code> 通信。</p><p>实际上，从上面可以看出，除了 <code>信号量</code> 的通信方式比较独特外，其他的通信方式都是基于 <code>共享</code> 或 <code>传递</code> 的进行。只是 共享的方式 和 传递的方式 有所差别。</p><h3 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h3><p>在 进程内通信时，共享内存 是可以被特定编程语言直接使用的内存格式，因此效率非常高；在进程间的共享内存上，内存是最底层的共享方式，因此内存格式需要自己约定，也就意味着所有传递的值 需要经过一定的格式转换，也就是 序列化的过程。</p><p>在 进程内通信时，变量传递可以分为 值传递 和 引用传递 ，所有的操作都是编程语言做的，我们只管使用即可。但在 进程间的消息传递时，我们则需要自己处理 消息格式 的问题，也即是 序列化和反序列化 的过程。</p><p>上述的这些通信方式，实际上是很通用的模型，不仅在操作系统层被使用，在应用层，我们基于这些模型造了很多工具或软件系统。例如，共享内存 我们有 <code>redis</code> 、<code>memcache</code> 等，共享存储 我们有 <code>mysql</code>、<code>etcd</code>、<code>mongodb</code> 等等，管道 我们有 <code>redis</code> ，消息队列 我们有 <code>kafka</code>、<code>zeroMQ</code> 、<code>rabbitMQ</code> 等等，甚至有一些 消息队列的通用协议，例如 <code>MQTT</code>、<code>AMQP</code> 等等。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>最繁荣的进程间通信方式，实际上还是 <code>socket</code> 通信，socket 本身只是一个接口定义，不过这个接口定义太通用了，任何消息传递几乎都可以套用这个接口，无论是 <code>文件</code>、<code>网络</code> 还是 <code>内存</code> 。</p><h2 id="服务端的常见通信方式"><a href="#服务端的常见通信方式" class="headerlink" title="服务端的常见通信方式"></a>服务端的常见通信方式</h2><p>对于服务端开发而言，最常用的还是基于 网络 的 socket 编程，最底层自然都依赖 TCP/UDP，在应用层上，我们有非常多的协议，例如 <code>http</code> 、<code>http2</code> 、 <code>http3</code> 、<code>websocket</code>、 <code>MQTT</code> 以及各种小领域的协议，其实，所有的协议，都是对特定领域的通信内容的通用抽象，例如，http 是一个很常用的互联网请求协议，包含 请求行 、请求头 、请求体 ，一般认为 http 是一个 文本协议，实际上这指的是其 序列化方式，文本内容直接通过 ascll [待验证] 进行传输，背景是 http 协议出生在 文本内容共享浏览 的互联网初始定位 的时代。</p><p>后来发现 http 的传输效率不高，于是 http2 做了 压缩消息头 、二进制分帧传输、连接复用 的优化。在后来，认为基于 tcp 的传输效率还是有点低，而现代基础设施整体是比较好的，因此基于 udp 在应用层做了一些消息质量保证的操作，用于提升传输效率。</p><p>其实 http 系列协议，都可以看做是在 http1.1 的协议约定基础上，在传输层做优化。 那么，是否有其他通过优化协议本身内容的方式呢？其实其他协议都是在做这件事。例如，<code>websocket</code>，建立在 tcp 之上，使用非常简洁的控制帧，通信消息全在消息体当中。还有一些追求极致性能的协议，甚至直接建立在 TCP 上做应用层消息传输，例如 kafka 的通信协议。</p><p>从 自定义消息结构 这个看待协议的角度出发，我们甚至可以认为 rpc 才是真正的一切协议的源头，可以想象曾经有各类自定义的 rpc 格式，例如 <code>samba</code>、<code>nfs</code>、<code>ssh</code> 等等，当他们具有一定的名气后，大家就把他们从 自定义 rpc 协议 的认识中拎出来，直接用他们的名字代替。也就是说，我们现在所自定义的各种 rpc 协议，当他们具有一定名气后，就可以拥有自己的 名字 。</p><p>阐述完各类协议的基本情况后，我们来聚焦一下 <code>http</code>、<code>http2</code>、<code>grpc</code>、 <code>ws</code> ，看一下他们的关系。</p><h3 id="几种协议的区别认识"><a href="#几种协议的区别认识" class="headerlink" title="几种协议的区别认识"></a>几种协议的区别认识</h3><p>Http 的全名叫 超文本传输协议，是互联网最常用的协议，分为 请求行 (method + path)、请求头 (header) 、请求体 (body)，请求体可以是二进制数据(经过编码传输)。</p><p>http2 是 http 的升级版，所有请求格式延续了 http 的格式，对上层应用来说整体没啥差别(如果仅当做http来用)，但是也提供了 服务端推送、stream 等功能。一定程度上，我们可以认为，http2 是 http 的 传输层封装 (充当 transport 层)。</p><p>grpc 是把 http2 当做传输层 (transport 层)。其他特性是自行实现的，例如 <code>interceptor</code>、<code>resolver</code>、<code>balancer</code>、<code>auth</code>、<code>log</code>、<code>status</code>(状态码)、<code>stats</code>(监控)。实际上，我们不能把 grpc 当做一种协议，而是一种 rpc 框架 (类似于 http 框架)，协议 有特定格式 或 接口约定，而 grpc 是用于生成特定 server 和 client 的一整套工具。</p><p>ws 是直接在 tcp 之上的一层通信协议，特点是 轻量、连接保持，ws的想象空间很大，实际上，如果你愿意，甚至可以使用 ws 作为 http 的 transport 层，也可以把 ws 作为 mqtt 的 transport 层，也可以把 ws 作为 grpc 的传输层。</p><p>一些情况下，我们可以认为，一个协议 或者 一个框架，为什么选择了某项技术 而并不是 其他技术，是由于 生态 决定的，例如为什么 grpc 选用了 http2 而不是直接的 tcp 连接？为什么后端服务调用大家使用 grpc 而不是 手写 http？为什么后端不用 ws 通信？</p><h3 id="ws的特点"><a href="#ws的特点" class="headerlink" title="ws的特点"></a>ws的特点</h3><p>ws 现在的主要场景在前后端的即时消息上，这得益于 ws 的 状态保持 的特性，那么，我们是否可以基于这个特性，做更多的事情？</p><p>比如，① 基于 ws 的 http 协议转换、② 基于 ws 的 grpc 协议转换、③ 基于 ws 的自定义 rpc 框架、④ 基于 ws 的自定义框架。</p><p>对于 ①，应用场景较少，如果是为了传输性能，那么使用 http2 就能解决，而且 http2 的生态更好。<br>对于 ②，可以，但目前已经有了基于 http 的 grpc 协议转换，使用 http2 的情况下，性能也没啥问题。<br>对于 ③，可以，但要考虑生态问题，这基本意味着重新实现整套 grpc 的各模块。<br>对于 ④，可以，但目前已经有一些 ws 框架，例如 socket.io，要考虑清楚为什么需要一套新的框架。</p><h3 id="我对于当前-http-、http2、grpc、ws-方式的基本判断"><a href="#我对于当前-http-、http2、grpc、ws-方式的基本判断" class="headerlink" title="我对于当前 http 、http2、grpc、ws 方式的基本判断"></a>我对于当前 http 、http2、grpc、ws 方式的基本判断</h3><ol><li>http 有完善的接口定义方式 (<code>openapi</code>)，http2 甚至 http3 在性能上和将来的生态上也非常不错。目前没有看到好的基于 http 接口定义 方式自动生产 server 和 client 的工具。</li><li>grpc 有完善的接口定义方式，性能上和生态上很不错，有自动生成代码的工具链。前端调用不支持直接通信，需要经过 http 协议再转一次(浏览器端 或 proxy 端)。</li><li>ws 有一定的生态支持，ws 的状态保持在一些场景下是非常不错的特性。ws 没有自动生成代码的工具。</li></ol><h3 id="ws有什么特殊的价值？"><a href="#ws有什么特殊的价值？" class="headerlink" title="ws有什么特殊的价值？"></a>ws有什么特殊的价值？</h3><p>ws 有两个特性： ① 连接保持  ② 协议轻量 。另外，ws 的生态不错 (主要指浏览器的特殊支持)。<br>ws 在一些需要长链接的场景下，非常有价值，比如： ① 协商缓存内容，② 服务端缓存内容(eg: 权限)</p><p>如果解决 ws 的 ① 重连状态保持  ② http 降级  ③ 代码自动生成  ④ 开发模式  ⑤ 测试工具包 问题，那么 ws 不失为一个很好的通信工具。</p><h2 id="代码生成的思考"><a href="#代码生成的思考" class="headerlink" title="代码生成的思考"></a>代码生成的思考</h2><p>代码生成是一个非常好的思路，可以保证代码的统一性，减少不规范的地方，可维护性更高。现在可以看到，在 client 和 server 代码生成上，grpc 做的是最好的，生态也比较开放，在这个基础上可以开发一些自己需要的功能。</p><p>Go-zero 框架是自己实现的一套语法解析并形成特定代码，提供了模板化的方法生成代码，也和 grpc 一样提供了自定义插件的方式，看上去野心不小。</p><p>Go-kratos 则是接入 grpc 的生态，通过扩展生成代码的方式，接入了自己的 http 和 rpc。</p><p>Go-frame 在接口自动化代码生产上没有动作，只是在 脚手架工具 中简化了 对 grpc 代码生成的命令。</p><p>除了上面说到的 基于接口文档 自动化生成 server 及 client 代码外，还有一些其他常用的可生成的代码：</p><ol><li>基于 数据库表 生成 结构体、orm、基本 crud 代码。</li><li>基于 接口定义，生成前端 client 代码。</li><li>生成部署侧的脚本或包 (docker、k8s、devspace等)</li></ol><p>第 1 点中的 model 生成，go-frame 和 go-zero 都有做。 第 2 点目前只有 go-zero 做了一些，grpc 也有一些。 第 3 点都有动作。</p><p>另外 ，补充一嘴，数据库的结构体生成 是可以 正反使用的，例如，通过 orm，生成数据库表，同样也可以通过 数据库表，生成 orm，这点可以参考 <a href="https://blog.longalong.cn/posts/22_03_21_%E5%85%B3%E4%BA%8E%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81.html">关于基于接口定义的开发流</a> 最后的链接。</p><h3 id="一个疑惑"><a href="#一个疑惑" class="headerlink" title="一个疑惑"></a>一个疑惑</h3><p>按理，http 才是互联网下的王者，那么，为什么很少见到基于 http 的 接口定义文档 自动生成代码的工具呢？</p><p>实际上，相比于 protobuff 的 proto3 这种新的 DSL ，我们使用已有语言的成本可能更低，例如 基于 yaml 或者 基于 json 的，比如使用 openapi 的接口定义。甚至，使用一门我们熟悉的语言做接口描述，例如 js，然后代码生成则直接使用 js 进行拼接 ( 或模板渲染 )。</p><p>这个可以找找是否有相关的工具，如果没有，可以自己实现一个。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>杂七杂八写了一些自己的想法，很多表述不一定很精准，但思路确实还是有可参考性的，可以经常回味一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>backend</tag>
      
      <tag>communication</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>service mesh 是如何产生的？</title>
    <link href="/longblog/posts/22_06_16_how_service_mesh_born.html"/>
    <url>/longblog/posts/22_06_16_how_service_mesh_born.html</url>
    
    <content type="html"><![CDATA[<h3 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h3><p>最原始的应用，是由小团队直接负责的单体应用，直观的感受是，团队里的每个人，都对整个项目的技术选型具有影响力(姑且认为 每个人都是 “技术管理委员会” 的成员)。由于仅有一个大项目，也就基本不存在 “平台能力” 的概念。</p><p>单体项目逐渐膨胀，分层逐渐模糊、模块逐渐耦合、调用逐渐混乱、发布越发频繁、单个错误的影响面越发增大…… ，这就进入到所谓的 “单体地狱” 阶段。 解决办法之一，就是进行 服务化演进。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>当单体服务拆分成多个服务后，从代码功能上，出现了一系列 与业务功能无关的 相似需求，例如 <code>服务发现</code>、<code>配置管理</code>、<code>负载均衡</code>、<code>健康检查</code>、<code>限流熔断</code>、<code>安全加密</code>、<code>协议转换</code>、<code>认证授权</code>、<code>链路追踪</code>、<code>通用监控</code> 等，我们将之统称为 “平台能力”。</p><p>在组织结构上，不同的服务 会被 不同的团队(人员) 所管理，服务的技术走向 会逐渐脱离原有的 “技术管理委员会” 的管理，逐渐出现 不同代码实现、不同库选型、不同框架选型、不同语言选型 等等情况。</p><p>当出现了一些上述的问题后，有识之士 就会想： <strong>“如何统一提供平台能力，解放业务专家们，让业务同学专注业务开发？”</strong></p><h3 id="解决问题的方向"><a href="#解决问题的方向" class="headerlink" title="解决问题的方向"></a>解决问题的方向</h3><h4 id="进程内方案"><a href="#进程内方案" class="headerlink" title="进程内方案"></a>进程内方案</h4><p>最直接的想法会是：根据不同语言，提供平台能力的 sdk。表现形式可能是： 工具库、应用框架。例如，统一的 web server 框架，在框架中提供 服务发现、负载均衡、监控、限流 等平台能力。</p><p>举个栗子，java 中的 <code>spring cloud</code> 提供了几大组件解决平台能力，如： <code>Eureka</code> 解决服务注册与发现、 <code>Ribbon</code> 解决负载均衡、 <code>Hystrix</code> 解决系统保护、 <code>Gateway</code> 提供 api 网关、 <code>Spring cloud config</code> 解决配置管理……</p><p>实际上，在单个语言体系下的各类 微服务框架 都是在解决这个问题。例如 golang 下的 <code>kratos</code>、<code>go-zero</code>、<code>go-micro</code>、<code>rpcx</code>、<code>kitex</code>、<code>go-kit</code> 等。(每个语言下都有一大堆)</p><p>但这种方式也存在 2 个主要问题： </p><ol><li>如果使用了多个语言体系，那么代码的维护成本就需要 *N 。例如，一个 负载均衡 的能力，如果有 python、java、golang、nodejs 4种语言，就需要对应的开发团队维护 4 套代码。难度之大，难以想象。  这个假设，其实是建立在一些 <code>大型团队</code>、<code>历史包袱重</code> 的前提下的。 对于大多数中小团队，服务端其实也只有一个语言体系，因此不失为一个不错的方案。</li><li>当平台能力不够稳定时(其实几乎很难稳定)，平台能力的升级需要业务代码同步更新，而推动业务同学进行库的升级，在稍大点的团队中是十分费心费力的。这也就是 代码耦合 带来的弊端。</li></ol><h4 id="进程外方案"><a href="#进程外方案" class="headerlink" title="进程外方案"></a>进程外方案</h4><p>在遇到上面的问题后，自然而然的想法，就是将一些平台能力进行抽离，在单独的进程中运行。独立部署后，使用一系列进程间通信的方式提供平台能力，就解决了 “语言绑定” 和 “代码绑定” 的问题。就这样，sidecar 模式诞生了！</p><p>Sidecar 在解决一些问题的同时，自然也引入了一些问题，主要有两个：</p><ol><li>通信方式的问题。</li><li>性能的问题。</li></ol><p>性能问题，从全局来看，由于多了一层进程外处理流程，不可避免地肯定会有性能损耗。解决办法自然就是尽量降低 sidecar 本身处理的资源耗用，包括 语言选型使用更高性能的语言(如 go、c++ 等)、代码层的架构设计和实现优化、扩展点使用更高性能的实现 (例如 grpc、wasm、golang、lua 等)。</p><p>通信方式 有两个走向：</p><ol><li>业务完全透明 的流量劫持 模式。</li><li>提供 http/grpc 的通信模式。</li></ol><h3 id="side-car-一览"><a href="#side-car-一览" class="headerlink" title="side car 一览"></a>side car 一览</h3><p>目前社区中比较出彩的 sidecar 解决平台能力的方案有： <a href="https://konghq.com/kong-mesh">kong(kuma)</a>、<a href="https://github.com/istio/istio">istio(envoy)</a>、<a href="https://github.com/traefik/mesh">traefik-mesh</a>、<a href="https://docs.nginx.com/nginx-service-mesh">nginx mesh (不开源)</a>、<a href="https://github.com/linkerd/linkerd2">linkerd</a>、 <a href="https://github.com/dapr/dapr">dapr</a> 、<a href="https://github.com/mosn/mosn">mosn</a>、<a href="https://github.com/megaease/easegress">easegress</a> 、<a href="https://github.com/hashicorp/consul">consul</a> 、<a href="https://github.com/openservicemesh/osm">osm(envoy)</a></p><p>从上面的项目可以看出，sidecar 大多都是从 <code>网关</code> 延伸而来的，这和 <code>平台能力</code> 的主体 <code>流量治理</code> 是分不开关系的。 基础能力是要做到 <code>服务发现</code>、<code>负载均衡</code>、<code>路由</code>、<code>安全</code>，延伸能力有  <code>限流熔断</code>、<code>可观测性(metrics、tracing)</code> 、<code>流量灰度</code>、<code>故障注入</code>、<code>认证授权</code>、<code>协议转换</code>、<code>管理平台</code> 。 </p><p>所有上面这些项目，有一个比较特殊： <code>dapr</code>，其他的基本都是 <code>网关</code>，而 dapr 被认为是一个 <code>应用运行时</code>，之所以 dapr 也被我列到这里，是因为他们有很多相似的地方，例如：<code>路由</code> 、<code>服务发现</code>、<code>负载均衡</code>、<code>可观测性</code> 等。 </p><p>现在看起来不一样的地方，例如 dapr 提供 <code>kvstore(state)</code>、<code>pubsub</code> 等，目标是提供与平台无关(不太相关) 的特定能力，例如 kvstore 就提供了 <code>DynamoDB</code> 、<code>redis</code>、<code>postgresql</code> 等实现。  从一部分 service mesh 的项目发展方向来看 (envoy、mson等)，流量代理的类型从原有的 <code>tcp</code>、<code>http</code>、<code>ws</code>、<code>http2</code>、<code>grpc</code> 等协议，扩展至 <code>redis</code>、<code>mongodb</code>、<code>dynamodb</code>、<code>kakfa</code>、<code>dubbo</code> 甚至是 自定义 协议(自有 rpc 协议) 的代理。 </p><p>有了这类中间件的代理，自然而然就会想着做些什么，比如 抽象一些通用业务能力，在代理中进行一些特定处理……， 这样，也就和 dapr 殊途同归了……</p><h3 id="趋势"><a href="#趋势" class="headerlink" title="趋势"></a>趋势</h3><p>可以看到一个趋势，随着技术需求的逐渐固化，开发模式逐渐靠近 <code>更加通用</code>、<code>更加透明</code>、<code>更加傻瓜式</code> 的设计理念，不论是各类开发框架提供的 <code>开箱即用 的开发套件</code>，还是类似于 grpc 提供的 <code>rpc client server 代码生成能力</code>， 亦或是各类脚手架工具提供的 <code>http 基础代码、orm 代码 一键生成</code> 能力，还是 基础设施层提供的 <code>流量代理side car</code> 流量治理能力，以及还未怎么普及的 <code>应用运行时</code>(eg: dapr)。</p><p>可以认为，基础设施所追求的一个目标是： <strong>极大地 降低业务人员的心智负担， 让业务人员 回归 业务开发！</strong> 。 </p><h3 id="我们可以做些什么？"><a href="#我们可以做些什么？" class="headerlink" title="我们可以做些什么？"></a>我们可以做些什么？</h3><p>为了实现这个目标，我们可以无所不用其极。例如：</p><ul><li>在一定程度上，选择一套完善的开发框架，能够完成业务开发的需要 (http server、log、api、orm)；</li><li>选择一套部署方案，能够快速准备环境，部署应用 (gitlab、k8s 等)；</li><li>选择一套通用基础设施，以及对应的管理平台 (mysql、redis、kafka 等)；</li><li>选择一系列通用工具，例如 功能测试、接口测试、压测、低代码平台、yapi、k8s 调试工具(devspace 等)、oauth平台、账户中心、rbac 等等；</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>实际上，<code>dapr</code> 的设计思想，和 <code>baas</code> 有着密不可分的联系。当我们盘点一下 baas 所提供的能力，例如 文档存储、事件通知 ，就会发现，和 dapr 提供的 state 管理、pub/sub(binding) 相对应。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh</a><br><a href="https://developer.aliyun.com/article/785943">Dapr 在阿里云原生的实践-阿里云开发者社区</a><br><a href="https://mosn.io/blog/posts/multi-protocol-deep-dive/">MOSN 多协议机制解析</a><br><a href="https://www.servicemesher.com/envoy/intro/what_is_envoy.html">Envoy 是什么? · Envoy proxy中文文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>service</tag>
      
      <tag>istio</tag>
      
      <tag>service mesh</tag>
      
      <tag>linkerd</tag>
      
      <tag>sidecar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搞定一个基础的私有部署环境</title>
    <link href="/longblog/posts/22_11_21_21_12_how_to_prepare_a_private_deploy_env.html"/>
    <url>/longblog/posts/22_11_21_21_12_how_to_prepare_a_private_deploy_env.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>私有部署在一些 TOB 的工具型企业中很常见，例如 神策、gitlab 、jira 、飞书 等等。</p><p>要私有部署服务，首先要解决运行环境的问题。</p><p>各企业的情况不同，能提供的环境也不一样。例如，有些企业只能提供物理机，系统随你装；有些企业只能提供特定操作系统的机器；有些企业希望提供 k8s 集群；有些企业提供的硬盘很拉胯；有些网络安全限制得特别严……</p><p>如果我们希望自己的实施同学轻松点，最好是提供一种统一的、不选择平台的部署方案。</p><p>简单场景下，我们可能会想到 docker； 如果有简单的编排需求，我们可能会想到 docker-compose。</p><p>在大多数场景下，我们通过一台硬件条件不错的机器，使用 docker-compose 几乎都能满足需求。</p><p>但如果，客户希望你的服务保证高可用、希望服务具有扩展性、希望…… 好吧，如果你的服务确实很复杂，又不是很稳定(资源抢占……)，确实需要横向扩机器的话……</p><p>那么可以考虑 k8s 集群。</p><h2 id="部署一套-k8s-集群"><a href="#部署一套-k8s-集群" class="headerlink" title="部署一套 k8s 集群"></a>部署一套 k8s 集群</h2><h3 id="简单的集群部署"><a href="#简单的集群部署" class="headerlink" title="简单的集群部署"></a>简单的集群部署</h3><p>之前在 <a href="/longblog/posts/22_07_21_12_45_install_k3s_in_air_gap_air.html" name="网络受限环境k3s安装记录" >网络受限环境k3s安装记录</a> 中记录过离线环境的 k3s 的安装，这只是简单的单个机器的 k3s server 安装，如果要安装集群，还需要在其他节点也做同样的操作，只是最后的命令需要改成 join。</p><p>这种场景，使用 <a href="https://docs.rancher.cn/docs/k3s/autok3s/_index/">autok3s</a> 还是很有优势的。</p><h3 id="稍微复杂一点的集群部署"><a href="#稍微复杂一点的集群部署" class="headerlink" title="稍微复杂一点的集群部署"></a>稍微复杂一点的集群部署</h3><p>当创建的集群节点比较多，且部署必须为离线部署时，则会遇到镜像多处拷贝的问题。解决的思路有两个： </p><ol><li>使用 ansible 工具，将 copy 的过程自动化</li><li>使用 docker-registry 的方式</li></ol><p>这里推荐使用 <a href="https://docs.docker.com/registry/">docker-registry</a>，因为更容易理解。在使用时，先把 docker-registry 的镜像放到 containerd 默认的镜像目录，再把 docker-registry 的 manifest 放到默认的 manifest 下。 </p><p>这样就能解决镜像一处更新的问题了。</p><p>将部署分成两个步骤： ① 创建基础集群  ② 部署业务应用</p><p><a href="http://sealer.cool/zh/">sealer</a> 的理念还是不错的，把集群进行打包，处处运行。 整体类似于 kubeadm 和 helm charts 的集合，以及做了镜像的管理。在一些场景下也是不错的方式。但目前来看，稍微有点 <code>黑盒</code> 了，没有直接使用 helm charts 来得清晰，或者说对实施同学而言，掌控感 略微不足。 对于一些希望使用自由 k8s 集群等情况时，就显得灵活性不足。</p><p>在部署了集群之后，就需要解决 集群管理、应用基础设施、应用部署 的问题。</p><h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><p>集群的管理主要是指：</p><ol><li>节点增删</li><li>集群资源修改</li><li>集群基本信息查看</li></ol><p>这类问题，可以通过一系列的 dashboard 解决，参考 <a href="/longblog/posts/21_12_26_a_record_of_k3s_run_up.html#解决面板及管理工具 和 [[网络受限环境k3s安装记录" name="记一次k3s环境搭建记录" >记一次k3s环境搭建记录</a></p><h2 id="应用基础设施"><a href="#应用基础设施" class="headerlink" title="应用基础设施"></a>应用基础设施</h2><p>应用基础设施，主要指 存储、监控、日志。<br>存储可以参考 <a href="/longblog/posts/22_11_11_20_48_k8s_nfs_storage_class.html" name="nfs、localpath作为k8s-storage-class" >nfs、localpath作为k8s-storage-class</a></p><p>监控的方案主要有两类， promethues 类 和 elastic 类，可以参考 <a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html" name="简单的集群监控方案" >简单的集群监控方案</a></p><p>日志的方案，主要有 ELK 和 EFK 两种常用的 ( logki 体系也可)，我选择 fluentbit，更多信息可以参考 <a href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html" name="简单的集群日志采集方案" >简单的集群日志采集方案</a></p><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><p>终于到了业务应用的部署环节。如果业务是无状态服务，那么很简单，直接找个业务低峰时进行镜像更新即可。如果为有状态服务，没有版本兼容问题还好处理，如果遇到版本不兼容就比较麻烦一点了，需要进行状态清洗或转换的操作。</p><p>私有部署中，针对不同的企业一般有一些独特的配置项，这些配置项需要独立出来。<br>一个常规的 helm charts 编写方式可以参考 <a href="/longblog/posts/22_11_22_00_15_normal_helm_charts.html" name="常规的charts编写方式" >常规的charts编写方式</a></p><p>对于 helm 的操作，可以参考 <a href="/longblog/posts/22_11_03_15_06_simple_usage_of_helm.html" name="helm的一些简单使用" >helm的一些简单使用</a></p><hr><blockquote><p>Don’t settle for a relationship that won’t let you be yourself.<br>— <cite>Oprah Winfrey</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>私有部署</tag>
      
      <tag>privazation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的集群监控方案</title>
    <link href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html"/>
    <url>/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于一个 saas 应用来说，面向的是广大用户，广大用户可能在任意一个时间点访问服务，因此，服务的高可用就变得非常重要了，用指标衡量的话，也就是 SLA (Service Level Agreement 服务等级保障)。</p><p>SLA 由两部分组成： 指标定义 + 目标 (SLI + SLO)(indicator + objective) 。具体的指标和目标根据不同的服务而定。对于一个系统的可用性，一般有一个很直观的指标：<code>1 - 当年宕机时长/当前总时长</code>，大家平常说的服务可用性为 2 个 9、3 个 9、4 个 9 基本值的都是这个。 </p><p>指标，也就是这套体系中的基石了，指标的采集、指标是否健康的判断、异常之后的告警 组成了监控体系。</p><h2 id="常用的指标体系"><a href="#常用的指标体系" class="headerlink" title="常用的指标体系"></a>常用的指标体系</h2><p>“服务可观测性” 方面，我们一般有 3 个方向： log、metrics、tracing。 指标也一样，绝大多数指标都是从这三个方向中得出来的。</p><p>本文中我们暂不讨论 metrics 的细节，也不讨论 log 和 tracing 系统，一些 log 系统的信息可以参考 <a href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html" name="简单的集群日志采集方案" >简单的集群日志采集方案</a> ，tracing 体系之后再聊吧。 本文着重于实践搭建一套简单实用的集群监控体系。</p><p>经典的 metrics 体系是 <a href="https://prometheus.io/docs/introduction/overview/">prometheus</a> + <a href="https://grafana.com/docs/">grafana</a>，这也是大多数互联网同学熟悉的体系。 prometheus 作为一个 metrics 数据采集器 + tsdb 存储引擎 + promql 查询语句，能很好地满足 metrics 使用的需求。 之前在 <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a> 也对 prometheus 做了一些代码层的研读。</p><p>实际上 metrics 存储和查询体系，从技术实现来看并不是特别难。我觉得 prometheus 最大的成功在于 <a href="https://prometheus.io/docs/operating/integrations/">生态</a> 。其一，它有比较完整的 client SDK，各语言都能很方便地集成；其二，它有齐全的工具链，采集、存储、查询、面板； 其三，它很好地实现了对 k8s 、service mesh 等的集成，云原生领域占了先机。</p><p>另外 一些常用的监控系统有:  zabbix、open-falcon、Nagios、datadog 等。 各有一些优劣，空了的话可以再进一步了解下。</p><p>prometheus 竞品中有一个比较有意思的身影: ELK，对，就是那个大名鼎鼎的日志系统。 他们的方案是 <a href="https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-overview.html">metricsbeat</a> + elasticsearch + <a href="https://www.elastic.co/cn/kibana/">kibana</a> 。</p><p>官方也有和一些竞品的对比： <a href="https://prometheus.io/docs/introduction/comparison/">官方对比文档</a></p><p>我们就选用 prometheus + grafana 的方案进行后续的实操了。</p><h2 id="监控项"><a href="#监控项" class="headerlink" title="监控项"></a>监控项</h2><p>一般而言，我们的架构体系中都会把软件系统分为这么几层：</p><ul><li>基础设施层 (机器、虚拟机、网络、磁盘、集群等)</li><li>基础服务层 (数据库、缓存、队列、配置中心、注册/调度中心、网关等)</li><li>应用层 (业务应用)</li></ul><blockquote><p>当然，从更广泛的视角看，业务本身可以作为一层，主要关注业务指标相关的东西，例如注册量、转化率、用户路径等等。 这类指标被直接成为 <code>业务指标</code> ，一般不融入到技术的监控中来，主要采用的方案是 <code>埋点上报</code> + <code>BI 平台</code>，这方面的内容也非常丰富，只有可以专门梳理一下。</p></blockquote><p>prometheus 的生态非常好，除了非常具体的业务监控外，其他几乎都有对应的开源监控项。</p><ul><li>基础设施：<ul><li>node: <a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></li><li>process: <a href="https://github.com/ncabatoff/process-exporter">https://github.com/ncabatoff/process-exporter</a></li><li>network: <a href="https://github.com/syepes/network_exporter">https://github.com/syepes/network_exporter</a></li></ul></li><li>k8s 集群： <ul><li><a href="https://github.com/kubernetes/kube-state-metrics">https://github.com/kubernetes/kube-state-metrics</a></li><li><a href="https://github.com/google/cadvisor">https://github.com/google/cadvisor</a></li></ul></li><li>基础服务：<ul><li>es: <a href="https://github.com/prometheus-community/elasticsearch_exporter">https://github.com/prometheus-community/elasticsearch_exporter</a></li><li>pg: <a href="https://github.com/prometheus-community/postgres_exporter">https://github.com/prometheus-community/postgres_exporter</a></li><li>java: <a href="https://github.com/prometheus/jmx_exporter">https://github.com/prometheus/jmx_exporter</a></li><li>redis: <a href="https://github.com/oliver006/">https://github.com/oliver006/</a></li><li>nginx: <a href="https://github.com/nginxinc/nginx-prometheus-exporter">https://github.com/nginxinc/nginx-prometheus-exporter</a></li><li>mongodb: <a href="https://github.com/percona/mongodb_exporter">https://github.com/percona/mongodb_exporter</a></li><li>gitlab-ci: <a href="https://github.com/mvisonneau/gitlab-ci-pipelines-exporter">https://github.com/mvisonneau/gitlab-ci-pipelines-exporter</a></li><li>haproxy: <a href="https://github.com/prometheus/haproxy_exporter">https://github.com/prometheus/haproxy_exporter</a></li><li>kafka-lag: <a href="https://github.com/seglo/kafka-lag-exporter">https://github.com/seglo/kafka-lag-exporter</a></li><li>kafka: <a href="https://github.com/redpanda-data/kminion">https://github.com/redpanda-data/kminion</a></li><li>kafka: <a href="https://github.com/danielqsj/kafka_exporter">https://github.com/danielqsj/kafka_exporter</a></li><li>ssl: <a href="https://github.com/ribbybibby/ssl_exporter">https://github.com/ribbybibby/ssl_exporter</a></li><li>gin: <a href="https://github.com/zsais/go-gin-prometheus">https://github.com/zsais/go-gin-prometheus</a></li><li>ping: <a href="https://github.com/czerwonk/ping_exporter">https://github.com/czerwonk/ping_exporter</a></li><li>nats: <a href="https://github.com/nats-io/prometheus-nats-exporter">https://github.com/nats-io/prometheus-nats-exporter</a></li><li>influxdb: <a href="https://github.com/prometheus/influxdb_exporter">https://github.com/prometheus/influxdb_exporter</a></li><li>rocketmq: <a href="https://github.com/apache/rocketmq-exporter">https://github.com/apache/rocketmq-exporter</a></li><li>airflow: <a href="https://github.com/epoch8/airflow-exporter">https://github.com/epoch8/airflow-exporter</a></li><li>pagespeed: <a href="https://github.com/foomo/pagespeed_exporter">https://github.com/foomo/pagespeed_exporter</a></li><li>ov: <a href="https://github.com/kumina/openvpn_exporter">https://github.com/kumina/openvpn_exporter</a></li><li>logstash: <a href="https://github.com/BonnierNews/logstash_exporter">https://github.com/BonnierNews/logstash_exporter</a></li><li>zk: <a href="https://github.com/dabealu/zookeeper-exporter">https://github.com/dabealu/zookeeper-exporter</a></li></ul></li></ul><p>上面这些只是自己扒的 github 得到的，其实官方文档已经维护了一份更全的了： <a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></p><ul><li>业务指标<ul><li>框架指标<ul><li>http 请求状态指标</li><li>ws 事件请求量、消息大小 histgram</li></ul></li><li>中间件使用指标<ul><li>kafka 消息情况 (可看 <a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html#应用中的经验" name="WIP-kafka的高吞吐原因" >sarama metrics 指标</a>)</li><li>数据库的连接情况、请求耗时等</li></ul></li><li>业务特性的指标<ul><li>eg: 登录失败人数</li></ul></li></ul></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="二进制部署"><a href="#二进制部署" class="headerlink" title="二进制部署"></a>二进制部署</h3><p>在机器上搭建 prometheus 很简单，直接一个 二进制就起来了。</p><ul><li>二进制的下载 <a href="https://prometheus.io/download/">可以从这里找</a></li><li>配置 可以参考<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">官方文档</a><ul><li>最简单的只用配 global 和 scrape_config 即可</li><li>如果要做告警，则要配置 <a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">rules</a> 和 <a href="https://prometheus.io/docs/alerting/latest/configuration/">alertManager</a>，告警的消息需要用 <a href="https://prometheus.io/docs/prometheus/latest/configuration/template_examples/">模板</a> 来实现</li><li>如果要和 k8s 集成 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config">service discovery</a>，需要为 prometheus 创建 role 和 rolebinding (ns、svc、ep、pod、node、ing 等的 list、watch)</li></ul></li></ul><h3 id="k8s-部署"><a href="#k8s-部署" class="headerlink" title="k8s 部署"></a>k8s 部署</h3><p>使用 <a href="https://github.com/prometheus-operator/prometheus-operator">prometheus-operator</a> , 这是对应的 <a href="https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack">helm charts</a> 。<br>这是<a href="https://prometheus-operator.dev/">官方文档</a></p><h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><ul><li><a href="https://github.com/prometheus/alertmanager">https://github.com/prometheus/alertmanager</a> (官方告警服务)</li><li><a href="https://github.com/samber/awesome-prometheus-alerts">https://github.com/samber/awesome-prometheus-alerts</a> (常用的 alerts)</li><li><a href="https://github.com/feiyu563/PrometheusAlert">https://github.com/feiyu563/PrometheusAlert</a></li><li><a href="https://www.aiops.com/docs/ca/">https://www.aiops.com/docs/ca/</a></li><li><a href="https://github.com/pppscn/SmsForwarder">https://github.com/pppscn/SmsForwarder</a> (短信接码)</li></ul><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><p>在监控</p><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><ul><li><a href="/longblog/posts/22_11_06_00_54_health_check_and_monitor.html" name="WIP-健康检查与监控梳理" >WIP-健康检查与监控梳理</a></li><li><a href="/notpublish/index.html" name="promethues的一些信息" >promethues的一些信息</a></li><li><a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li></ul><h2 id="不错的资料"><a href="#不错的资料" class="headerlink" title="不错的资料"></a>不错的资料</h2><ul><li><a href="https://github.com/roaldnefs/awesome-prometheus">https://github.com/roaldnefs/awesome-prometheus</a> (信息聚合，非常不错)</li><li><a href="https://github.com/crazy-canux/awesome-monitoring">https://github.com/crazy-canux/awesome-monitoring</a> (信息聚合，非常不错)</li><li><a href="https://exporterhub.io/">https://exporterhub.io/</a> (有几个中间件的监控资料聚合的社区)</li><li><a href="https://zhuanlan.zhihu.com/p/34005738">https://zhuanlan.zhihu.com/p/34005738</a> (grafana 使用技巧)</li><li><a href="https://prometheus.io/docs/practices/naming/">https://prometheus.io/docs/practices/naming/</a> (prometheus 官方最佳实践)</li><li><a href="https://zhuanlan.zhihu.com/p/563799358">https://zhuanlan.zhihu.com/p/563799358</a> (grafana panel 发送图片 实践)</li><li><a href="https://github.com/IzakMarais/reporter">https://github.com/IzakMarais/reporter</a> (grafana dashboard to pdf)</li><li><a href="https://github.com/zuchka/grafana-awesome">https://github.com/zuchka/grafana-awesome</a></li><li><a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a> (grafana 社区看板)</li><li><a href="https://github.com/starsliao/Prometheus">https://github.com/starsliao/Prometheus</a> 一哥们儿做的基础设施管理平台</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 梳理一下业务指标体系建设</li><li><input disabled="" type="checkbox"> grafana 的具体实践流程走一次<ul><li><input disabled="" type="checkbox"> sso 配置、看板导入导出、权限设置</li></ul></li></ul><hr><blockquote><p>I know where I’m going and I know the truth, and I don’t have to be what you want me to be. I’m free to be what I want.<br>— <cite>Muhammad Ali</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>operation</tag>
      
      <tag>monitor</tag>
      
      <tag>云原生</tag>
      
      <tag>k8s</tag>
      
      <tag>promethues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何白嫖存储空间</title>
    <link href="/longblog/posts/23_02_15_00_18_use_oss_for_file_backup.html"/>
    <url>/longblog/posts/23_02_15_00_18_use_oss_for_file_backup.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>手机中文件越来越多，空间越来越少，因此想找一个可用于文件备份的存储空间。</p><h2 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h2><h3 id="最简单的方案"><a href="#最简单的方案" class="headerlink" title="最简单的方案"></a>最简单的方案</h3><p>直接购买手机厂商提供的云盘，同步即可。</p><p>优点： 简单，方便，可预览。<br>缺点： 要花钱，长期来看还不便宜，私密性得不到保证。</p><h3 id="简单的方案"><a href="#简单的方案" class="headerlink" title="简单的方案"></a>简单的方案</h3><p>买一块硬盘，将手机中的文件转移到硬盘中。</p><p>优点： 私密性<br>缺点： 要花钱( 比买云盘便宜些，1T在500-1000元，5-10年都还ok )，硬盘坏了就 gg 了</p><h3 id="穷人的方案"><a href="#穷人的方案" class="headerlink" title="穷人的方案"></a>穷人的方案</h3><ul><li>参考 <a href="/longblog/posts/21_12_02_a_nas_solution_used_by_poor.html" name="穷人才会用的nas方案" >穷人才会用的nas方案</a></li></ul><h3 id="白嫖事儿还多的人的方案"><a href="#白嫖事儿还多的人的方案" class="headerlink" title="白嫖事儿还多的人的方案"></a>白嫖事儿还多的人的方案</h3><p>需求有这么几点：</p><ul><li>绝对不能花钱，10 块钱都不行！！</li><li>安全必须要保障，文件不能说丢就丢了！</li><li>私密性必须要保障，不想让自己的文件有泄漏的风险！</li><li>方便，使用起来要方便！</li></ul><p>梳理梳理思路啊：</p><p>第一，不能花钱，那就只有白嫖了，嫖谁呢？阿里云不行，虽然有 9 块钱 40g 一年的套餐，但终究要花钱啊，而且超过 40g 想扩展就很贵了。腾讯云、华为云也差不多。七牛云在认证了之后有 10G 的免费存储空间，可以嫖，但容量有限。</p><p>似乎专门做存储的不好搞，那不是专门做存储的怎么样呢？公共存储？</p><p>阿里云盘在经过一段时间发展，现在也还不错，目前不限速，容量还挺大，我现在就有 1.5T 左右的空间。但将来不好说，毕竟现在想吃一点百度的市场，不盈利谁会白做网盘呢。</p><p>阿里云盘可以考虑下抓一下接口，看看能怎么搞成自动化，作为一个备选方案还 ok。</p><p>还有谁有公共存储呢？似乎各大内容平台都有？主要是用来存各种静态资源的，比如图片啥的。 dockerhub 的公开镜像倒是可以无限免费存。 github 的公开仓库也可以免费存。 这里面的想象空间就比较大了 🐶 。</p><p>另一个思路是 p2p，公开的 p2p 存储节点，可以再调研看看。</p><p>第二，要保证安全，有两方面要考虑，① 尽量保证数据不会损坏 ② 尽量保证数据有多份冗余 。</p><p>如果要用公共存储，那就要考虑第一点尽量少发生，例如，不会因为长久未使用被删掉、被压缩、被处理……，不会因为平台关闭导致数据丢失。 </p><p>多份冗余，多存几份咯，可以通过分块、副本的方式保证冗余，俗话说，鸡蛋不能放到同一个篮子里~</p><p>第三，私密性。 不用说，就是加密。</p><p>第四，方便。 考虑一些使用场景，比如，文件的预览、打开、恢复、删除、迁移 等操作要能够很方便地进行。</p><h2 id="整体的思路"><a href="#整体的思路" class="headerlink" title="整体的思路"></a>整体的思路</h2><h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><ul><li>github</li><li>dockerhub</li><li>阿里云盘</li><li>阿里云 docker hub?</li></ul><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><ul><li>密钥加密</li><li>三方认证加密 (openid + salt)</li></ul><h3 id="冗余方式"><a href="#冗余方式" class="headerlink" title="冗余方式"></a>冗余方式</h3><ul><li>切分 block</li><li>多平台冗余存储</li><li>增量更新，不删老数据 (公共存储很多不提供 delete 操作)</li></ul><h3 id="便利性"><a href="#便利性" class="headerlink" title="便利性"></a>便利性</h3><ul><li>专属应用进行管理</li><li>提供缩略图<ul><li>pdf 可以参考 <a href="https://gist.github.com/alamsal/bdfa7528cc9bd291e527">python-pdf-thumbnail</a></li><li>word、txt</li><li>ps、sketch 等</li></ul></li><li>一系列小文件可采用文件夹打包的方案</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>把 <a href="/longblog/posts/21_12_02_a_nas_solution_used_by_poor.html" name="穷人才会用的nas方案" >穷人才会用的nas方案</a> 做一个升级，看看能怎么变成一套超级自动化的方案。</li><li>继续梳理公共存储的方案，形成一套可用的工具。</li></ol><hr><blockquote><p>It is the province of knowledge to speak, and it is the privilege of wisdom to listen.<br>— <cite>Oliver Wendell Holmes Jr.</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>oss</tag>
      
      <tag>backup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golevelDB源码走读</title>
    <link href="/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html"/>
    <url>/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html</url>
    
    <content type="html"><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><ul><li><a href="https://github.com/syndtr/goleveldb">https://github.com/syndtr/goleveldb</a> (lsm)</li><li><a href="https://github.com/flower-corp/lotusdb">https://github.com/flower-corp/lotusdb</a> (lsm &amp; b+, using bbolt)</li><li><a href="https://github.com/timtadh/fs2">https://github.com/timtadh/fs2</a> (b+ &amp; list)</li><li><a href="https://github.com/philippgille/gokv">https://github.com/philippgille/gokv</a> (kv abstract)</li><li><a href="https://github.com/flower-corp/rosedb">https://github.com/flower-corp/rosedb</a>  (bitcask)</li><li><a href="https://github.com/etcd-io/bbolt">https://github.com/etcd-io/bbolt</a> (b+, 很牛)</li><li><a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a> (etcd, 基于 bbolt)</li></ul><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul><li>levelDB 采用 LSM tree，具体的存储文件采用 sstable 格式</li><li>levelDB 是一个单机应用，且没有配备 server 和 client，相当于 sqlite 的模式</li><li>rocksDB 是以 levelDB 为基础的分布式 kv server</li><li>Google BigTable，HBase，RocksDB，Apache Cassandra 都是基于 LSM tree 的数据库</li><li>chrome 的 indexDB 也是基于 levelDB 的 (或者参考？)</li><li>其实 prometheus 也是同样的模型 <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li><li>对于一些嵌入式场景，或者一些 有状态 server，都可以用 levelDB 做 kv 存储</li><li><a href="https://github.com/ideawu/ssdb">SSDB</a> 是基于 levelDB 的 kv 存储，提供了 client-server ，并实现了 redis 的接口，可以用 redis client 实现很多功能，还是很有前途的。 </li><li><a href="https://riak.com/assets/bitcask-intro.pdf">bitcask</a> 是类 LSM tree 的方案，具体的存储上，采用了 hashmap 的方式，<a href="https://github.com/roseduan/rosedb">rosedb</a> 就是采用这种方案，并且也实现了 redis 的接口。</li></ul><h2 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h2><p>不得不说，用两个字形容 goleveldb 的代码： 非常简洁！</p><ul><li><input disabled="" type="checkbox"> 需要再细看一下 memdb 的具体实现</li><li><input disabled="" type="checkbox"> 需要再细看一下 compact 的具体实现</li></ul><p>看看别人的笔记，写得多好啊：</p><ul><li><a href="https://www.jianshu.com/p/750c7ea9b88c">https://www.jianshu.com/p/750c7ea9b88c</a> (levelDB)</li><li><a href="https://www.jianshu.com/p/a4ce176f11ce">https://www.jianshu.com/p/a4ce176f11ce</a> (levelDB)</li><li><a href="https://www.jianshu.com/p/798c457412d7">https://www.jianshu.com/p/798c457412d7</a> (levelDB)</li><li><a href="https://www.jianshu.com/p/82c0a55f8b92">https://www.jianshu.com/p/82c0a55f8b92</a> (levelDB)</li><li><a href="https://mp.weixin.qq.com/s/s8s6VtqwdyjthR6EtuhnUA">https://mp.weixin.qq.com/s/s8s6VtqwdyjthR6EtuhnUA</a> (rosedb 作者)</li><li><a href="https://blog.csdn.net/ws1296931325/article/details/86635751/">https://blog.csdn.net/ws1296931325/article/details/86635751/</a> (sstable)</li><li><a href="https://zhuanlan.zhihu.com/p/415799237">https://zhuanlan.zhihu.com/p/415799237</a> (lsm tree)</li><li><a href="https://zhuanlan.zhihu.com/p/490963897">https://zhuanlan.zhihu.com/p/490963897</a> (lsm tree)</li><li><a href="https://developer.hashicorp.com/vault/tutorials/monitoring/inspect-data-boltdb">https://developer.hashicorp.com/vault/tutorials/monitoring/inspect-data-boltdb</a> ( hashicorp 的 vault 项目实例 )</li><li><a href="https://zhuanlan.zhihu.com/p/332439403">https://zhuanlan.zhihu.com/p/332439403</a> ( bboltdb，看看别人是怎么写源码导读的 ) <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html#你想要什么？" name="prometheus代码走读" >如何把读源码价值最大化</a></li></ul><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><ul><li>嵌入式场景下的数据库选型</li></ul><hr><blockquote><p>Happiness mainly comes from our own attitude, rather than from external factors.<br>— <cite>Dalai Lama</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>code reading</tag>
      
      <tag>源码阅读</tag>
      
      <tag>levelDB</tag>
      
      <tag>LSM tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>alertmanager等监控项目源码走读</title>
    <link href="/longblog/posts/23_02_09_15_15_code_reading_of_alert_manager.html"/>
    <url>/longblog/posts/23_02_09_15_15_code_reading_of_alert_manager.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做私有部署的监控告警方案，由于我们线上用的是 promethues + alert manager + grafana 的方案，为了保持方案一致性，也使用了这套方案。</p><p>但在梳理需求的过程中，发现了一些其他的应用，具体可以查看:</p><ul><li><a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html" name="简单的集群监控方案" >简单的集群监控方案</a></li><li><a href="/longblog/posts/22_11_06_00_54_health_check_and_monitor.html" name="WIP-健康检查与监控梳理" >WIP-健康检查与监控梳理</a></li></ul><p>其中，发现 <a href="github.com/megaease/easeprobe">easeprobe</a> 和 <a href="https://github.com/sourcegraph/checkup">checkup</a> 这两个项目还挺有意思，这和我们平常所认识的： promethues 、 zabbix、open-falcon、Nagios、datadog 等等不同。 这两个项目都是面向简单环境下的检查，很轻量，都是一个配置文件 + 一个二进制文件 即可运行起来。</p><p>在这里对 alertmanager 、easeprobe 、 checkup 做一次源码走读，看看有些什么可以借鉴的。</p><h2 id="整体认识"><a href="#整体认识" class="headerlink" title="整体认识"></a>整体认识</h2><p>对于监控告警而言，整体来说有这么几个核心概念：</p><ul><li>监控探测</li><li>探测数据存储</li><li>数据检查规则</li><li>告警分发<ul><li>告警组</li><li>告警渠道</li></ul></li><li>辅助系统<ul><li>api server</li><li>fontend admin page</li></ul></li></ul><p>以上是一个监控告警系统的核心环节，当然，在这之上可以添加很多辅助系统，例如用户系统、权限系统 等等。</p><h2 id="代码走读"><a href="#代码走读" class="headerlink" title="代码走读"></a>代码走读</h2><h3 id="alertmanager"><a href="#alertmanager" class="headerlink" title="alertmanager"></a>alertmanager</h3><h4 id="代码层级主体职能"><a href="#代码层级主体职能" class="headerlink" title="代码层级主体职能"></a>代码层级主体职能</h4><ul><li><p>cmd</p><ul><li>amtool<ul><li>这是 cli 的入口文件，详情可查看 cli 目录</li></ul></li><li>alertmanager<ul><li>这是 server 的直接入口文件</li><li>做一系列的初始化，例如： nflog(详见 nflog 目录)、cluster (详见 cluster 目录)、slience (详见 slience 目录)、mem provider (详见 provider 目录)、dispatch、api server (详见 api 目录)</li></ul></li></ul></li><li><p>config</p><ul><li>配置的 model，主要有 route (分发路由)、notifier (通知渠道)</li></ul></li><li><p>dispatch</p><ul><li>实现了 route 和分发逻辑。两个循环，① 循环接收 alerts  ② 对每一个 alert 循环判断是否需要分发到 route。</li><li>聚合了 route(aggrGroup)、provider.Alerts、notify.Stage 等实例。</li></ul></li><li><p>api</p><ul><li>api server 的实现</li><li>restapi : 做了一个 http server 的封装，我们一般使用现成的框架，例如 gin、echo 等等。  <ul><li>api： 具体业务接口的实现。</li><li>operations： 做了一些 params 和 response 的定义，看起来感觉实际意义不大。</li></ul></li><li>models : 接口的模型，做了 Validate 和 marshal 的逻辑，我们一般使用 tag 的方式做 validate，使用 http 框架提供的 bind 等做 marshal 操作。</li><li>client: 实际的 service 接口，业务方可直接使用作为 client sdk。</li></ul></li><li><p>notify</p><ul><li>通知的具体实现，有很多通知类型，写一些通知工具的时候可以参考： email、discord、opsgenie、pushover、slack、sns、telegram、webex、wechat……</li><li>扩展很方便，仅需要实现 Notify 接口即可。</li></ul></li><li><p>provider</p><ul><li>alerts 的暂存和分发，目前仅有 mem 的实现。</li></ul></li><li><p>store</p><ul><li>存储的实际实现，主体为一个 map 结构，有 gc。 provider 的 mem 中存的也是这个。</li></ul></li><li><p>silence</p><ul><li>静默的实现</li></ul></li><li><p>types</p><ul><li>几个公共的 model</li></ul></li><li><p>cluster</p><ul><li>集群实现</li></ul></li><li><p>cli</p><ul><li>提供一系列 cli 命令，主要是用于和 server 交互的，例如 添加告警、添加静默、获取状态 等等。</li><li>使用的 <a href="https://github.com/alecthomas/kingpin">alecthomas/kingpin</a> cli 框架，我们平常用的是 cobra。</li></ul></li><li><p>timeinterval</p><ul><li>自己实现了一个时间周期判断器</li></ul></li><li><p>asset</p><ul><li>用的 github.com/shurcooL/httpfs 把静态资源打包到二进制文件中，保证了启动服务的简单。</li></ul></li><li><p>nflog</p><ul><li>每隔一段时间把接收到的 notify 情况进行 log 存储，用 proto 定义了 entry，存的也是 protocal buffer。</li></ul></li><li><p>ui</p><ul><li>管理面板的实现，前端项目，最后会打包到 assets 中。这种模式很方便，可以参考。</li></ul></li><li><p>把 proto 作为 model 使用</p><ul><li>cluster</li><li>nflog</li><li>slience</li></ul></li><li><p>使用二进制文件存数据</p><ul><li>nflog</li></ul></li><li><p>在网上看到这个，觉得不错</p></li></ul><p><img src="https://static.longalong.cn/img/20230220141634.png"></p><h3 id="easeprobe"><a href="#easeprobe" class="headerlink" title="easeprobe"></a>easeprobe</h3><ul><li>channel : 消息通道，用来绑定探测和通知的</li><li>cmd : 服务的入口，做配置解析、绑定探测器、绑定通知 等等</li><li>conf : 全局的配置定义</li><li>daemon : 做 pidfile 管理，避免重复启动，没有重启能力</li><li>eval : 结果解析器，有 JSON、xml、text、html 等解析器，可以定义更丰富的结果判断方法</li><li>global : 定义一些全局变量</li><li>metric : 对接 promethues 指标</li><li>notify : 消息通知渠道，有很多种通知，可以参考<ul><li>base : 所有 notify 公共的字段和方法，继承 和 实现接口 是两种很通用的多态方式。</li></ul></li><li>probe : 探针的逻辑，最核心的部分<ul><li>data : 使用全局变量，保存所有探针结果。 status 为探针得出的结论。stat 为每次探测的记录。result 为当前探针的结果，包括了 status 和 stat 以及 探针本身的信息。</li><li>base : 探针的主题逻辑，使用 Config(probeFuc) 的方式实现多态，由各种探测方式自行进行探测，并返回结果给 base。</li></ul></li><li>report : 拼接各种报告模板</li><li>web : 提供 metrics 采集 和 报告获取接口</li></ul><p>整个服务实现得很简单清晰，很值得参考，主要有 ① 全局 config 的定义  ② 探针和 notify 的多态实现。</p><h3 id="checkup"><a href="#checkup" class="headerlink" title="checkup"></a>checkup</h3><ul><li>check : 提供了一些检查方式，有 http、tcp、tls、dns，还有 exec</li><li>cmd : 命令的入口文件<ul><li>采用了 cobra 的命令行框架</li><li>提供了几种执行探测的方式</li><li>serve : 提供了 web 服务，具体的前端代码在 statuspage 中</li></ul></li><li>notifier : 几种通知的方式<ul><li>每次检测 (每次检测可配置多次测试)，如果有错误就进行通知</li></ul></li><li>storage : 提供了多种存储方式，可用文件存储，也可用 sql 存储</li><li>types : 一些 model 的定义</li><li>checkup.go、notifier.go、storage.go 都是一些 model 的定义</li></ul><p>这个工具非常简单，把几个部分都拆得特别干净，相互没有依赖，也没有全局依赖，和上面两个不同的是，它完全采用了 无状态 设计，这让它可以实现分布式部署，所有数据都汇总到一个独立的地方，再对数据做聚合。</p><blockquote><p>吐槽一下，界面还是有点…… 🤦🏻‍♀️</p></blockquote><h2 id="简单思考"><a href="#简单思考" class="headerlink" title="简单思考"></a>简单思考</h2><p>这几个项目都比较简单，在梳理清楚 <code>工具的目标</code> 之后，实施起来实际上都不会特别麻烦。</p><p>但不同的开发者，看问题的视角和开发习惯都不完全相同，因此也有一些编程技巧是可以借鉴和学习的。</p><h3 id="你想得到什么？"><a href="#你想得到什么？" class="headerlink" title="你想得到什么？"></a>你想得到什么？</h3><p>这些都只是工具而已，看过了一遍代码也就过去了，关键还是得知道： 你究竟想得到什么？是否有战略目标？是否能把自己看到的这些东西融入到自己的一套体系中？</p><p>我希望得到：</p><ol><li>企业级业务系统可直接使用的监控方案</li><li>小项目可直接使用的监控方案</li></ol><h3 id="后续-TODO"><a href="#后续-TODO" class="headerlink" title="后续 TODO"></a>后续 TODO</h3><ul><li><del>走读 pushgateway 代码</del> <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li><li><del>走读 prometheus 代码</del> <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li><li><del>走读 prometheus client go 代码</del> (简单看了下，没什么特别说的)</li><li><del>完全走一次 promethues 的监控告警流程</del> <a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html#二进制部署" name="简单的集群监控方案" >简单的集群监控方案</a></li><li>梳理在具体业务中使用 easeprobe 的场景<ul><li>考虑家用场景</li><li>考虑看板 和 ui 平台的价值</li></ul></li></ul><hr><blockquote><p>This is the final test of a gentleman: his respect for those who can be of no possible value to him.<br>— <cite>William Lyon Phelps</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>code reading</tag>
      
      <tag>源码阅读</tag>
      
      <tag>源码</tag>
      
      <tag>alertmanager</tag>
      
      <tag>monitor</tag>
      
      <tag>easeprobe</tag>
      
      <tag>checkup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于k8s之上的一些平台的梳理</title>
    <link href="/longblog/posts/23_03_07_23_16_some_platforms_on_k8s.html"/>
    <url>/longblog/posts/23_03_07_23_16_some_platforms_on_k8s.html</url>
    
    <content type="html"><![CDATA[<h2 id="一些杂思"><a href="#一些杂思" class="headerlink" title="一些杂思"></a>一些杂思</h2><p>k8s 是一个云原生操作系统，和传统的操作系统所做的事类似，都是对资源进行虚拟化，并提供一系列通用场景的模型来抽象这些资源。 传统操作系统主要在  cpu、mem、持久化、进程、网络、权限 方面做了抽象和虚拟，k8s 主要在 node、workload、持久化、网络、权限 方面做了抽象和虚拟，突出的地方在于 <code>将传统操作系统对于一台机器的管理</code> 变成了 <code>对集群中所有机器的管理</code> 。</p><p>以往，在操作系统之上诞生了 Iaas、paas、saas 的服务体系，那么在 k8s 的体系下，又会有什么变化吗？</p><p>k8s 可以认为是在 Iaas 和 Paas 之间的一层，一定程度上可以对标 openstack (但实际上属于这之上，毕竟 k8s 不能对基础设施做控制，维度不同，但 openstack 也能做容器的编排，所以层次比较交叉)。</p><p>一般认为，paas 提供的是在基础设施之上，能降低业务应用开发和维护成本的一系列辅助系统的集合，例如 paas 能提供业务需要的 存储空间、CICD流、常用中间件、数据库等等…… 从这个角度看，k8s 不属于 paas，也不属于 iaas，而是夹在这两者之间。</p><p>那么，自然而然的，至少会诞生这三类生态形态： ① 在 Iaas 之上的，用于维护和管理 k8s 的平台  ② 在 k8s 之上的 paas 平台  ③ 在特定领域扩展 k8s 能力的应用</p><p>实际上，我们也确确实实看到了这些形态的项目，以下举一些例子：</p><ol><li>kubeless</li><li>kubesphere</li><li><a href="https://openkruise.io/zh/docs/">openkruise</a></li><li><a href="http://static.kubevela.net/">kubevela</a></li><li><a href="https://istio.io/latest/zh/docs/concepts/traffic-management/">istio</a></li></ol><p>k8s 诞生的历史使命，实际上是解决大规模服务部署与维护的问题。无论 k8s 之上建立起了多少强大的生态，也一定是为更好地实现这个目标而服务的。从一个角度看，不管 paas 还是 saas，实际上都是应用，那么只有真正把 <code>应用部署和维护</code> 的事做好，才算是最大化地发挥了 k8s 的价值。</p><p>应用部署和维护有什么特别难解的问题？</p><ul><li>流量治理<ul><li>金丝雀发布</li><li>可观测性建设 (eg: ebpf)</li></ul></li><li>有状态服务维护</li><li>跨区域集群调度和维护</li><li>工程上操作友好 (理解成本)<ul><li>flow (kubevela、argoCD、airflow……)</li><li>control (admin、kubesphere、spinnaker……)</li></ul></li></ul><p>看看如何把这几件事做好！</p><hr><blockquote><p>A man sees in the world what he carries in his heart.<br>— <cite>Johann Wolfgang von Goethe</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>kubevela</tag>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-改变意味着什么？</title>
    <link href="/longblog/posts/23_02_01_08_22_what_is_change.html"/>
    <url>/longblog/posts/23_02_01_08_22_what_is_change.html</url>
    
    <content type="html"><![CDATA[<p>人人都知道，唯有改变才能带来新事物，想到达理想的彼岸，只有通过改变现状，持续朝着彼岸前进。</p><p>但我们真的理解 改变 意味着什么吗？</p><p>改变意味着 朝着理想目标在前进<br>改变意味着 打破现状<br>改变意味着 与原有的 行为习惯 和 思维习惯 做斗争<br>改变意味着 你需要放弃现在拥有的一些东西</p><p>“得到” 和 “放弃” 是 “改变” 的一体两面，没有放弃也就不会有得到。</p><p>做好心理准备分为两个方面，一方面是指 “能接受所放弃的东西”，另一方面，是指”能接受没有获得期待的东西”。</p><p>如果没有做好心理准备，就会在短暂的改变过程中，被”意外”的失去打个措手不及，导致一次改变之旅被扼杀在襁褓中。</p><p>刨去外在环境的差异，绝大多数人在底层的潜力都是差不多的，是否能发挥出这份潜力，取决于内外两方面，整体而言有两种典型模式：</p><ul><li><p>外在环境带动改变</p></li><li><p>内在核心驱动改变</p><p>  两种模式不是割裂的，可以同时具备，也可能同时不具备</p></li></ul><p>驱动力有两种，同样，阻力也有两种：</p><ul><li>外在环境的阻力</li><li>内在思维和习惯的阻力</li></ul><p>人们期待改变，但往往又不能接受改变带来的副产物，所以又会尽可能阻碍改变。 这是人生常态，也是阻碍人转变的重要原因。</p><p>看到窈窕淑女、肌肉猛男，我们都想拥有其所带来的好处，但是否考虑过得到它的代价 以及 它的副产物呢？</p><p>改变，意味着你在期待能得到好处的同时，也要能够接受其带来的副产物。</p><p>举一些例子：</p><p>你想拥有很强的技术，那你是否愿意舍弃休息时间？是否愿意死磕一些基础知识？是否愿意探索可能没有任何收益的问题？<br>你想成为牛逼的作家，是否愿意接受很长时间没有收入或收入很低？是否愿意接受大量时间处于沉思状态而不是娱乐？是否愿意接受一系列你可能无法接受的观点？是否愿意接受可能成为疯子？<br>你想成为肌肉猛男，是否愿意接受早起运动？是否愿意长期接受缺盐少油的食物？是否愿意接受肌肉的疼痛？</p><p>用一个不大恰当的比喻： 爱屋及乌<br>也如魔兽中所言：那么古尔丹，代价是什么？</p><p>要想改变，就要梳理清楚这些问题：</p><ul><li>改变的意义是什么？</li><li>改变有哪些动力？</li><li>改变有哪些阻力？</li></ul><p>进而可以逐个击破：</p><ul><li>明白自己想要的是什么？为什么想要？</li><li>明白自己可以借助哪些力量达成目标？</li><li>明白哪些问题会阻碍我们前进，又能如何解决？</li></ul><p>实际案例：<br>我自己的例子，想要获得内心的平静，寻找意义的过程中，就会经历 观念轰炸，娱乐压缩，持续非舒适区。</p><p>其他思考：</p><ul><li>我如何能应用这套 改变的框架 去实现改变？</li><li>如何把用这套框架进行改变的过程进行作品化，并扩大影响力？</li><li>作为”金手指”的一部分，如何让其发挥更大的作用？进行更广泛的实践？</li></ul><p>文档直通车：</p><ul><li><a href="/longblog/posts/23_01_31_13_25_the_way_to_build_habit.html" name="习惯的养成方法论" >习惯的养成方法论</a></li><li><a href="/notpublish/index.html" name="习惯养成列表" >习惯养成列表</a></li><li><a href="/notpublish/index.html" name="习惯养成的另一个隐藏破坏者" >习惯养成的另一个隐藏破坏者</a></li><li><a href="/notpublish/index.html" name="以案例分析和练习为主的学习方法论" >以案例分析和练习为主的学习方法论</a></li></ul><hr><blockquote><p>To do all that one is able to do, is to be a man; to do all that one would like to do, is to be a god.<br>— <cite>Napoleon</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>改变</tag>
      
      <tag>习惯</tag>
      
      <tag>成长</tag>
      
      <tag>金手指</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫漫减肥路，渺渺肌肉身</title>
    <link href="/longblog/posts/23_01_31_13_02_the_way_i_lose_weight.html"/>
    <url>/longblog/posts/23_01_31_13_02_the_way_i_lose_weight.html</url>
    
    <content type="html"><![CDATA[<p>不能仅依靠意志减肥，还要用习惯和科学。</p><blockquote><p>意志受到 心力 的重大影响，解决心力问题，可以参考 <a href="/longblog/posts/23_01_31_11_36_ways_to_keep_heart_strength.html" name="WIP-心力保持方法" >WIP-心力保持方法</a></p></blockquote><ul><li>减重意识<ul><li>持续的意识增强</li></ul></li><li>减重目标<ul><li>清晰、合理的目标</li></ul></li><li>减重反馈与激励<ul><li>目标激励 (减重的目标、理想形象的目标)</li><li>过程激励</li><li>组队激励</li></ul></li><li>减重心态<ul><li>减重有多重要？为什么减重很重要？</li><li>你如何看待第二天胖了一斤？</li><li>你对减重周期的理解是怎样的？</li><li>你如何看待减重期吃了一个冰淇淋？</li><li>运动和玩手机相比，你怎么权衡？</li><li>韩式炸鸡在你眼中是什么样？</li></ul></li><li>减重方法<ul><li>饮食知识<ul><li>分量与热量</li><li>饱腹与血糖</li></ul></li><li>饮食习惯<ul><li>点菜习惯</li><li>夹菜习惯 (高糖、高油、高盐)</li><li>光盘的习惯</li></ul></li><li>运动知识</li><li>运动习惯</li><li>行为习惯的影响<ul><li>购物习惯</li><li>拿零食的习惯</li><li>答应他人吃东西的习惯</li><li>……</li></ul></li></ul></li><li>减重微操控制<ul><li>监控摄入，及时截断</li><li>保持心力，减少身体不适，及时补充能量</li></ul></li></ul><p>文档直通车：</p><ul><li><a href="/longblog/posts/23_01_31_13_02_beautiful_life_record_management.html" name="美好生活记录管理" >美好生活记录管理</a></li><li><a href="/longblog/posts/23_01_31_13_25_the_way_to_build_habit.html" name="习惯的养成方法论" >习惯的养成方法论</a></li></ul><hr><blockquote><p>I don’t want to achieve immortality through my work… I want to achieve it through not dying.<br>— <cite>Woody Allen</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>健康</tag>
      
      <tag>饮食</tag>
      
      <tag>健身</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-心力保持方法</title>
    <link href="/longblog/posts/23_01_31_11_36_ways_to_keep_heart_strength.html"/>
    <url>/longblog/posts/23_01_31_11_36_ways_to_keep_heart_strength.html</url>
    
    <content type="html"><![CDATA[<p>心力有限、心力提升、心力恢复、远离心力消耗、远离精神内耗</p><p>提升：</p><ul><li>提高格局</li><li>思路转变</li><li>无所谓啦</li></ul><p>恢复：</p><ul><li>放下一切，不要在心力耗尽时再刺激</li><li>做开心的事</li><li>休息，恢复精神</li><li>做简单、有成就感的事</li><li>最简单、可沉入其中的事</li></ul><p>远离：</p><ul><li>关注哪些是消耗心力的事</li><li>改变行为</li><li>关注哪些是精神内耗</li><li>改变心态</li></ul><p>常有的心力消耗：</p><ul><li>他人的情绪传递</li><li>身体的疲惫却无法得到休息</li><li>注意力的分散</li></ul><p>文档直通车：</p><ul><li><a href="/longblog/posts/22_08_08_16_20_thoughts_of_heart_strength.html" name="聊聊心力" >聊聊心力</a></li></ul><hr><blockquote><p>Ideas pull the trigger, but instinct loads the gun.<br>— <cite>Don Marquis</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>心力</tag>
      
      <tag>精神</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-专注力练习计划</title>
    <link href="/longblog/posts/23_01_31_11_30_practice_of_foucus.html"/>
    <url>/longblog/posts/23_01_31_11_30_practice_of_foucus.html</url>
    
    <content type="html"><![CDATA[<h3 id="专注的价值"><a href="#专注的价值" class="headerlink" title="专注的价值"></a>专注的价值</h3><p>专注的价值非常大，两个主要方面：</p><ul><li>专注时的效率是非专注时的 3 倍及以上，专注时长越长，效率的倍数越高</li><li>专注产生的心流状态让人快乐，快乐是我等应当追求的</li></ul><p>反面来看，注意力的分散会造成精力的消耗，精力的消耗又会影响到 心力，心力消耗会影响到个人心情和情绪，进而影响到家庭幸福。 所以，注意力管理非常重要。</p><h2 id="提升专注力的方法论"><a href="#提升专注力的方法论" class="headerlink" title="提升专注力的方法论"></a>提升专注力的方法论</h2><ul><li>减少干扰源<ul><li>移开、关闭</li><li>记录到 todo</li></ul></li><li>自我专注力监控<ul><li>专注力回归练习</li></ul></li><li>专注习惯养成<ul><li>番茄钟法</li></ul></li></ul><h3 id="减少注意力分散"><a href="#减少注意力分散" class="headerlink" title="减少注意力分散"></a>减少注意力分散</h3><p>心理学上认为，一个正常人能同时关注的事项仅为 5-7 项。超过能接受的关注项数量，我们就会产生焦虑。</p><p>举个简单的例子：</p><p>你第二天早上要出差，现在已经是晚上12点，你困到不行必须要睡觉了，但你的行李还没有收拾好，你在脑海里罗列了一下你明早要做的事： ① 带上公司的印章 ② 带上键盘 ③ 还有两个文件没签字 ④ 走之前给 xx 打个电话沟通下接待问题 ⑤ 记得把钥匙留给 xxx …… 。你告诉自己，这些事都很重要，漏任意一个都会造成很麻烦的事……</p><p>现在，你还睡得着吗？</p><p>如果，现在你起身，把上面这几项写在纸条上，把纸条贴在卫生间门上。</p><p>现在，睡得着了吗？</p><p>其他:<br>写作的一些要点： </p><ul><li>跟我有什么关系 是最先要回答的问题</li><li>金字塔结构 会更加便于理解</li><li>讲故事 大于 讲道理</li><li>分条列点 会更简洁明了有冲击力</li></ul><hr><blockquote><p>To accomplish great things, we must not only act, but also dream; not only plan, but also believe.<br>— <cite>Anatole France</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>长远价值</tag>
      
      <tag>专注力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-时刻365计划概览</title>
    <link href="/longblog/posts/23_01_29_14_24_overview_of_plan_moment_365.html"/>
    <url>/longblog/posts/23_01_29_14_24_overview_of_plan_moment_365.html</url>
    
    <content type="html"><![CDATA[<ul><li>时刻365计划</li><li>摄影知识学习</li><li>摄影评析活动</li><li>摄影刻意练习</li></ul><ul><li>摄影练习成果展示方案</li><li>摄影作品化及展示方案</li></ul><h3 id="时刻365计划"><a href="#时刻365计划" class="headerlink" title="时刻365计划"></a>时刻365计划</h3><p>这个计划的目标是提升我们的拍摄能力，以实践为导向，每天拍一张照片，主题随意，风雨无阻。 </p><p>实践是主要环节，在实践之外，我们会一起举行一系列美图赏析与评议，用于提升我们对美的鉴赏力。</p><p>一年后，我们都会是摄影高手。这是目标，也是板上钉钉的事。</p><p>之前听过一句话:<br><img src="https://static.longalong.cn/img/20230129103953.png"></p><p>生命短暂，如白驹过隙，瞬间稍纵即逝，唯有影像可以将之变成永恒。</p><p>因此，让我们提高摄影能力吧，用影像把时光定格在那一刻，让我们一切的体验、感受、情绪、美好甚至不完美都随着清脆的“咔嚓”声，化成一幅幅相片存储下来，让我们相约在生命的尽头，一起去回顾那些走过的岁月，就像在欣赏一部电影，陪伴与见证主角走过人生的一幕幕精彩瞬间，我想，那时，荧幕外的我们，定是此生无憾……</p><h4 id="其他目的"><a href="#其他目的" class="headerlink" title="其他目的"></a>其他目的</h4><ol><li>记录美好瞬间供日后回忆，比如娃娃们的成长影像</li><li>提升审美与鉴赏能力，创业、副业、独立成事必备技能，可以提前积累相关经验</li><li>照片是最小单元的“作品”，收获制作、打造作品的成功经验，说不定这个变量的引入能给人生带来变化，比如收获看待世界的新视角，比如获得一个技能，发展一个优势，比如开启副业…… </li></ol><p>爱因斯坦早早说过，人不能翻来覆去做同一类事儿，还能指望有不同的结果。</p><p>让我们折腾起来，在“玩”中“成长”～</p><p>想一起从拍照小白变身摄影达人的举个爪~</p><p>每天咔嚓一下子<br>美好生活一整年<br>幸福快乐一辈子</p><h4 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h4><ul><li><p>拍照能带来什么？</p><ul><li>用另一个视角观察这个世界，相信你一定能看到不一样的景色</li><li>生活就是体验，让你的体验、感受、情绪定格在那一刻</li><li>照片也是一门语言，就和你说话是一样的，都在表达一些东西，想要更好地传达你的信息，就要注重表达方式和技巧。删繁就简、聚焦重点是一个不错的方式</li></ul></li><li><p>拍照的心态</p><ul><li>拍照不要急，多走走多试试多想想，没有哪张好的照片是随便得来的。</li></ul></li></ul><h3 id="摄影知识学习"><a href="#摄影知识学习" class="headerlink" title="摄影知识学习"></a>摄影知识学习</h3><ul><li>知乎 <a href="https://zhuanlan.zhihu.com/p/525217185">零基础系统地学习摄影</a></li><li>知乎 <a href="https://www.zhihu.com/question/36095338">新手如何系统性地学习摄影</a></li><li>B 站 <a href="https://www.163.com/dy/article/HA3NEGKU0525ISGB.html">摄影区 up 主们</a></li></ul><h3 id="如何实践？"><a href="#如何实践？" class="headerlink" title="如何实践？"></a>如何实践？</h3><h4 id="日常实践"><a href="#日常实践" class="headerlink" title="日常实践"></a>日常实践</h4><ul><li>采用 时刻 365 计划，保持对摄影的关注，保持发现美的状态。</li><li>一个新的开始，注重仪式感。 (触发和反馈机制)</li><li>将所学融会贯通。</li><li>形成实践作品集，增强摄影反馈。</li></ul><blockquote><p>每天一张仅仅是基础，目的在于保持拍照的意识，帮助养成观察生活中美好事物的习惯。更好的状态应当是  发现美，记录美，分享美，而不在意 “今天分享的是第几张照片”，更不在意 “是否要存到第二天发”。</p></blockquote><h4 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h4><ul><li>知识检测</li><li>手把手教学、复刻临摹</li><li>评析活动</li></ul><h3 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h3><h4 id="时刻365练习成果展示"><a href="#时刻365练习成果展示" class="headerlink" title="时刻365练习成果展示"></a>时刻365练习成果展示</h4><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><ul><li>当前姑且用手机做存储，之后可以尝试家庭媒体系统。</li></ul><h5 id="宣发方式"><a href="#宣发方式" class="headerlink" title="宣发方式"></a>宣发方式</h5><ul><li>每日社交平台分发 (目前采用 微博 的方式)<ul><li><a href="https://s.weibo.com/weibo?q=%23%E6%97%B6%E5%88%BB365%23">查看微博</a></li></ul></li><li>周期聚合成集 (图集、小视频等)</li></ul><h4 id="摄影作品化展示"><a href="#摄影作品化展示" class="headerlink" title="摄影作品化展示"></a>摄影作品化展示</h4><h5 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h5><h5 id="宣发方式-1"><a href="#宣发方式-1" class="headerlink" title="宣发方式"></a>宣发方式</h5><h3 id="搞清楚如何学好摄影"><a href="#搞清楚如何学好摄影" class="headerlink" title="搞清楚如何学好摄影"></a>搞清楚如何学好摄影</h3><p>学一个东西，就把它学好，而且要尽量用最高效的方式学好。既然你已经有了最高效学好一个东西的方法，那就把它变成一套体系，让别人也能高效地学好。</p><ul><li><a href="/notpublish/index.html" name="以案例分析和练习为主的学习方法论" >以案例分析和练习为主的学习方法论</a></li></ul><h3 id="其他思考-1"><a href="#其他思考-1" class="headerlink" title="其他思考"></a>其他思考</h3><ul><li><p>我们一直在强调 作品思维 的重要性，那么，对于教育而言，是否意味着让受教育对象拥有这些重要的思维呢？</p></li><li><p>这个活动的潜在价值有哪些？</p><ul><li>让人更加关注美、关注生活中的细节，热爱生命，享受生活</li><li>增加人的幸福感</li><li>提升人的审美能力、摄影能力</li><li>让人进入 独处 的状态，感受 “自我的存在”</li><li>实践 “留下印记”，埋下 “作品思维” 的种子，埋下 “测量成功” 的种子</li><li>实践 “坚持”，为构建 “坚持终将会有收获” 提供成功经验</li><li>实践 “习惯养成”，为回答 “如何坚持一件事” 提供经验支撑</li><li>实践 “学习”，为构建 “技能学习方法论” 提供经验支撑</li></ul></li></ul><h3 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h3><ul><li><a href="/notpublish/index.html" name="摄影修炼计划" >摄影修炼计划</a></li><li><a href="/notpublish/index.html" name="以案例分析和练习为主的学习方法论" >以案例分析和练习为主的学习方法论</a></li></ul><hr><blockquote><p>Happiness can exist only in acceptance.<br>— <cite>George Orwell</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>摄影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牙签牛肉怎么做？</title>
    <link href="/longblog/posts/23_01_18_16_55_how_to_cook_yaqian_niurou.html"/>
    <url>/longblog/posts/23_01_18_16_55_how_to_cook_yaqian_niurou.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在准备年夜饭的菜单，想做点跟往常不大一样的，好玩又好看的那种。一番浏览下来，看上了牙签牛肉。 趁着还有一段时间才过年，赶紧尝试一番。</p><p><img src="https://static.longalong.cn/img/20230130225840.png"></p><h2 id="食材准备"><a href="#食材准备" class="headerlink" title="食材准备"></a>食材准备</h2><h3 id="所需食材"><a href="#所需食材" class="headerlink" title="所需食材"></a>所需食材</h3><p>主/辅料： 牛里脊肉半斤</p><p>配/调料： 盐、鸡精、生抽、少许老抽、辣椒面、白芝麻、孜然粉、孜然粒、干辣椒、五香粉、玉米淀粉、小葱、生姜、蒜蓉、花椒</p><p><img src="https://static.longalong.cn/img/20230130225813.png"></p><h3 id="食材处理"><a href="#食材处理" class="headerlink" title="食材处理"></a>食材处理</h3><ul><li>牛肉：切粗丝 或者 切薄片。加入盐、鸡精……所有调味料进行腌制，加入少许水，让牛肉充分吸收，加入少许玉米淀粉锁水，腌制 4 小时及以上。</li><li>用牙签将牛肉串好。</li></ul><p><img src="https://static.longalong.cn/img/20230130225905.png"></p><h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><p><img src="https://static.longalong.cn/img/20230130225925.png"></p><p><img src="https://static.longalong.cn/img/20230130225947.png"></p><ul><li>锅中下油，4 成热，加入花椒、干辣椒、姜，炒香。</li><li>滤起所有香料。</li><li>油烧热，倒入腌好的牛肉，快速翻炒，变色即转小火。</li><li>倒入香料，撒上辣椒面、白芝麻、孜然、葱花。</li><li>翻拌均匀，出锅装盘。</li><li>拍照，开始！！</li></ul><h2 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h2><p><img src="https://static.longalong.cn/img/20230130230002.png"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>牛肉一定要变色即停火！</li></ul><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><ul><li><a href="/longblog/posts/23_01_09_13_44_how_to_cook_jichi_baofan.html" name="鸡翅包饭怎么做？" >鸡翅包饭怎么做？</a></li><li><a href="/longblog/posts/23_01_18_16_37_how_to_cook_huangguyu_dun_doufu.html" name="黄骨鱼炖豆腐怎么做？" >黄骨鱼炖豆腐怎么做？</a></li></ul><hr><blockquote><p>A jug fills drop by drop.<br>— <cite>Buddha</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>美食</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黄骨鱼炖豆腐怎么做？</title>
    <link href="/longblog/posts/23_01_18_16_37_how_to_cook_huangguyu_dun_doufu.html"/>
    <url>/longblog/posts/23_01_18_16_37_how_to_cook_huangguyu_dun_doufu.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在准备年夜饭的菜单，想做点跟往常不大一样的，好玩又好看的那种。一番浏览下来，看上了黄骨鱼炖豆腐。 趁着还有一段时间才过年，赶紧尝试一番。</p><h2 id="食材准备"><a href="#食材准备" class="headerlink" title="食材准备"></a>食材准备</h2><h3 id="所需食材"><a href="#所需食材" class="headerlink" title="所需食材"></a>所需食材</h3><p><img src="https://static.longalong.cn/img/20230130230038.png"></p><p>主/辅料：黄骨鱼 3 只 (1斤半左右)、南豆腐 2 斤左右</p><p>配/调料： 盐、鸡精、生抽、料酒、小葱、大葱、生姜、花椒、红甜椒</p><h3 id="食材处理"><a href="#食材处理" class="headerlink" title="食材处理"></a>食材处理</h3><p><img src="https://static.longalong.cn/img/20230130230103.png"></p><ul><li>黄骨鱼：洗干净就行了</li><li>豆腐：切厚片 (块也行)</li></ul><h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><ul><li>锅中下油，烧至 7 成热，下入黄骨鱼，中小火煎一下，煎出黄油即可</li><li>下入姜片、少许花椒、大葱</li><li>倒入清水，没过黄骨鱼，开大火煮开</li><li>倒入料酒，加入盐、鸡精、生抽</li><li>加入豆腐，中小火煮 5-10 分钟</li><li>待豆腐入味，起锅，加入红甜椒、小葱</li><li>拍照，开吃</li></ul><h2 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h2><p><img src="https://static.longalong.cn/img/20230130230119.png"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>倒入清水煮鱼的时候要开大火煮 3-5 分钟左右，让汤变浓白。</li></ul><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><ul><li><a href="/longblog/posts/23_01_09_13_44_how_to_cook_jichi_baofan.html" name="鸡翅包饭怎么做？" >鸡翅包饭怎么做？</a></li><li><a href="/longblog/posts/23_01_18_16_55_how_to_cook_yaqian_niurou.html" name="牙签牛肉怎么做？" >牙签牛肉怎么做？</a></li></ul><hr><blockquote><p>Of course there is no formula for success except perhaps an unconditional acceptance of life and what it brings.<br>— <cite>Arthur Rubinstein</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>美食</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-基于创造性活动的价值追求</title>
    <link href="/longblog/posts/23_01_18_10_55_value_based_on_creation.html"/>
    <url>/longblog/posts/23_01_18_10_55_value_based_on_creation.html</url>
    
    <content type="html"><![CDATA[<h2 id="主体逻辑"><a href="#主体逻辑" class="headerlink" title="主体逻辑"></a>主体逻辑</h2><ul><li><p>人是物质的，因此人需要物质文明；人是意义的，因此人要有精神文明的支撑。</p></li><li><p>目前社会的运行体系，仍处在以价值交换为主要方式的阶段。</p></li><li><p>人是社会性动物，在几乎所有物质需求 和 部分精神追求中，都需要通过以财富为衡量物的价值交换来实现。</p></li><li><p>对大多数人而言，财富的累积需要通过 价值创造 和 价值交换 实现。</p></li><li><p>价值创造 来源于 创造性活动，创造性活动的效率取决于创造力。</p></li><li><p>创造力来源于 思考力的解放 和 行动力的解放，思考力来源于认知资源的释放</p><ul><li>提升行动力的原则有：明确目标、理清路径、去除不对的惯性行为、养成对的惯性行为</li></ul></li><li><p>劳动创造人，劳动使人快乐 =&gt; 对现阶段的意义 和 对长期的意义</p></li><li><p>创造性活动的产出品 – 创造物，要以 作品 的形式呈现，因为作品是价值评估的基础单元</p></li><li><p>创造性活动 要以人的精力和其他资源作为原材料，但人的精力和资源是有限的，用战略眼光制定战略目标，聚焦到最重要的事物上才能将价值最大化</p></li><li><p>系统性的作品能产生协同效应，系统性的创造性活动能降低基础资源的投入成本。</p></li></ul><ul><li><p>归纳创造性活动的三个阶段： 价值发现，价值实现，价值扩大</p></li><li><p>从价值创造方式的纬度看，世上有两种角色，价值实现者 和 效能提升者 (管理者、工具生产者、教育者)</p></li></ul><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><ol><li>创造性活动的过程 =&gt; 把你当前正在投入的事情，扩大影响力，成为一个作品 的流程体系。</li><li>人思想的通透，来源于我执，来源于一套理论体系的成熟</li><li>从外在看，我们终其一生都在打造自己的名片，而这些名片都是由一件件我们的作品所定义，作品，是我们做创造性活动的产出物。所以，我们终其一生都要做创造性活动，既然如此，认清现实，把这件事做好，做到极致。</li></ol><hr><blockquote><p>It’s just a job. Grass grows, birds fly, waves pound the sand. I beat people up.<br>— <cite>Muhammad Ali</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>价值</tag>
      
      <tag>value</tag>
      
      <tag>创造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用webmin管理机器</title>
    <link href="/longblog/posts/23_01_13_16_51_use_webmin_for_linux_management.html"/>
    <url>/longblog/posts/23_01_13_16_51_use_webmin_for_linux_management.html</url>
    
    <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>项目地址： <a href="https://github.com/webmin/webmin/blob/master/README-zh.md#%E6%96%87%E6%A1%A3">github 地址</a><br>参考文档： <a href="https://www.zhihu.com/tardis/bd/art/572357999">https://www.zhihu.com/tardis/bd/art/572357999</a><br>官方文档： <a href="https://webmin.com/docs/intro/">https://webmin.com/docs/intro/</a></p><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p>这是一个面向 web 的 linux 系统管理工具箱，功能丰富，包括 进程管理、磁盘管理、用户管理、web terminal 等，一些复杂的操作比 命令行操作简单，可以降低认知复杂度，比如 lvm 管理等。</p><p>在管理 linux 机器时，很多领域的操作频率是非常低的，例如： lvm、raid、firewall、smb server、vpn server、ldap server 等等，而这些模块大多是通过命令行操作，长时间不用之后，每次要做点啥时，都要重新去看命令怎么使用，十分恶心。</p><p>我遇到的最恶心的场景就是 lvm ！！！涉及到存储，只能小心翼翼操作，但命令又多，还分好几步，真的是搞得提心吊胆。 而只要用这个 webmin 的工具，就能很好解决。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o setup-repos.sh https://raw.githubusercontent.com/webmin/webmin/master/setup-repos.sh<br><br>sh setup-repos.sh<br><br>apt-get install webmin<br><br><span class="hljs-comment"># 会监听 10000 端口，用浏览器打开即可，账号密码均使用系统账号</span><br>systemctl start webmin<br></code></pre></td></tr></table></figure><h2 id="想点啥"><a href="#想点啥" class="headerlink" title="想点啥"></a>想点啥</h2><p>我们开发很多工具，其目的都是降低用户在某个场景下的使用成本，从而提高生产效率。从某个维度看，开发一些产品所做的大多数事情，都是在做 “封装”，把 “一些操作” 封装成 “一个操作”，同时给各种可选项做功能说明。 </p><p>不论是 cli 的各种 args 说明，还是 ui 的布局、颜色、组件等等，都是为了让大家在使用的时候，更好地理解其含义。</p><p>这件事是有价值的。</p><p>站在这个角度，很多工具都可以通过提供 UI 的方式降低使用成本，比如： docker、k8s、fio、disk、nginx、nps、ngrok、mysql …… </p><p>实际上，这些工具大都也有 ui，只是一些平台没有 web 的版本，例如 disk、fio 之类的，想来是由于使用者仅有极少数的 linux 运维人员，因此必要性会大打折扣。 </p><blockquote><p>找到一篇 linux 管理的 <a href="https://www.how2shout.com/tools/ubuntu-server-web-gui.html">web gui 的文章</a>，比较推荐： <a href="https://webmin.com/docs/intro/">webmin</a>、<a href="https://cockpit-project.org/">Cockpit</a>、<a href="https://www.bt.cn/">bt panel</a> 、<a href="https://github.com/ajenti/ajenti">ajenti</a></p></blockquote><h2 id="有搞头的"><a href="#有搞头的" class="headerlink" title="有搞头的"></a>有搞头的</h2><p>fio 的 web gui，用来一键得到一些磁盘的性能信息。目前还没太大需求，以后有需求的时候看能不能顺便搞了吧</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>nginx web ui: </p><ul><li><a href="https://github.com/0xJacky/nginx-ui">https://github.com/0xJacky/nginx-ui</a></li><li><a href="https://github.com/cym1102/nginxWebUI">https://github.com/cym1102/nginxWebUI</a></li></ul><p>iptables web ui:</p><ul><li><a href="https://github.com/chaifeng/ufw-docker">https://github.com/chaifeng/ufw-docker</a></li><li><a href="https://github.com/Nudin/iptable_vis">https://github.com/Nudin/iptable_vis</a> (iptables 链路可视化)</li></ul><hr><blockquote><p>Lord, make me an instrument of thy peace. Where there is hatred, let me sow love.<br>— <cite>Francis of Assisi</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>webmin</tag>
      
      <tag>management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-shell练习标准和考核方式</title>
    <link href="/longblog/posts/23_01_11_11_16_shell_practice_and_examination.html"/>
    <url>/longblog/posts/23_01_11_11_16_shell_practice_and_examination.html</url>
    
    <content type="html"><![CDATA[<p>目标： 为了让 shell 学习能够有质量保证，需要采用 <code>实践练习</code> 和 <code>考核检测</code> 这两种方式。</p><p>一套标准式的 shell 学习方案。</p><ul><li>shell 的参数解析<ul><li>getopt 的用法</li></ul></li><li>shell 的命令提示</li><li>shell 的文件处理<ul><li>文件操作符</li><li>文件子命令 (mkdir、touch、chmod、ls、rm、mv、cp、tar、gzip)</li></ul></li><li>shell 的文本处理<ul><li>字符串处理</li><li>文本子命令 (grep、awk、sed、head、tail)</li></ul></li><li>shell 的日志处理<ul><li>多日志输出 (输出符、管道、tee)</li></ul></li><li>shell 的函数封装 (常用 util?)</li><li>shell 的交互式处理<ul><li>read</li></ul></li><li>shell 的案例分析</li></ul><p>linux基础的考核标准</p><ul><li>network<ul><li>网络配置与状态 (netstat、ss、iptables、ipvsadm、ip、route)</li><li>网络抓包 (tcpdump、nc、wireshark)</li><li>性能测试 (iperf)</li></ul></li><li>process<ul><li>进程管理 (top、kill、glances、ps)</li><li>进程资源 (/proc、lsof)</li><li>namespace</li></ul></li><li>disk<ul><li>挂载、分区、备份、恢复 (mount、lsblk、fdisk、mkfs、lvm、nfs、fstab)</li><li>性能测试 (iotop、dd、iofs)</li></ul></li><li>crontab<ul><li>执行、日志、检测</li></ul></li><li>service<ul><li>systemctl</li><li>init</li><li>dmsg</li></ul></li></ul><p>参考文档：</p><ul><li><a href="/longblog/posts/22_11_23_01_26_batch_job_tools.html#shell" name="批任务处理工具" >批任务处理工具</a></li><li><a href="/longblog/posts/23_01_10_14_05_some_normal_linux_cmds.html" name="一些常用的linux命令记录" >一些常用的linux命令记录</a></li><li><a href="/longblog/posts/21_12_02_operation_of_raid_with_lvm.html" name="使用lvm实现raid能力" >使用lvm实现raid能力</a></li></ul><hr><blockquote><p>It’s better to be a lion for a day than a sheep all your life.<br>— <cite>Elizabeth Kenny</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>bash</tag>
      
      <tag>terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些常用的linux命令记录</title>
    <link href="/longblog/posts/23_01_10_14_05_some_normal_linux_cmds.html"/>
    <url>/longblog/posts/23_01_10_14_05_some_normal_linux_cmds.html</url>
    
    <content type="html"><![CDATA[<h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><ul><li>拷贝文件  <code>dd if=infile of=outfile</code></li><li>创建填充文件  <code>dd if=/dev/zero of=xxx bs=1024000 count=100</code> (100 MB)</li><li>备份磁盘 <code>dd if=/dev/sda of=/dev/sdb</code></li><li>备份磁盘到文件  <code>dd if=/dev/sda of=/path/to/filename</code>，恢复备份 <code>dd if=/path/to/filename of=/dev/sda</code></li><li>拷贝内存内容到硬盘 <code>dd if=/dev/mem of=/path/to/filename.mem bs=1024</code></li><li>销毁磁盘 <code>dd if=/dev/urandom of=/dev/sdb</code></li></ul><p>更详细的信息可以参考 <a href="https://www.runoob.com/linux/linux-comm-dd.html">菜鸟</a></p><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>给 scp 加代理，方法和 ssh 一样： <code>scp -o &quot;ProxyCommand=nc -X 5 -x localhost:1080 %h %p&quot;  remotehost:~/xx ./xx</code></p><h2 id="nc-ncat"><a href="#nc-ncat" class="headerlink" title="nc (ncat)"></a>nc (ncat)</h2><ul><li>nc 可以监听 udp 端口， <code>nc -luv 60001</code> ，也可以连接 udp  <code>nc -vu 46.46.46.46 60001</code></li><li>通过 nc 发送文本消息， <code>echo xxx | nc 46.46.46.46 1234</code></li><li>nc 调试 http server   <code>nc -lkp 50081 -c &quot;nc 127.0.0.1 50080&quot; -o /dev/stdout</code>   但输出没有展示方向，看起来不太友好。<ul><li><code>nc -kl 1234 -c &#39;tee -a xxin.txt - | nc 127.0.0.1 50080 | tee xxout.txt -a -&#39;</code></li><li>查看 <code>tail -f xxin.txt</code>  和 <code>tail -f xxout.txt</code></li><li><input disabled="" type="checkbox"> 调试内容显示可以更加优化，加个中间件</li></ul></li><li>nc 请求复制  ( 结合 <a href="https://github.com/session-replay-tools/tcpcopy">tcpcopy</a> )</li><li>nc 作为 http 代理 server <code>nc -kl --proxy-type http 0.0.0.0 8888</code><ul><li>socks5 server 可以参考 <a href="https://github.com/armon/go-socks5">go-socks5</a></li><li>socks5 server 可以参考 <a href="https://github.com/serjs/socks5-server">socks5-server</a></li><li>基于 nps 的 socks5 搭建工具可以参考 <a href="https://github.com/wyx176/nps-socks5">nps-socks5</a></li></ul></li><li>nc 直接 <a href="https://github.com/jaburns/ngincat">serve files</a>:   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span>|grep :;<span class="hljs-keyword">do</span> :;<span class="hljs-keyword">done</span>;&lt;a href=<span class="hljs-string">&quot;/notpublish/index.html&quot;</span> name=<span class="hljs-string">&quot; -e .<span class="hljs-variable">$g</span> &amp;&amp;! <span class="hljs-variable">$g</span> = *..* &quot;</span> &gt; -e .<span class="hljs-variable">$g</span> &amp;&amp;! <span class="hljs-variable">$g</span> = *..* &lt;/a&gt;||<span class="hljs-built_in">exit</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\nContent-Length: <span class="hljs-subst">$(stat -c%s .$g)</span>\n\n&quot;</span><br>cat .<span class="hljs-variable">$g</span>)|nc -l -p <span class="hljs-variable">$1</span>;&#125;&gt;/dev/fd/0;<span class="hljs-variable">$0</span> <span class="hljs-variable">$1</span><br></code></pre></td></tr></table></figure></li><li>nc 端口扫描  <code>nc -w 1 -z [ip] [port]</code> </li><li>nc 聊天消息 <code>nc --chat -lkp 50081</code><ul><li>nc 带认证聊天 (回头再看)</li></ul></li><li>nc 调试 server，延迟 1s 收发  <code>nc -lkp 50081 -d 1</code></li><li>nc 让一切命令行拥有 proxy 的能力 (回头再看)</li><li>nc 视频流媒体 ( 在树莓派上可以玩一下 )</li><li>nc 传输文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 传输文件 (可以有两种，服务端收、服务端发)，下面案例是 服务端发</span><br>nc -l 1234 &lt; file_receive <span class="hljs-comment"># 发送方</span><br>nc 46.46.46.46 1234 &gt; file_send <span class="hljs-comment"># 接收方</span><br><br><span class="hljs-comment"># 传输文件夹 (服务端收)</span><br>nc -l 1234 | tar zxf - <span class="hljs-comment"># 接收方</span><br>tar zcf - files_send | nc 46.46.46.46 1234 <span class="hljs-comment"># 发送方</span><br><br><span class="hljs-comment"># 加密证书传输文件 (服务端收)</span><br>nc -l 1234  --ssl --ssl-cert xxxxxx &gt; file_receive  <span class="hljs-comment"># 接收方</span><br>nc --ssl --ssl-cert xxxxxx &lt; file_send  <span class="hljs-comment"># 发送方</span><br><br><span class="hljs-comment"># 加密密码传输文件夹 -- 是的，很丑……，可以用 tar ，虽然没有好看多少……</span><br>nc -l 1234 -c <span class="hljs-string">&#x27;dd of=/tmp/xxreceive.zip&#x27;</span> &amp;&amp;  unzip -P password /tmp/xxreceive.zip || rm -f /tmp/xxreceive.zip  <span class="hljs-comment"># 接收方</span><br><br>zip -rP password /tmp/xxsend.zip axel-2.17.5 &amp;&amp; nc 127.0.0.1 1234 &lt; /tmp/xxsend.zip || rm -f /tmp/xxsend.zip  <span class="hljs-comment"># 发送方</span><br><br></code></pre></td></tr></table></figure><blockquote><p>关于加密部分的玩法，可以参考 <a href="/longblog/posts/22_10_18_21_19_useful_tools_of_encryption.html" name="简单好用的加解密工具" >简单好用的加解密工具</a></p></blockquote><blockquote><p>nc 只能扫描某一个 ip 下的端口，如果想扫描某个网段，可以使用 nmap，eg: nmap -v -T4 172.20.0.1/16</p></blockquote><ul><li><a href="/longblog/posts/21_12_11_reverse_proxy_compares.html#nc" name="反穿技术哪家强" >反穿技术哪家强</a></li></ul><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>ls 进行时间排序，可以使用 <code>ls -t</code>，时间反向排序，可以使用 <code>ls -tr</code>，也可以使用 sort 进行排序 <code>ls -l | sort -k 8 -n</code>  </p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><ul><li>用任意代理 <code>curl --proxy xx://xxx.xx.x.xx:xxxx</code></li></ul><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul><li>根据文件名搜索  <code>find ./* -name xxxx</code></li><li>根据文件名模糊匹配  <code>find ./* -name &#39;*hello*&#39;</code></li><li>查找最近 n 天修改过的文件 <code>find -ltime/mtime/atime</code></li><li>查找具体某天的文件 <code>find ./* -newermt &#39;2023-01-13&#39; ! -newermt &#39;2023-01-14&#39;</code></li><li>找出 3 天”以前”被改动过的文件 72小时之前: <code>find /var/log/ -mtime +3 -type f -print</code></li><li>找出 3 天內被改动过的文件 (0 ~ 72 小时內): <code>find /var/log/ -mtime -3 -type f -print</code></li><li>找出前第 3 天被改动过的文件 (72 ~ 96 小时): <code>find /var/log/ -mtime 3 -type f -print</code></li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><ul><li>排除一些文件 <code>grep -v xxx</code></li></ul><h2 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h2><ul><li>shell 对数据结构的处理真的是一言难尽，json 尤其如此</li><li>jq 可以用来提取 json  <code>curl http://xx.com/xx | jq .data</code> 或者 <code>jq .data xxx.json</code></li><li>eg:  long.json<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;longalong&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">&quot;friends&quot;</span>: [<br>    <span class="hljs-string">&quot;long1&quot;</span>,<br>    <span class="hljs-string">&quot;long2&quot;</span>,<br>    <span class="hljs-string">&quot;long3&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>获取 name :  <code>jq .name long.json</code></li><li>过滤 数组:  <code>jq &#39;.friends[] | select(. == &quot;long1&quot;)&#39;</code></li><li>把多个 json 合成为一个数组:  <code>jq -s &#39;.&#39; xx.json xx1.json</code></li><li>在使用 curl 时，json 的 data 很难处理，如果有一个长文本，这个长文本的格式有很多奇奇怪怪的东西 (比如 ‘ “ <code>\n</code> 这些)，在拼接 data 的时候就可以使用:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">JSON_STRING=$(jq -n --arg description <span class="hljs-string">&quot;<span class="hljs-subst">$(cat <span class="hljs-string">&quot;new_release_desc_with_checksum.txt&quot;</span>)</span>&quot;</span> <span class="hljs-string">&#x27;&#123;&quot;description&quot;:$description&#125;&#x27;</span>)<br><br>curl -XPUT  -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> https://xx.xx.com -d <span class="hljs-string">&quot;<span class="hljs-variable">$JSON_STRING</span>&quot;</span><br></code></pre></td></tr></table></figure></li><li>嗯，上面的方式真的贼拉好用</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="/longblog/posts/22_11_23_01_26_batch_job_tools.html" name="批任务处理工具" >批任务处理工具</a></li><li><a href="/longblog/posts/22_10_18_21_19_useful_tools_of_encryption.html" name="简单好用的加解密工具" >简单好用的加解密工具</a></li><li><a href="/longblog/posts/22_07_18_17_46_some_records_of_tcpdump_for_grab_net_packages.html" name="tcpdump" >tcpdump</a></li><li><a href="/notpublish/index.html" name="如何把命令行玩花？" >如何把命令行玩花？</a></li><li>直接在当前 git repo 下打开仓库页面 <code>git config --get remote.origin.url | sed &#39;s/git@//;s/:/\//;s/\.git$//;s|^|https://|&#39; | xargs -I &#123;&#125; open &#123;&#125;</code></li></ul><hr><blockquote><p>I know but one freedom and that is the freedom of the mind.<br>— <cite>Antoine de Saint-Exupéry</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>scp</tag>
      
      <tag>dd</tag>
      
      <tag>ls</tag>
      
      <tag>sort</tag>
      
      <tag>ncat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸡翅包饭怎么做？</title>
    <link href="/longblog/posts/23_01_09_13_44_how_to_cook_jichi_baofan.html"/>
    <url>/longblog/posts/23_01_09_13_44_how_to_cook_jichi_baofan.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在准备年夜饭的菜单，想做点跟往常不大一样的，好玩又好看的那种。一番浏览下来，看上了鸡翅包饭。 趁着还有一段时间才过年，赶紧尝试一番。</p><h2 id="食材准备"><a href="#食材准备" class="headerlink" title="食材准备"></a>食材准备</h2><h3 id="所需食材"><a href="#所需食材" class="headerlink" title="所需食材"></a>所需食材</h3><p>主/辅料： 鸡翅 (全翅)、米饭(可混糯米)、胡萝卜、洋葱、甜玉米粒、青豆、火腿肠</p><blockquote><p>没买到鸡全翅，就姑且用中翅代替吧……</p></blockquote><p>配/调料： 奥尔良腌料、小葱、蚝油、蜂蜜……</p><p><img src="https://static.longalong.cn/img/20230130225324.png"></p><h3 id="食材处理"><a href="#食材处理" class="headerlink" title="食材处理"></a>食材处理</h3><ul><li>鸡翅： 剔除骨头，用奥尔良腌料腌上。 (这一步很艰难，12个鸡翅剪了至少半小时)</li><li>胡萝卜、洋葱、火腿肠： 切小粒 (量不需要多，甚至最好少点，不能像平常炒饭那样)</li><li>米饭：蒸熟后凉冷</li><li>蜂蜜：加入少许水和匀</li></ul><p><img src="https://static.longalong.cn/img/20230130225351.png"></p><h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><ul><li>锅中下油，倒入火腿、胡萝卜、洋葱、玉米、青豆 炒熟，加入盐、鸡精、白胡椒粉、少许耗油。</li><li>加入米饭，拌匀。</li><li>将炒饭晾冷。</li><li>把米饭塞进鸡翅中，用牙签封口。</li></ul><p><img src="https://static.longalong.cn/img/20230130225528.png"></p><p><img src="https://static.longalong.cn/img/20230130225625.png"></p><ul><li>将包好米饭的鸡翅放入烤箱，上下火 200°C，15分钟。</li><li>上下刷蜂蜜水。</li><li>180°C 继续烤 10分钟。</li><li>出炉，拍照！</li></ul><p><img src="https://static.longalong.cn/img/20230130225701.png"></p><h2 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h2><p><img src="https://static.longalong.cn/img/20230130225714.png"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>可以买现成的鸡翅包饭，回家一热完事儿……</li></ul><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><ul><li><a href="/longblog/posts/23_01_18_16_55_how_to_cook_yaqian_niurou.html" name="牙签牛肉怎么做？" >牙签牛肉怎么做？</a></li><li><a href="/longblog/posts/23_01_18_16_37_how_to_cook_huangguyu_dun_doufu.html" name="黄骨鱼炖豆腐怎么做？" >黄骨鱼炖豆腐怎么做？</a></li></ul><hr><blockquote><p>Love is the wisdom of the fool and the folly of the wise.<br>— <cite>Samuel Johnson</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>美食</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用流程制度驱动人以适应改变</title>
    <link href="/longblog/posts/2301091220.html"/>
    <url>/longblog/posts/2301091220.html</url>
    
    <content type="html"><![CDATA[<p>爱因斯坦说 “不能翻来覆去做同一件事儿，却期待能有不同的结果。”</p><p>要让现状有所改变，就要用行动去做不同的事。</p><p>做不同的事，挡在眼前的是以往的习惯。</p><p>习惯会让我们的 注意力、思维方式、行动方式 停留在以往的流程中，因此我们才会需要 “刻意” 去扭转我们的思维和行动方式。</p><p>人的认知资源都是有限的。</p><p>这样的 “刻意” 会非常消耗我们的认知资源。</p><p>我们想做一件不一样的事、做出一些改变的时候，阻碍甚至导致我们失败的，往往就是 流程不清楚、流程不清晰、流程不熟练 导致的 心力用尽 (认知资源耗尽)。</p><p>缓解这个问题的一个方式是： 建立流程制度，降低认知压力，释放认知资源。</p><p>然后建立任务管理机制，保证顺利进入到流程制度中 (触发机制、过程管理、反馈管理) 。</p><p>比如：</p><p>我们想在美食上有所进展。<br>我们就必须做出一些和现在不一样的事情，因为爱因斯坦说过 “不能xxx”。<br>我们不知道该怎么做，不知怎么产生目标、怎么实践目标，也就是，我们不知道从哪里获取要做的美食、我们不知道怎么去做这些美食 (什么时候、怎么行动)。</p><p>即使我们在脑海中做了一个简单的方案，决定  每周末都研究一道菜，然后要拍做菜的记录。</p><p>然而现实也会出现这两个问题： ① 无法保证周末会记起这件事  ② 周末到了也不知道该怎么操作  ③ 完全不知道该怎么拍做菜的记录，甚至忘了要拍……</p><p>如果，<br>我们先制定了一套标准的操作流程，可以指引我们每一步的行动，比如，① 通过在下厨房搜索”年夜饭”寻找目标美食  ② 分析美食制作流程并形成分析文档  ③ 确定食材，并购买食材  ④ 准备手机支架、补光灯、场景  ⑤ ……  ⑥ 美食记录分享到 blog ……</p><p>然后，在 任务管理 中添加 本周六 的做美食任务。</p><p>通过以上流程，就能对我们想做的这个改变有了更大概率进行下去。</p><p>我之前一直有种行为的倾向，当产生一些兴趣和小点子时，只想依据在脑海中产生的较混乱的想法去驱动自己的行为。大多数时候，这些点子都随着下一秒时间的到来而飞走了。也有很多是在执行过程中被心智负担所压垮，然后开始闪躲和逃避。</p><p>之后，我会更加关注这个问题，把自己想做的事先变成制度和流程，然后用项目管理机制进行管理，以真正发挥自己的创造力和价值。</p><p>其他思考：</p><ul><li>不能仅依靠临时的创造力临场发挥，真正的作品都是经过多次雕琢的</li></ul><hr><blockquote><p>Your friends will know you better in the first minute you meet than your acquaintances will know you in a thousand years.<br>— <cite>Richard Bach</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>改变</tag>
      
      <tag>习惯</tag>
      
      <tag>流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-金手指计划总论</title>
    <link href="/longblog/posts/23_01_07_12_05_gold_finger.html"/>
    <url>/longblog/posts/23_01_07_12_05_gold_finger.html</url>
    
    <content type="html"><![CDATA[<p>什么是金手指？<br>一套以 ”持续进步“ 为核心目标的 学习和实践框架及方法论。</p><p>基本指导思想：<br>元思考方法。<br>长期价值主义者。<br>做时间的朋友。<br>底层能力赋能。<br>磨刀不误砍柴工。<br>人们容易高估一年能做的事，也总是低估十年能做的事。<br>杠杆思维。</p><p>哪些是金手指？</p><ol><li>理论学习方法论</li><li>技能学习方法论</li><li>成长型思维 (持续进步思维 + 反思与复盘思维 + DRY思维)</li><li>习惯养成方法论</li><li>具体的行动框架 (计划、实施、反馈)</li><li>自我教育与他人教育理论</li><li>创造性活动方法路 <a href="/longblog/posts/23_01_18_10_55_value_based_on_creation.html" name="WIP-基于创造性活动的价值追求" >WIP-基于创造性活动的价值追求</a></li><li>……</li></ol><p>如何促使拥有这些金手指？</p><ol><li>通过元思考，获得什么是金手指 (更高层级、更原理性的、更本质的) (第一性原理)</li><li><a href="/longblog/posts/2301091220.html" name="用流程制度驱动人以适应改变" >用流程制度驱动人以适应改变</a></li><li>大量实践</li></ol><p>文档直通车：</p><ul><li><a href="/notpublish/index.html" name="以案例分析和练习为主的学习方法论" >以案例分析和练习为主的学习方法论</a></li><li><a href="/longblog/posts/23_01_31_13_25_the_way_to_build_habit.html" name="习惯的养成方法论" >习惯的养成方法论</a></li><li><a href="/longblog/posts/23_02_01_08_22_what_is_change.html" name="WIP-改变意味着什么？" >WIP-改变意味着什么？</a></li><li><a href="/notpublish/index.html" name="什么是作品思维？" >什么是作品思维？</a></li></ul><hr><blockquote><p>Change your life today. Don’t gamble on the future, act now, without delay.<br>— <cite>Simone de Beauvoir</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>金手指</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-慢就是快</title>
    <link href="/longblog/posts/23_01_07_12_08_slow_is_fast.html"/>
    <url>/longblog/posts/23_01_07_12_08_slow_is_fast.html</url>
    
    <content type="html"><![CDATA[<p>当我们确定了一个目标之后，尤其是确定了一个任务之后，很容易走上 “为了完成任务而完成任务” 的道路。加上在这个快节奏的工作环境下，大家更是强调 “快速”、”高效”，因此很喜欢用 “能被快速衡量的任务” 来定义自己的价值。</p><p>这种现象容易忽略 更高层级的系统性价值 所带来的价值。</p><p>以读书为例。当我们因为一些原因拿起了一本书之后，就会去计算 <code>投入产出比</code>，想看看自己得到了什么价值，那么，用什么去衡量自己这段时间收获的价值呢？ 似乎 “读了多少页”、”读了这本书的多少” 这种简单易见的事实很容易被衡量，于是给自己下了个结论： 我用 3 个小时读了这本书的 1/3，这是我这个晚上产生的价值。</p><p>你会发现，当你用 读了多少页 这种方式去衡量你的阅读收益时，你已经有意无意开始忽略书中的一些关键点了，因为你不希望因为停下来理清这些疑问而耽误了你 “读了多少页” 这个目标。</p><ul><li>写作，梳理、打磨、观摩对比 才是关键，而不是写了多少篇。</li><li>美食，实验、练习、熟练每个环节 才是关键，而不是做了多少种。</li></ul><p>难点在哪？太想简单快速地证明自己的收获，太想得到激励。但现实却是，最开始就是最难的。</p><p>延迟满足，你将获得更好的。</p><p>认识客观规律<br>超越困难<br>跨过去，你将看到一个不一样的世界</p><p>在一些问题上，把一件事做好，比做完多件事更有价值。得从长期来看，你认为这些事的价值。</p><p>当然，不是每件事都一样，事也分轻重缓急，真有紧急的事，你只能尽可能做得更好，但始终会存在底线。</p><p>公司中，往往存在着这样的博弈，慢点但是做好，快点但无法保证质量。互联网公司中，尤其是越基层，越是短期价值主义者，希望快点拿出一些能让人看到的结果，中期来看只要过得去就行，很少去在意长期价值。说起来理由来，永远有一个无法反驳的理由: 这个优先级不高，有更高优的事。</p><p>这既是自己和自己的博弈，有时候也是团队和个人的博弈，有事甚至会是团队和公司的博弈。</p><p>做好，现在花的时间多了，但长远看，反复调整的时间就少了，价值反而更大。</p><p>杠杆思维<br>长期价值主义</p><p>成年人，需要认清客观规律，而非盲从社会风潮的波澜。</p><p>文档直通车：<br><a href="/longblog/posts/23_01_07_12_05_gold_finger.html" name="WIP-金手指计划总论" >WIP-金手指计划总论</a><br><a href="/longblog/posts/23_02_01_08_22_what_is_change.html" name="WIP-改变意味着什么？" >WIP-改变意味着什么？</a></p><hr><blockquote><p>I can’t imagine a person becoming a success who doesn’t give this game of life everything he’s got.<br>— <cite>Walter Cronkite</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>长远价值</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本是弥勒佛，何做苦行僧</title>
    <link href="/longblog/posts/23_01_06_23_14_dont_be_pain.html"/>
    <url>/longblog/posts/23_01_06_23_14_dont_be_pain.html</url>
    
    <content type="html"><![CDATA[<ul><li><p>痛苦不是你成功的原因，选对了方向 + 持续积累才是。</p></li><li><p>你值得拥有幸福。</p></li><li><p>戒骄戒躁戒嗔。</p></li><li><p>不嫉妒不忧虑不伤心不生气。</p></li><li><p>人生来就是不平等的，不以他人比自己幸运就嫉妒或自卑，不以他人比自己不幸就嘲笑或自傲。</p></li><li><p>知足常乐。</p></li><li><p>若爱，则追求，若不爱，则远离。很多时候你没有你想象中的那么脆弱，也没有你想象中的那么经不起风浪。</p></li><li><p>听从内心的声音。</p></li><li><p>成功没有统一的标准，做到了你所在意的，就是成功。</p></li><li><p>人生短暂，光阴似箭，匆匆一瞥，已是半生。年少轻狂，以为天降大任于我，我必不负苍天。中年将近，才明白一世之所求，不过内心平静、念头通达。没准儿，天并不认识你，也或许，你就是个意外？  换个思路，也许会更加幸福。</p></li><li><p>互信互赖，如若港湾；互愤互妒，尤胜炼狱。</p></li></ul><hr><blockquote><p>You can’t win unless you learn how to lose.<br>— <cite>Kareem Abdul-Jabbar</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>思想</tag>
      
      <tag>价值观</tag>
      
      <tag>生活</tag>
      
      <tag>成功</tag>
      
      <tag>幸福</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阳明心学的探索笔记</title>
    <link href="/longblog/posts/23_01_06_10_18_learning_notes_of_mind_philosophy_by_laowang.html"/>
    <url>/longblog/posts/23_01_06_10_18_learning_notes_of_mind_philosophy_by_laowang.html</url>
    
    <content type="html"><![CDATA[<h3 id="书籍选择"><a href="#书籍选择" class="headerlink" title="书籍选择"></a>书籍选择</h3><ul><li><a href="https://book.douban.com/subject/26900530/">《王阳明与明末儒学》</a></li></ul><h3 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h3><ul><li><p>致良知，知行合一。 这是阳明心学的核心。一门哲学学说，目标在于 <code>从构建顶层逻辑来指导实践</code> (这也是对 <code>体用之体</code> 的追求)。</p></li><li><p>那么，阳明心学的指导逻辑是怎样的呢？实践，也就是 知行合一 中的 <code>行</code>，而 <code>行</code> 是由 <code>知</code> 所决定的，这个 <code>知</code> ，在王阳明的语境中，指的是 <code>良知</code> (因为阳明心学讨论的更多是道德论问题，与我们现代讨论的 知识、技能、方法 之类的不同，那个时候认为良知才是本体，而知识、技能、方法等是枝叶)。</p></li><li><p>那么，良知从何而来？阳明认为 良知天生就存在，每个人心中天生就存在一个圣人，当你不知道该怎么做时，只需要倾听内心的想法，就能找到答案。 </p></li><li><p>这种思想继承自孟子的 <code>性善论</code> (无恻隐之心，非人也；无羞恶之心，非人也；无辞让之心，非人也；无是非之心，非人也。恻隐之心，仁之端也；羞恶之心，义之端也；辞让之心，礼之端也；是非之心，智之端也。人之有是四端也，犹其有四体也。)</p></li><li><p>《三字经》总纲中也有 <code>人之初，性本善。性相近，习相远。苟不教，性乃迁</code> 的说法。 </p></li><li><p>其实，这种将一切的根本归结于 内心 的方式，和佛家的 <code>见性成佛</code> 理念是一致的。</p></li><li><p>良知虽然在每个人心中，但人们不太容易找出来，所以要求学，求学的整套体系就是在帮助你更好地倾听内心的声音。 那么怎么操作呢？有两个方面。其一，让你学习先贤对良知的解读，从而找到共鸣； 其二，教你悟道的方法论。</p></li><li><p>学习先贤对良知的解读，实际就是学习儒家所构建的 三纲五常四维八德 (三纲指君臣、父子、夫妻之间关系，五常指仁、义、礼、智、信，四维指礼、义、廉、耻，八德指孝、悌、忠、信、礼、义、廉、耻) 为基础的道德体系，更多的读物就是以儒家的 四书五经 为主、各位先贤的解读注释。</p></li><li><p>悟道的方法论中，阳明的前半生，倾向于 <code>静坐悟道</code>，但这样容易陷入 佛家和道家 类似的 <code>虚无空寂</code> 的状态，也对学生不太友好，阳明的后半生，把悟道方法放在了 <code>致良知</code> 的 <code>致</code> 上，也就是 <code>在实践中，倾听内心的想法，达到悟道的状态</code> 。</p></li><li><p>关于学习，阳明认为 学习的首要目标是 <code>立志</code>，在阳明的语境中，<code>立志</code> 指的是 <code>立成圣之志</code>。立志作为学习的首要目标我是十分认同的，在我们当前的时代背景下，我们也应当理清楚应当立什么志。</p></li></ul><h3 id="杂思杂想"><a href="#杂思杂想" class="headerlink" title="杂思杂想"></a>杂思杂想</h3><ul><li><p>所有的意义论的学说，都是为了让人能够 更加稳定地获得幸福，因此，能更好达到次目的的，就是更好的意义论学说，反之，则不是。 对于个人而言，我认为有两个重要的衡量方面： ① 与这个人的一些基本观念是否契合  ② 与这个人和环境现状是否相符 。</p></li><li><p>阳明心学推崇的 <code>事上练</code> 和我们平常说的 <code>实践出真知</code> 有相似之处，都强调 <code>实践</code>。从这个角度，阳明心学其实是一门 <code>入世</code> 学说。</p></li><li><p>阅读这本书，或者说阅读每一本书，都应当先 <code>概览其整体</code> ，然后将 <code>通读其章节</code> 与 <code>细读其关键</code> 结合进行，最后再 <code>自行论述其核心</code>，若可以，最好 <code>用文字记录认识和启发</code>。</p></li><li><p>唯心论、唯物论 和 出世或入世 关系不大，就如阳明心学而言，虽然认为一切事物的本源都源自内心，但不否认现实世界的真实存在，并且推行 知行合一 的理念，也就是 唯心论也可以入世。</p></li><li><p>关于 <code>问心</code> 的操作，在教育上确实是一个不错的方式，通过 <code>问心</code>，可以让学生产生 <code>自我对话</code> 的能力，也就拥有了 <code>自我意识</code> 和 <code>独立思考力</code>，可以认为是 <code>开启智慧大门的钥匙</code> 。</p></li><li><p>我发现书中所述的 师生关系，都是联系非常紧密的，不论是字称呼上称为 <code>恩师</code> ，还是在文章中记录的 <code>追随</code> 的行为，无一不在表达对 师生关系的重视。中国一直都有 <code>尊师重道</code> 的传统思想，甚至在祠堂的供奉中，都有 <code>天地君亲师</code> 的说法。 同样，对于教师而言，也很重视教导学生，不论是持续探索 <code>教学之本</code> 还是探索 <code>教学之方法</code>，都在于探求事物本质。前两天看罗振宇的 <a href="https://mp.weixin.qq.com/s/tWeuLAkybDTfzB0_okLiMQ">2022跨年演讲</a> 中，故事14.《绿道与眼前人》中，也有这个问题的影子(虽然他将这个的目的不是探寻师生关系的)，或许值得关注教育的人思考。</p></li><li><p>我发现流行的学说，都有 <code>著书立说，传道受业</code>  的典型行为。其实这也是 <code>作品思维</code> 和 <code>杠杆思维</code> 的一个体现吧，有 <code>作品</code> ，才能有传播的基础，同时，教授弟子，再由弟子去传道受业，才能真正做到信徒满天下。</p></li></ul><hr><blockquote><p>Truth is powerful and it prevails.<br>— <cite>Sojourner Truth</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>思想</tag>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>愿我执常伴生命旅途</title>
    <link href="/longblog/posts/23_01_05_13_22_life_with_faith.html"/>
    <url>/longblog/posts/23_01_05_13_22_life_with_faith.html</url>
    
    <content type="html"><![CDATA[<p>生命就是一场修行，无所谓你所追求的是什么，但不论你遇到了什么，请一定对自己坦诚，保持与自身澄澈的对话，用平静的心态看待所遇到的事物，只要心在路上，身边的一切都是风景。</p><p>这个世界是纷繁复杂的，充满了太多的诱惑，有时候我们可能不需要那么多的选择，我们需要的是一个选择，一个能让我们愿意持续为之付出的选择，我们愿将所有的意义都加于其上。终于，内心不再焦躁、不再割裂，我们感到充满了力量，灯在心中，再黑的路也能平静前行。</p><p>希望我们今年都能找到一个我执，逃脱世间的千万种诱惑，弱水三千只取一瓢</p><hr><blockquote><p>God made me fast. And when I run, I feel His pleasure.<br>— <cite>Eric Liddell</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>信念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目管理工具在生活中的应用</title>
    <link href="/longblog/posts/23_01_03_10_25_how_to_use_project_management_tools_in_daily_life.html"/>
    <url>/longblog/posts/23_01_03_10_25_how_to_use_project_management_tools_in_daily_life.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 <a href="/longblog/posts/23_01_01_16_23_use_okr_in_daily_life.html" name="把okr应用在生活中" >把okr应用在生活中</a> 中，我描述过，如果真的认可 okr 的价值，就可以在需要的时候，把 okr 运用到生活中。 okr 是一个目标管理工具，而目标的落地需要通过一系列 <code>TODO</code> 来实现，这也就是 <code>项目管理</code> 的范畴了。</p><p>为了能更好地支撑 okr 落地实行，我需要一套 项目管理 方案。</p><h2 id="项目管理的核心价值"><a href="#项目管理的核心价值" class="headerlink" title="项目管理的核心价值"></a>项目管理的核心价值</h2><p>项目管理，是为了在资源有限的情况下，采用一系列专门的知识、技能、工具、方法，通过对相关活动的整体监测和管控，最中保证一个或多个目标能够实现 的一个专业领域。</p><p>在互联网项目管理的背景下，目前通常采用 scrum 的方案，虽然这是一个为软件开发管理而生的一套项目管理方案，但其核心价值却有非常多可以借鉴的地方，把 scrum 的方案进行适配后运用到生活中，将会产生强大的效用。</p><p>scrum 的细节可以非常丰富且繁杂，但站在实用主义的角度，我们可以抽离出一些关键点，核心理念是 “小步快跑，不断更新”，主要概念包括：</p><ol><li>存在 <code>迭代周期</code> 的概念，每个迭代可以是 1 周 / 2 周 / 1 月，根据具体场景而定</li><li>每个迭代周期开始前，需要开迭代会，规划本迭代的具体计划，计划需要符合 SMART 原则</li><li>存在 <code>早会</code> 的概念，可以看做是 每日版的迭代周期，会议上快速沟通进展、今日计划、遇到的问题、所需的资源</li><li>每个迭代周期结束后，需要开复盘会，回顾本周期的进展、得失</li></ol><p>除了上面的执行流程外，还有一些重要的概念和工具：</p><ul><li>用户故事。迭代会做规划的依据，在生活中，可以是我们在 OKR 中确定的各类目标 (Objectives)，这些目标的背后都存在我们的需求。</li><li>product backlog。所有需要达到的目标的汇总，按照优先级进行排列。在迭代会做规划时，实际就是确认本期内要完成哪些 backlog。</li><li>sprint backlog。在迭代会时，将本期要完成的 backlog 拿出，放入到 sprint backlog 中，这就是本期要达成的目标。在每天的 早会 中，根据 该 backlog 进行沟通。</li><li>时间估计。 对每项任务要花费的时间进行预估，并确定预估的开始时间点和结束时间点。</li><li>燃耗图。 一个整体时间耗用的看板，用于判断各项任务是否健康运行。</li></ul><p>在具体的管理过程中，有一些具体的工具可以使用：</p><ul><li>wbs，工作分解结构，用于将 backlog 中的目标分解成可执行的任务，本身没啥特别的，只要穷尽进行任务拆分即可。</li><li>gatt，甘特图，用于各项任务的依赖关系、成员的资源管理、任务的时间线管理。 可以用在每日的 早会 或者一个回顾周期的回顾会上，用于保证任务的顺利进行。</li></ul><p>关于 scrum 的指导手册，可以参考:</p><ul><li><a href="https://static.longalong.cn/longfiles/2020-Scrum-Guide-Chinese-Simplified.pdf">2020-scrum-guide</a></li><li><a href="https://static.longalong.cn/longfiles/Scrum%E5%AE%9E%E6%88%98%EF%BC%9A%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BC%80%E5%8F%91.pdf">scrum实战: 敏捷软件项目管理与开发</a></li><li><a href="https://static.longalong.cn/longfiles/Scrum%E7%B2%BE%E9%AB%93_%E6%95%8F%E6%8D%B7%E8%BD%AC%E5%9E%8B%E6%8C%87%E5%8D%97_13571180.pdf">scrum精髓 敏捷转型指南</a></li></ul><h2 id="其他的诉求"><a href="#其他的诉求" class="headerlink" title="其他的诉求"></a>其他的诉求</h2><ul><li>成果管理</li></ul><p>scrum 的核心理念是 “小步快跑”，往往在执行之后，各任务产生的成果是分散在各个 sprint 中的，这对于形成整体的成果是不利的。</p><p>成果的集中性和体系性，有助于 <code>作品打造</code>、<code>构建持续的正反馈</code>，这对于 构建意义、提振信心 是有重大价值的，因此，要重新思考成果管理和 scrum 的结合。</p><ul><li>包容不稳定性</li></ul><p>在 scrum 中，大都追求 <code>更准确的时间</code>，但是在生活中，更容易出现一些 意料之外 的事，同时，由于对一些任务缺乏更深入的认识，预估的时间更不准确，因此，在生活体系下运用 scrum ，需要以更加包容的态度来处理一些情况。</p><h2 id="实际的落地方案选择"><a href="#实际的落地方案选择" class="headerlink" title="实际的落地方案选择"></a>实际的落地方案选择</h2><ul><li>okr 记录方案</li><li>backlog 记录方案</li><li>迭代周期确定</li><li>迭代会形式与内容确定</li><li>日会形式与内容确定</li><li>任务管理工具确定</li><li>成果管理工具确定</li><li>okr 复盘会形式与内容确定</li><li>迭代周期、okr 周期 管理工具</li></ul><p>【未完待续……】</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>okr 一般制定的是希望 “有特别变化” 的目标，而往往不记录日常的目标，比如 作息、打扫卫生、运动 ，但我们同样希望在上述方面有所改进，最好也把它们加入到反馈体系中。因为这些方面是比较难产生特别的 “成果” 的，因此需要把 <code>过程</code> 作为反馈的来源。</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>先做起来吧，用迭代的方式完善整个项目管理体系。</p><hr><blockquote><p>I never think of the future. It comes soon enough.<br>— <cite>Albert Einstein</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>PM</tag>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行动力是怎么练成的</title>
    <link href="/longblog/posts/23_01_02_16_58_how_to_imporve_power_of_action.html"/>
    <url>/longblog/posts/23_01_02_16_58_how_to_imporve_power_of_action.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>可能和不少同学同病相怜，我也是一个行动力不强的人，但同时，我又是一个好奇心还算强的人，脑海中经常会存在各种各样的想法，有了想法就会把想法列成计划，每隔一段时间，到了复盘前段时间的时候，却会发现很多很多的想法都停留在计划中……</p><p>我深感自己被 “行动力” 拖慢了探索这个精彩世界的节奏，甚至被 “行动力” 阻断了体验丰富多彩人生的道路。</p><p>我希望得到改变，我想成为一个行动力强的人，风风火火，不断尝试，勇敢龙龙，不畏挫折向前冲 ！！！ :-)</p><h2 id="什么是行动力？"><a href="#什么是行动力？" class="headerlink" title="什么是行动力？"></a>什么是行动力？</h2><p>行动力，代表的是一个人在决定做一件事之后，实际推动这件事发生的能力。 一个行动力强的人，会把自己的想法迅速地、持续地付诸实践，让想法照进现实；而一个行动力弱的人，则更像是个理想家，纵使脑海中有无数个想法，却很难主动把这些想法落地实践。</p><p>我们生活在一个现实的世界中，显然，一个行动力强的人，有更多的可能性做成一些事，现实中有很多这样的例子。比如，有不少人都想过旅居的生活，大多数人却左顾右盼、畏首畏尾，一次次的幻想，又一次次被 “困难” 所打倒；还有一些人，说干就干，学驾照、买车、规划路线、上路…… 一气呵成。</p><p>对于行动力强的人，大多数人报以赞许的态度，但有时候也很不解： 他们为什么能这么无所顾忌？ 实际上，行动力弱的人，大多数时候都是被 “顾忌” 所阻碍的。</p><h2 id="我们为何行动力弱？"><a href="#我们为何行动力弱？" class="headerlink" title="我们为何行动力弱？"></a>我们为何行动力弱？</h2><p>当我本来决定在做一件事之后，为什么却未能付诸行动？<br>有三种常见的状态： ① 顾忌太多，优柔寡断  ② 习惯性拖延  ③ 无行动框架，无所适从 。 以下，逐个状态分析一下，更清晰的认识才能针对性下药。</p><h3 id="顾忌太多，优柔寡断"><a href="#顾忌太多，优柔寡断" class="headerlink" title="顾忌太多，优柔寡断"></a>顾忌太多，优柔寡断</h3><p>主要表现是 “瞻前顾后”，这类人经常被人评价为： “想的太多”。 在他们的话语中存在很多假设，比如：”如果怎么怎么样，怎么办？”</p><p>这类情况的人有一些倾向： 生活没有太多原则，目标大都是多元化的，价值体系不成型，容易拎不清轻重，对事物安全感不足。</p><p>这种情况确实很难说他不对，因为 “人无远虑必有近忧”，但客观上，我们大多数时候的决策都在信息缺乏的条件下进行的，如果无法抓住主要矛盾，忽略次要因素，就会变得很难做出决策并且执行。</p><p>难做决策的一种原因是：缺乏更多信息的输入。 如果是这种情况，就需要意识到，需要去获取更多的信息来辅助决策。如果在获取信息时遇到的困难，需要知道一个道理：有些信息确是需要在有了一些行动之后才能获得的。就像你开车行驶在一条小路上，途径一座山，你目所能及之处只能看到小路在入山口截断，此时你需要做决定是否往前行，你能做的，或许就只有往前走走看，转过那个弯，你才能真正做出决策。</p><p>除了上面的 “想太多” ，还有另一种可能性： “习惯性悲观”。这可能是由上述 “想太多” 进一步产生的症状，它是一种习惯性状态，处于这种状态之下，会认为大多数事物没有希望。</p><p>相比如那些 “病在身体” 的情况而言，这种情况解决的难度是更大的，因为 “病在思想”，就需要从思想上改变。</p><p>顶层上，需要构建自己的价值体系，多问自己： 你想要什么？你为什么想要 xx ？ 如果不 xx 又怎样？</p><p>具体实践中，也可以采用另一类问题： 你能避免 xx 吗？ 如果能，何不尝试去避免呢？ 如果不能，为何不积极面对呢？快速搞完，你就有时间和精力去做你认可的事了。</p><p>或者，也可以在心中尝试植入一些 “信条”，比如： “哪有什么想不想，不过就是一些事而已，干就完事儿了”。 或许你不愿意，但如果我告诉你，这样做真的能让你快乐一点呢？</p><h3 id="习惯性拖延"><a href="#习惯性拖延" class="headerlink" title="习惯性拖延"></a>习惯性拖延</h3><p>存在一些不好的习惯，行动被习惯所打断，比如 “随便翻翻”、”注意力不集中”、”习惯性打断聚焦”、”习惯性转移注意力”，核心特征就是 “不自觉寻找其他能转移注意力的事物” 甚至是 “选择性忽略”。</p><p>这是受到外界影响而形成的一种行为状态，有可能是 第一条原因 产生的自我保护性行为，久而久之就成为一种习惯。</p><p>这属于 “病在身体”，可以通过 “行为矫正法” 来解决，具体如下： </p><ul><li>意识到这种问题及具体表现</li><li>自我监控，及时识别这种状态</li><li>建立另一种习惯性行为，来截断之前的习惯</li><li>可以通过刻意练习来保证 “行为矫正法” 的落地</li></ul><p>有一种强大的方法值得一试：用身体带动大脑。</p><p>有时候，我们知道该做某些事，我们总是会习惯性地调动大脑，去决策要不要做、怎么做，但是在习惯性拖延的病症下，我们的大脑总是会 “欺骗” 我们，用各种其他事务来转移我们的注意力。 此时，可以用身体带动大脑，当我们意识到事情该做，就立马行动起来，身体跑在大脑之前，先咱后奏，由于身体的带动，大脑就会采用一些其他的想法来应对，而这个想法，往往会是: “既然已经在做了，那就做吧”。 </p><h3 id="无行动框架，无所适从"><a href="#无行动框架，无所适从" class="headerlink" title="无行动框架，无所适从"></a>无行动框架，无所适从</h3><p>通常的表现为： 想做，但不知道怎么做，不知道怎么开始。有时候当我们获得了一个 “认识” 、得到一个结论、做了一个决策 之后，似乎就此结束了，不知后续如何。</p><p>存在这种类型的场景时，大多数是由于对所得到的 “认识” 还不够深刻，按照 <code>知道、理解、内化</code> 的认识标准来看，大多都是处于 “知道” 的层次，因此比较难和现实结合起来。</p><p>严格来说，这不算 “病”，或许算是 “弱”，缺少的是一套从 “认识” 到 “行动” 的方法论。</p><p>先问自己 “然后呢？我能做点啥？”，得到这些 “认识” 能带来的行为上的改变，相当于是列 TODO。</p><p>之后可以有两种方案来保证后续的执行：</p><p>其一，把能做的事加入到 “项目管理” 中，然后交由 “项目管理体系” 来支撑后续的行动。</p><p>其二，先做起来吧，从任意一个小事开始，往往开始就是胜利的一半。</p><h2 id="行动力炼成计划"><a href="#行动力炼成计划" class="headerlink" title="行动力炼成计划"></a>行动力炼成计划</h2><p>要解决具体某些事务的行动力，一套体系性的行动力炼成计划会更加有效，这涉及到一下几个方面：</p><ul><li>建立计划<ul><li>确定要解决那些行动力的问题</li><li>确定如何行动</li></ul></li><li>建立反馈<ul><li>确定如何激励和矫正</li></ul></li><li>持续性监测<ul><li>确定持续性触发的机制</li></ul></li></ul><p>这是一套实践的方法论，最好的解释方式就是实践一次，具体参见 <a href="/notpublish/index.html" name="阅读行动力炼成计划" >阅读行动力炼成计划</a> 。</p><hr><blockquote><p>And when the world is created, it is created in such a way that those eternal objects of God’s loving wisdom become actualities - interacting with one another, relating to God in the finite realm.<br>— <cite>Rowan Williams</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把okr应用在生活中</title>
    <link href="/longblog/posts/23_01_01_16_23_use_okr_in_daily_life.html"/>
    <url>/longblog/posts/23_01_01_16_23_use_okr_in_daily_life.html</url>
    
    <content type="html"><![CDATA[<h2 id="OKR-是什么"><a href="#OKR-是什么" class="headerlink" title="OKR 是什么"></a>OKR 是什么</h2><p>OKR 是一个用来管理 不确定性目标 的工具，改变了原来使用 KPI 的格局，在公司的管理体系中，OKR 所在的层次如下：</p><p><img src="https://static.longalong.cn/img/20230101163101.png"></p><p>既然是用来做 <code>目标管理</code> 的，它也同样遵循目标管理循环 PDCA<br><img src="https://static.longalong.cn/img/20230101163320.png"></p><p>目标的不确定性是 OKR 的一个背景，因此，OKR 是允许目标有变化的，符合 <code>成长性思维</code> 。</p><p><img src="https://static.longalong.cn/img/20230101163507.png"></p><p>和 KPI 相比，他们的主要异同如下：</p><p><img src="https://static.longalong.cn/img/20230101163558.png"></p><h2 id="如何制定-OKR"><a href="#如何制定-OKR" class="headerlink" title="如何制定 OKR"></a>如何制定 OKR</h2><h3 id="关于-O-的撰写"><a href="#关于-O-的撰写" class="headerlink" title="关于 O 的撰写"></a>关于 O 的撰写</h3><p>Objective 即 “是什么”，它应该：</p><ul><li>表述的是”目的”和”意图”，并且<strong>聚焦高优</strong>；</li><li>既要有挑战性，又要切合实际；</li><li>务必清晰明确，能让旁观者一眼就看明自这个oblective达成了还是没有；</li><li>O 的达成应当要有可预见的价值，应当和上层目标具有连接性；</li><li>有需要外部资源的地方，确保充分沟通对齐；</li></ul><h3 id="关于-KR-的撰写"><a href="#关于-KR-的撰写" class="headerlink" title="关于 KR 的撰写"></a>关于 KR 的撰写</h3><p>Key Results 即”如何做到”，它应该：</p><ul><li>表述的是一些可衡量、能校验的关键结果，并且聚焦高优，且这些KR的达成能最大程度上助益于 Objective 的实现；</li><li>表述的是结果而不是过程；</li><li>必须包含达成标准且这些标准清晰明了，可行可信；</li><li>有需要外部资源的地方，确保充分沟通对齐；</li><li>原则上应当符合SMART原则；<blockquote><p>S=Specific 具体的、M=Measurable 可衡量的、A=Attainable 可以达到的（虽然有挑战）、R=Relevant 相关的、T=Time-bound 有时效性的</p></blockquote></li></ul><p><img src="https://static.longalong.cn/img/20230101170111.png"></p><h3 id="跟进与复盘"><a href="#跟进与复盘" class="headerlink" title="跟进与复盘"></a>跟进与复盘</h3><ul><li>要多方协同的，有意识地随时沟通、讨论、拉齐；</li><li>周会机制：周会时以 OKR 的方式拉通和讨论；</li><li>每周更新 OKR 的进度，不要以“没有进展”体现进度；</li><li>月度/双月度复盘机制：审视目标、OKR的执行情况、及时防范风险、达到的成果（亮点）、遇到的问题（反思内外部的原因）、总结规律、是否需要对OKR进行调整；<br><img src="https://static.longalong.cn/img/20230101170325.png"></li></ul><h4 id="OKR-12-要"><a href="#OKR-12-要" class="headerlink" title="OKR 12 要"></a>OKR 12 要</h4><p>O 要清晰、易读、有进取心，始终进步<br>O 若有连接关系须明确清晰地体现、同相关方沟通确认<br>KR 要有明确标准和产出，可衡量，符合SMART原则<br>O 和 KR 要聚焦关键事项，少即是多，突出优先级<br>讨论过程积极参与、认真阅读及评论他人的 OKR<br>OKR应在团队内和协作方有明确的对齐的逻辑<br>讨论发言坦诚沟通、实事求是<br>讨论聚焦关键问题，发言直接、清晰有重点<br>共创良好的讨论氛围，鼓励自省、自我剖析<br>讨论确定后积极按照 OKR 高频开展工作<br>Review 的过程以终为始，以 O 的实现作为回顾和复盘的重点<br>需要着眼长期的目标，双月的OKR应该能够支撑更远大的目标</p><h4 id="OKR-12-不要"><a href="#OKR-12-不要" class="headerlink" title="OKR 12 不要"></a>OKR 12 不要</h4><ul><li>O 过于保守或无关紧要，表意模糊、生僻难懂</li><li>O 连接关系弱，没有和相关方充分沟通确认</li><li>KR模糊，不可校验，不足以支撑 O</li><li>O 和 KR 列“Laundry List”(长篇的罗列），多且没重点</li><li>讨论过程敷行了事</li><li>OKR 缺乏支撑、感觉团队做的事情和自己的OKR往上靠</li><li>讨论发言流于形式，走过场，陷在自己的叙事里</li><li>讨论过于发散，低效交流，若无必要也无需逐字通读</li><li>会议陷于追究责任、开批斗会、强调客观、推卸责任</li><li>讨论完后就放置不用，没有review，没有跟进沟通</li><li>仅 Review KR和具体任务/项目的进展，而忽略了最终的目的 O</li><li>脱离长远的规划，仅关注近两个月的事情，造成短视</li></ul><h2 id="OKR-应用在生活中"><a href="#OKR-应用在生活中" class="headerlink" title="OKR 应用在生活中"></a>OKR 应用在生活中</h2><p>基于一个基本理念： 人生目标管理的重要性比任何目标管理都重要，既然我们认可 okr 的价值，那么就更应该把 okr 的方法应用在人生目标的管理中，也就是应用在生活中。</p><p>2023 年有这些目标：<a href="/longblog/posts/23_01_01_16_21_summary_of_2022.html#2023年计划" name="2022年总结" >2022年总结</a></p><p>以下，把这些目标转成 OKR。</p><p>O1: 构建起强有力的学习框架，为学习效率提供支撑 [骨架计划]</p><ul><li>KR1：学习环境构建，展示学习环境，输出文章 1 篇。</li><li>KR2：学习内容构建，完成内容构建，输出内容构建的文章 1 篇。</li><li>KR3：学习过程管理建设，形成 okr 与项目管理机制，输出文章 1 篇。</li><li>KR4：学习成果与反馈建设，形成体系的成果反馈方案，输出文章 1 篇。</li></ul><p>O2: 提高工程效率，建立一套高效的快速开发体系 [磨刀计划]</p><ul><li>KR1：从 需求分析、架构设计、工具链、协作方案 的角度分析对效率工程的影响，找到一套高效的方案，形成研发体系，输出文章 3 篇。</li><li>KR2：以 前端、后端、运维 三个部分为基础，形成一套高效开发体系，输出专题文章 5 篇。</li><li>KR3：打破语言壁垒，练习 js/ts、shell、python、java、lua，输出文章 3 篇，适用每种语言完成一次项目。</li></ul><p>O3: 稳定价值体系</p><ul><li>KR1：研究阳明心学，理清中国古代哲学的体系，输出文章 3 篇，阅读相关书籍 3 本。</li><li>KR2：研究西方哲学入门知识，理清西方哲学的发展脉络，阅读书籍 2 本，输出文章 2 篇。</li><li>KR3：形成自己的价值体系，输出文章 3 篇。</li></ul><p>O4: 过好美好生活</p><ul><li>KR1：户外兴趣要持续进行，全年进行户外活动 15 次，其中有规划的活动 5 次。</li><li>KR2：美食需要研究和记录，研究美食数量 20 种，输出文章 2 篇，制作美食 20 次。</li><li>KR3：体重控制达到 135，胸肌和腹肌有轮廓感。</li><li>KR4：形成稳定的运动习惯，全年运动天数达 150 天，形成运动记录与激励方案，输出运动心得文章 3 篇。</li><li>KR5：需要记录生活，形成生活记录方案，输出文章 2 篇，记录生活超 50 次。</li></ul><h2 id="如何执行？"><a href="#如何执行？" class="headerlink" title="如何执行？"></a>如何执行？</h2><ul><li><p>如何保证持续执行？<br>可以参考 <a href="/longblog/posts/23_01_03_10_25_how_to_use_project_management_tools_in_daily_life.html" name="项目管理工具在生活中的应用" >项目管理工具在生活中的应用</a></p></li><li><p>在学习这件事上，有什么实践框架？<br>可以参考 <a href="/notpublish/index.html" name="骨架计划总论" >骨架计划总论</a></p></li></ul><hr><blockquote><p>If you would take, you must first give, this is the beginning of intelligence.<br>— <cite>Laozi</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>okr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年总结</title>
    <link href="/longblog/posts/23_01_01_16_21_summary_of_2022.html"/>
    <url>/longblog/posts/23_01_01_16_21_summary_of_2022.html</url>
    
    <content type="html"><![CDATA[<h2 id="今年整体评价"><a href="#今年整体评价" class="headerlink" title="今年整体评价"></a>今年整体评价</h2><h3 id="思想方面"><a href="#思想方面" class="headerlink" title="思想方面"></a>思想方面</h3><p>整体是混乱的，经历了一系列关于 “价值问题” 的洗礼，上半年处于混沌状态，下半年价值缺失的问题走向白热化。<br>经历过虚无主义的状态，目前逐步进行价值建设中，主要关注儒家心学，同时关注西方哲学体系。意识到 “意义” 最终都是 “宗教的”，目前希望从阳明心学中找到自己的信念。<br>从 “致良知” 和 “心即理” 的角度，在 “我们应该做什么事” 的问题上，认可 “创造性活动对我们的生活价值用极大的正向作用”，也在努力做到 “知行合一”。</p><h3 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h3><p>以 k8s 为基础，对 devops 体系有更多认识。<br>技术价值观经历了一次破裂，正在重塑中。从以往认为 “技术拥有至高无上的地位” 的技术崇拜 状态 到开始思考 “技术有什么价值?”。<br>目前的主要观点是： ① 技术没有高低贵贱之分，技术是一门工具，技术的价值依附于产品的价值  ② 当前互联网开发体系下，技术的主要附加价值体现在 “提高工程效率，降低研发成本” 上。<br>在技术的追求上，不再单纯追求 “流行的技术”，而是根据需要，去学习和掌握需要的技术。</p><h3 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h3><p>今年工作内容主要为 性能测试、私有部署体系、业务运维、少量业务开发。</p><p>2-5月热衷于发现系统问题，积极梳理问题及提出解决建议，6月为止，发现自己很难推动改变，对组织运行机制失望，9月经历了公司的裁员潮，没有被裁，整个小组仅剩我一人，之后系统的问题在逐步得到解决 (但跟我关系不大)。</p><p>6 月开始受到精神混乱的影响比较大，一直沉溺于对 “意义” 的追寻中，包括 “工作的意义”，工作上整体比较懈怠，没有产出突破性的成果。</p><p>从职业发展的角度来看，今年在工作上是失败的，不过也不必因此太过自责，今年是特别的一年，是职业价值观塑造的开端，宁可在探寻意义的路上孤苦前行，也不愿在糊涂与假象中安然自乐，就像苏格拉底说的：未经审视的人生不值得过</p><h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><p>对户外生活的兴趣加深；一段时期内对美食丧失兴趣；对健康的重视度有所提高；房贷第一年，遇到大环境不好，心理压力较大；和珊姐偶尔吵几句，但整体更加和谐稳定，思想交流也更加顺畅；今年在看动漫上的收获比较小，主要以打发时间消耗为主，但 《我的三体》、《凡人修仙传》 这两部作品还是给了我一些力量；</p><h3 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h3><p>今年几乎没有主题性学习，技术上的学习也是杂乱而随意的，整体学习时间少。 对工作日晚上 和 周末 的利用率很低。</p><h2 id="今年重要的认知收获"><a href="#今年重要的认知收获" class="headerlink" title="今年重要的认知收获"></a>今年重要的认知收获</h2><ol><li>作品是最好的名片</li><li>思考的质量 (正确的问题、足够的深度) 对认知升级有极其强大的作用</li><li>知道、理解、内化 的差别</li><li>建立人生正循环</li><li>阅读、探讨 是认知升级的重要途径</li><li>神思为唯一圣业</li><li>每个人都活在一个宗教般的信仰体系下，逻辑自洽、符合现实条件的信仰体系才会让人脱离精神混乱的游离状态，我需要有这么一套体系</li><li>人是意义动物，组织的文化建设和团队建设等，实际就是在为成员构建意义，也可以认为是价值渗透</li><li>这个世界是是不公平的，更是混乱的，这是现实</li><li>杠杆思维 (突破性变化)</li><li>认识规律和趋势，利用规律、迎合趋势</li><li>长期价值主义</li><li>创造性活动</li><li>闭环思维</li><li>守正出奇 (追求卓越，超越自我)</li><li>战略意图</li><li>记录生活的意义和生活的意义几乎同等重要</li></ol><h2 id="今年最大的遗憾"><a href="#今年最大的遗憾" class="headerlink" title="今年最大的遗憾"></a>今年最大的遗憾</h2><ol><li>在意义探索过程中，其他方面的进展很缓慢，技术上几乎没有突破性变化，工作上收获几乎为负</li><li>okr 体系运用在生活中未能建立起来</li><li>运动体系未能持续</li></ol><p>今年虽然有非常多的遗憾，但站在另一个角度，这些看似遗憾的东西，其实都像是埋下的种子，2023 年到来之际，这些种子依然能够生根发芽，并最终长成大树为我们构建人生大厦做重要的支撑。</p><h2 id="今年重要事件"><a href="#今年重要事件" class="headerlink" title="今年重要事件"></a>今年重要事件</h2><ol><li>6 月开始，执行计划墙计划，(然而)一个月后弃疗</li><li>7 月开始把 ob 作为 todo list 和 知识管理工具使用，并建立了相对健全的驱动体系</li><li>8 月起做了运动的尝试，控制饮食和运动双管齐下，体重降低 12 斤</li><li>中秋节期间，父母拜访了珊姐一大家子，为将来和谐相处奠定了坚实基础</li><li>博客数量有了长足的增长，从 2021 年的 8 篇增加到当前的 71 篇 (虽然质量有限并且还些坑没填)</li><li>11 月开始理解哲学和宗教对于人的意义</li></ol><h2 id="整体的整体"><a href="#整体的整体" class="headerlink" title="整体的整体"></a>整体的整体</h2><p>2022年，我是不幸的，我更是幸运的。</p><p>这一年发生了很多的事，这个世界发生了更多的事，我们都感受到了这个世界的混乱，也感受到了个人在强势群体和趋势面前的无力。疫情加速了这个价值观割裂的世界走向更加割裂，也加速了以往高增长掩盖下的各种矛盾的凸显，这一年，注定是会深深刻入我们人生印记的一年……</p><p>这一年我也发生了很多的事，经历了生命中最直观的一次大型被割韭菜，经历了一次价值观念的割裂及重建，经历了生活和工作的价值塑造……</p><p>这一年，痛苦伴随了我很长时间，但是，不经历点风雨，又怎能见彩虹呢，甚至，我的这点痛苦，和很多人相比，又算得了什么呢？庸人自扰也不一定。</p><p>实际上，我是幸运的。</p><p>人只有在比较中，才能更清楚地看到自己拥有什么、没有拥有什么。经过对比，我发现，我拥有很多珍贵的宝藏： 我的家人们都很健康，他们生活稳定，精神稳定；家人们都很开明，这让我和爱人拥有不少的生活选择权；我的爱人很可爱、很可靠，在我思想混乱的时候也一直支持和帮助我；我有一定的阅读能力和思辨能力，也依稀有自己在精神的追求；我进入了技术的世界，就像玩游戏一样，我拥有构建一个个理想世界的潜力；我所在公司的领导很宽容，给了我很多独立的空间……</p><p>2022年，27岁，是时候说再见了。</p><p>伴随着新一年的到来，我想起了老爸对我们说过的一句话：生活不简单，但我们可以简单的生活。 摒弃那些纷繁的诱惑，拨开内心的屏障，直面内心，回归本心，让那些乱我道心的妖邪狐媚都随着 2022 午夜的钟声一同消散在穹宇中……</p><p>新的一年，我不敢说能完全摆脱混乱和迷茫，也不敢乞求不会遭遇更大的挑战，但我想，面对生活，不论什么变化，我应该都能更加从容。</p><p>实际上，对于 2023，我是充满信心的。</p><ul><li>在生活上，我能更加坦诚面对自己的欲望，户外、美食、健康 会是生活中的关键词；</li><li>在工作上，我更加清楚自己想要的是什么，突破、创造、构建体系、中庸 会是工作的关键词；</li><li>在家庭上，我更信赖亲人，互赖、互信、携手共进 会是家庭的关键词；</li><li>在思想上，我走上了探索价值观和信念的道路，学习、思考、坚定 会是思想方面的关键词。</li></ul><p>如果让我用几个词语来给 2023 许下期待，我希望是： 从容、自信、坚定、创造。</p><p>2023 年，28岁，你好</p><h2 id="2023年计划"><a href="#2023年计划" class="headerlink" title="2023年计划"></a>2023年计划</h2><h3 id="技术上的规划"><a href="#技术上的规划" class="headerlink" title="技术上的规划"></a>技术上的规划</h3><ul><li>整体更重视 工程效率，以 需求分析、架构设计、工具链、协作方案 为主要关注点。互联网技术上，追求一套高效的快速开发体系，包括比较传统的 前端、后端、运维 几个部分，目前暂不关注 大数据、ML、图形、音视频 这几块。这是工作上的立身之本。【磨刀计划】</li><li>开始切入物联网应用，建立对物联网产业的整体认识，做工业物联网的技能储备。</li><li>需要有大量的训练，算法上有一些基本的训练，设计模式上有较多训练，借由八股文的练习总结一下当前技术的核心点，做较多的实操项目训练。</li><li>打破语言屏障，进一步突破 js/ts，熟练掌握 shell，熟练使用 python、java、c、lua。 【破壁计划】</li></ul><h3 id="2023工作上的规划"><a href="#2023工作上的规划" class="headerlink" title="2023工作上的规划"></a>2023工作上的规划</h3><ul><li>找到自己在工作上的追求，用更开放的心态看待工作，用更专业的状态对待工作。</li><li>站在行业的角度、企业的角度、团队的角度 看待工作内容，总结梳理自己的职业价值观。【职业观计划】</li><li>有技术的分享机会时，做至少 2 次主题分享 【speech计划】</li></ul><h3 id="2023学习上的规划"><a href="#2023学习上的规划" class="headerlink" title="2023学习上的规划"></a>2023学习上的规划</h3><ul><li>对教育学进行主题性学习；</li><li>构建起强有力的学习框架，包括环境、内容、反馈、留存等方面，全年学习时长目标为 1000 小时； 【骨架计划】</li><li>构建以刻意练习为核心方法的技能学习方法论，并用于实践【金手指计划】</li><li>所做的学习都要有产出；</li></ul><h3 id="2023生活上的规划"><a href="#2023生活上的规划" class="headerlink" title="2023生活上的规划"></a>2023生活上的规划</h3><ul><li>户外的兴趣要得到满足，寄情山野，创造回忆；</li><li>对美食需要建立记录，做美食的分析，做美食食谱，构建美食的体系性认识；</li><li>健康方面，要将健康融入到生活中，将运动体系融入到生活中，体重控制上达到 135 的目标，体型上有一些追求；【炼体计划】</li><li>房贷正常还款，不再过度忧虑；</li><li>如无特别的目的，今年完全不看动漫和电视剧；</li><li>和珊姐保持更好的精神同步，更加注重沟通方式；</li><li>建立体系性的生活记录方式；【人生化石计划】</li></ul><h3 id="2023创造性活动规划"><a href="#2023创造性活动规划" class="headerlink" title="2023创造性活动规划"></a>2023创造性活动规划</h3><ul><li>更进一步的创造性活动的价值体系解释</li><li>okr 体系计划</li><li>创造性活动实践</li></ul><h3 id="2023其他方面规划"><a href="#2023其他方面规划" class="headerlink" title="2023其他方面规划"></a>2023其他方面规划</h3><ul><li>稳定思想价值体系</li><li>对费曼学习法的充分运用</li><li>建立需要的技术框架</li><li>健康和运动融入到生命中</li><li>冥想式思考</li></ul><hr><blockquote><p>I have not failed. I’ve just found 10,000 ways that won’t work.<br>— <cite>Thomas Edison</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>summary</tag>
      
      <tag>plan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种常见的daemon方式</title>
    <link href="/longblog/posts/22_11_24_12_38_kinds_of_daemon.html"/>
    <url>/longblog/posts/22_11_24_12_38_kinds_of_daemon.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在使用 cli 工具时，经常有这样的需求： ① 失败自动重启 ② 后台守护进程运行</p><p>在守护进程这件事上，我们常用的有这些工具：</p><ul><li>systemd</li><li>init</li><li>supervisior</li><li>pm2</li><li>tmux、screen</li><li>nohup</li></ul><p>以上工具都或多或少存在一些问题，以下逐个分析一下</p><h2 id="各工具优劣"><a href="#各工具优劣" class="headerlink" title="各工具优劣"></a>各工具优劣</h2><h3 id="systemd-amp-init"><a href="#systemd-amp-init" class="headerlink" title="systemd &amp; init"></a>systemd &amp; init</h3><p>systemd 和 init 都是在 linux 体系下的进程管理方式，优点是，只要在 linux 下，这就是一定会存在的能力，因此兼容性很好。缺点是，一方面只有在 linux 下有，家用 pc 上无法使用；需要单独写配置文件。</p><p>这两种方式是 linux 下最常用的方案，操作系统级别的支持还是很可靠的，重启策略、日志 等都直接可用。兼容性最好。</p><p>之前在 <a href="/longblog/posts/21_12_12_how_to_resolve_proxy_in_linux.html#代理安装" name="如何解决linux下的代理访问" >如何解决linux下的代理访问</a> 也有用到 systemd</p><blockquote><p>参考文档<br><a href="https://systemd.io/">官方文档</a><br><a href="https://www.jinbuguo.com/systemd/systemd.html">systemd man 翻译</a><br><a href="https://zhuanlan.zhihu.com/p/271071439">一个案例</a></p></blockquote><h3 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h3><p>这是一个类似 systemd 的 python 程序，只要有 python 环境则都可以运行。优点是，只要有 python 环境，则可以运行。缺点是，需要单独安装、写配置文件、需要设置supervisor自启动</p><p>配置文件可以参考 <a href="http://supervisord.org/configuration.html">官方文档</a><br>另外，社区有一个 <a href="https://github.com/ochinchina/supervisord">golang 版本的实现</a> ，最大的价值在于无需依赖，在 docker 中或者在一些轻量级的系统中挺适用。</p><p>在容器时代之前，这是一个被广泛用作业务进程管理的工具。</p><blockquote><p>supervisor 和 systemd 的一个比较： <a href="https://segmentfault.com/a/1190000009338835">参考资料</a></p></blockquote><h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>毋庸置疑，这是一个神器。强大到令人发指(主要是操作太友好了)。<br>优点：好用，强大<br>缺点：nodejs 依赖</p><p>pm2 可以直接让提供网络服务的 nodejs 程序拥有多进程能力，之前在 <a href="/notpublish/index.html" name="nodejs多进程管理的方式" >nodejs多进程管理的方式</a> 有提到</p><blockquote><p>ps: 多一嘴，如果 pm2 的面板是开源的就更香了<br>使用参考<a href="https://pm2.keymetrics.io/docs/usage/quick-start/">官方文档</a></p></blockquote><h3 id="tmux-screen-nohup"><a href="#tmux-screen-nohup" class="headerlink" title="tmux | screen | nohup"></a>tmux | screen | nohup</h3><p>这几个算是一类工具，都是把 在前台执行的程序 放到后台运行。</p><p>nohup 是最简单的，使用时，直接使用 <code>nohup xxxx &amp;</code>  或者把日志定向到特定文件 <code>nohup xxx &gt; xx.log</code>， nohup 的缺点在于无法恢复到交互状态，往往只能通过 <code>kill</code> 进程号来结束运行。</p><p>tmux 和 screen 这类，弥补了 nohup 不能恢复到交互状态的缺点.</p><ul><li>新增一个运行的命令 <code>screen -S xxsessname xxx</code> </li><li>使用 <code>ctl + a + d</code> 从当前 screen 出去</li><li>使用 <code>ctl + a + c</code> 在当前 screen 分一个子 screen 出来 (等同在当前terminal 下输入 <code>screen</code> 命令)</li><li>使用 <code>ctl + a + a</code> 在同一个 screen 的不同子 screen 切换</li><li>使用 <code>screen -list</code> 查看有哪些 screen 在运行</li><li>使用 <code>screen -r xxxsessname</code> 恢复到一个 screen 中</li></ul><p>tmux 类似。</p><p>这几个工具，都是 session 级别的，没有 开机拉起、失败重启 的策略，当处理一些耗时的命令时可用，例如 gzip、wget 等</p><h2 id="golang做到简单的daemon"><a href="#golang做到简单的daemon" class="headerlink" title="golang做到简单的daemon"></a>golang做到简单的daemon</h2><h3 id="用-service-项目"><a href="#用-service-项目" class="headerlink" title="用 service 项目"></a>用 service 项目</h3><p><a href="https://github.com/kardianos/service">这个项目</a> 比较有意思，这是把 golang 的程序结合着各个平台的 daemon 工具来使用，相当于它来帮你写 systemd 的 service 文件(linux下)。</p><h3 id="直接用代码实现"><a href="#直接用代码实现" class="headerlink" title="直接用代码实现"></a>直接用代码实现</h3><ul><li><input disabled="" type="checkbox"> 封装实现一个直接在后台运行的 golang 程序</li></ul><hr><blockquote><p>People may doubt what you say, but they will believe what you do.<br>— <cite>Lewis Cass</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>daemon</tag>
      
      <tag>cli</tag>
      
      <tag>supervisor</tag>
      
      <tag>screen</tag>
      
      <tag>systemd</tag>
      
      <tag>pm2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批任务处理工具</title>
    <link href="/longblog/posts/22_11_23_01_26_batch_job_tools.html"/>
    <url>/longblog/posts/22_11_23_01_26_batch_job_tools.html</url>
    
    <content type="html"><![CDATA[<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>shell 是一个用于和 linux 内核交互的工具，通常用来编写各种自动化脚本。</p><p>shell 有两种模式，交互式 和 脚本式，我们主要谈论脚本式。</p><p>shell 很强大，我认为强大来源于三方面：</p><ul><li>脚本语言，开发方便</li><li>环境适应性非常非常广</li><li>能够粘合各类工具</li></ul><p>shell 也有一些问题，我认为主要在这两方面：</p><ul><li>编程范式和现代高级语言有较大差异 (几乎是纯命令式编程，且语言风格与其他语言差别较大)</li><li>语言本身的功能较弱，工程能力较差 (缺乏统一标准库、模块管理能力弱)</li></ul><p>现在大多数机器中都集成了 python，因此基于 python 在很多场景下是可以替代 shell 的，尤其是在十分需要 <code>工程化</code> 的项目中。</p><p>但由于 shell 和 linux 系统有着天生的兼容性，因此 shell 一定会大量运用于 linux 中的各个方面，甚至可以认为: **linux 不灭，shell 永存 **。</p><h3 id="shell-主要难理解的地方"><a href="#shell-主要难理解的地方" class="headerlink" title="shell 主要难理解的地方"></a>shell 主要难理解的地方</h3><h4 id="变量的差异"><a href="#变量的差异" class="headerlink" title="变量的差异"></a>变量的差异</h4><h5 id="类型系统是非常非常弱的！！"><a href="#类型系统是非常非常弱的！！" class="headerlink" title="类型系统是非常非常弱的！！"></a>类型系统是非常非常弱的！！</h5><p>在 shell 中，字面量默认都是 字符串 ！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=hello<br>var3=<span class="hljs-string">&quot;hello_quote&quot;</span><br>var4=<span class="hljs-string">&#x27;semi_quote&#x27;</span><br>var5=<span class="hljs-string">&quot;hello world 123&quot;</span><br><br><span class="hljs-built_in">echo</span> hello   <span class="hljs-comment"># hello</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你好&quot;</span>   <span class="hljs-comment"># 你好</span><br><span class="hljs-built_in">echo</span> var2    <span class="hljs-comment"># var2</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var2</span>   <span class="hljs-comment"># hello</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var3</span>   <span class="hljs-comment"># hello_quote</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$var4</span>&quot;</span> <span class="hljs-comment"># semi_quote</span><br></code></pre></td></tr></table></figure><h5 id="带空格的字符串也可以类似数组迭代"><a href="#带空格的字符串也可以类似数组迭代" class="headerlink" title="带空格的字符串也可以类似数组迭代"></a>带空格的字符串也可以类似数组迭代</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">arr=<span class="hljs-string">&quot;hello world arr&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$arr</span>; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h5 id="拼字符串的时候会看起来很奇怪"><a href="#拼字符串的时候会看起来很奇怪" class="headerlink" title="拼字符串的时候会看起来很奇怪"></a>拼字符串的时候会看起来很奇怪</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">var=nihao<br><span class="hljs-built_in">echo</span> \&quot;hello world\&quot; and <span class="hljs-variable">$var</span> are equal<br></code></pre></td></tr></table></figure><h5 id="数组的操作和其他语言不大一样"><a href="#数组的操作和其他语言不大一样" class="headerlink" title="数组的操作和其他语言不大一样"></a>数组的操作和其他语言不大一样</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">long=(longalong 18 <span class="hljs-string">&quot;handsome&quot;</span>)<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;long[0]&#125;</span>  <span class="hljs-variable">$&#123;long[2]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;long[*]&#125;</span> <span class="hljs-comment"># 全部</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#long[*]&#125;</span>  <span class="hljs-comment"># 数组长度！！</span><br></code></pre></td></tr></table></figure><p>数组也可以这么赋值 <code>ages=([3]=24 [5]=19 [10]=12)</code></p><p>数组拼接方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">array1=(23 56)<br>array2=(99 <span class="hljs-string">&quot;hello world&quot;</span>)<br>array_new=(<span class="hljs-variable">$&#123;array1[@]&#125;</span> <span class="hljs-variable">$&#123;array2[*]&#125;</span>)<br></code></pre></td></tr></table></figure><p>删除数组一个值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">arr=(23 56 99 <span class="hljs-string">&quot;hello world&quot;</span>)<br><span class="hljs-built_in">unset</span> arr[1]<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span><br></code></pre></td></tr></table></figure><h5 id="map-关联数组-需要申明，其他可申可不申"><a href="#map-关联数组-需要申明，其他可申可不申" class="headerlink" title="map (关联数组) 需要申明，其他可申可不申"></a>map (关联数组) 需要申明，其他可申可不申</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -A testmap<br><br>testmap[name]=longsang<br>testmap[age]=18<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;testmap[age]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;testmap[*]&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">-f [name]列出之前由用户在脚本中定义的函数名称和函数体。<br>-F [name]仅列出自定义函数名称。<br>-g name在 Shell 函数内部创建全局变量。<br>-p [name]显示指定变量的属性和值。<br>-a name声明变量为普通数组。<br>-A name声明变量为关联数组（支持索引下标为字符串）。<br>-i name 将变量定义为整数型。<br>-r name[=value] 将变量定义为只读（不可修改和删除），等价于 readonly name。<br>-x name[=value]将变量设置为环境变量，等价于 export name[=value]。<br></code></pre></td></tr></table></figure><h5 id="true-和-false-有时候是-bool-，有时候又是-字符串"><a href="#true-和-false-有时候是-bool-，有时候又是-字符串" class="headerlink" title="true 和 false 有时候是 bool ，有时候又是 字符串"></a>true 和 false 有时候是 bool ，有时候又是 字符串</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">vart=<span class="hljs-literal">true</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$vart</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$vart</span>; <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> hello; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h5 id="所有变量的直接使用都得用-xxx"><a href="#所有变量的直接使用都得用-xxx" class="headerlink" title="所有变量的直接使用都得用 $xxx"></a>所有变量的直接使用都得用 $xxx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=longalong<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span><br></code></pre></td></tr></table></figure><h5 id="直接命名的变量都是全局变量-包括-function-中！！"><a href="#直接命名的变量都是全局变量-包括-function-中！！" class="headerlink" title="直接命名的变量都是全局变量 (包括 function 中！！)"></a>直接命名的变量都是全局变量 (包括 function 中！！)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=long<br><br><span class="hljs-function"><span class="hljs-title">changename</span></span>() &#123;<br>name=longalong<br>&#125;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br>changename<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># longalong</span><br><br><br><span class="hljs-comment"># 函数内可以使用 local name 重新申明</span><br>name=long<br><br><span class="hljs-function"><span class="hljs-title">changename</span></span>() &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br><span class="hljs-built_in">local</span> name  <br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># &quot;&quot;</span><br>name=longalong<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># longalong</span><br>&#125;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br>changename<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br></code></pre></td></tr></table></figure><h5 id="大量使用子命令"><a href="#大量使用子命令" class="headerlink" title="大量使用子命令"></a>大量使用子命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">now=`date`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$now</span><br><br>now=$(date)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$now</span><br></code></pre></td></tr></table></figure><h5 id="类型很弱，也就别期待-结构体、类型、对象-这类东西了"><a href="#类型很弱，也就别期待-结构体、类型、对象-这类东西了" class="headerlink" title="类型很弱，也就别期待 结构体、类型、对象 这类东西了"></a>类型很弱，也就别期待 结构体、类型、对象 这类东西了</h5><h4 id="运算符差异"><a href="#运算符差异" class="headerlink" title="运算符差异"></a>运算符差异</h4><h5 id="语言层没有算数运算符！！！"><a href="#语言层没有算数运算符！！！" class="headerlink" title="语言层没有算数运算符！！！"></a>语言层没有算数运算符！！！</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=321<br>var3=123+321<br>var4=<span class="hljs-variable">$var1</span>+<span class="hljs-variable">$var2</span><br><br><span class="hljs-built_in">echo</span> var3 : <span class="hljs-variable">$var3</span>  <span class="hljs-comment"># var3 : 123+321</span><br><span class="hljs-built_in">echo</span> var4 : <span class="hljs-variable">$var4</span>  <span class="hljs-comment"># var4 : 123+321</span><br></code></pre></td></tr></table></figure><p>要使用指令进行计算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=321<br><br><span class="hljs-comment"># 用 let 做运算</span><br><span class="hljs-built_in">let</span> var3=<span class="hljs-variable">$var1</span>+<span class="hljs-variable">$var2</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var3</span> <span class="hljs-comment"># 444</span><br><br><span class="hljs-comment"># 用 $(()) 做运算</span><br>var4=$((<span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>))<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var4</span> <span class="hljs-comment"># 444</span><br></code></pre></td></tr></table></figure><p>或者使用单独的命令来实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=321<br><br>var3=`expr <span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var3</span><br></code></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><p>以上方法都仅适用于 <code>整数运算</code> ，要想做浮点运算，需要用  <code>bc</code>  或者 <code>awk</code> ！</p><h5 id="关系运算符-比较运算符-的样式很怪异"><a href="#关系运算符-比较运算符-的样式很怪异" class="headerlink" title="关系运算符(比较运算符) 的样式很怪异"></a>关系运算符(比较运算符) 的样式很怪异</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=123<br>b=123<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> : a 等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span>: a 不等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>当然也可以用 &gt; 、&lt; 、 &gt;= 这种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=124<br>b=123<br><br><span class="hljs-keyword">if</span> (( <span class="hljs-variable">$a</span> &gt;= <span class="hljs-variable">$b</span> ))<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> &gt;= <span class="hljs-variable">$b</span> : a 大于等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> &lt; <span class="hljs-variable">$b</span>: a 小于 b&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>需要注意的是， = 这个符号，在比较中，代表的是 “等于”，而不是赋值。</p><h5 id="逻辑运算-amp-amp-和布尔运算含义是一样的，但布尔运算形式和关系运算符类似"><a href="#逻辑运算-amp-amp-和布尔运算含义是一样的，但布尔运算形式和关系运算符类似" class="headerlink" title="逻辑运算 &amp;&amp; || 和布尔运算含义是一样的，但布尔运算形式和关系运算符类似"></a>逻辑运算 &amp;&amp; || 和布尔运算含义是一样的，但布尔运算形式和关系运算符类似</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=<span class="hljs-literal">false</span><br>b=<span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -o <span class="hljs-variable">$b</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> a or b<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h5 id="看起来很不习惯的字符串运算符"><a href="#看起来很不习惯的字符串运算符" class="headerlink" title="看起来很不习惯的字符串运算符"></a>看起来很不习惯的字符串运算符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">假设  a=abc  b=def<br><br>=检测两个字符串是否相等，相等返回 true。[ $a = $b ] 返回 false。<br>!=检测两个字符串是否不相等，不相等返回 true。[ $a != $b ] 返回 true。<br>-z检测字符串长度是否为0，为0返回 true。[ -z $a ] 返回 false。<br>-n检测字符串长度是否不为 0，不为 0 返回 true。[ -n &quot;$a&quot; ] 返回 true。<br>$检测字符串是否不为空，不为空返回 true。[ $a ] 返回 true。<br></code></pre></td></tr></table></figure><h5 id="有文件运算符这种东西"><a href="#有文件运算符这种东西" class="headerlink" title="有文件运算符这种东西"></a>有文件运算符这种东西</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text">文件类型判断<br>-b filename判断文件是否存在，并且是否为块设备文件。<br>-c filename判断文件是否存在，并且是否为字符设备文件。<br>-d filename判断文件是否存在，并且是否为目录文件。<br>-e filename判断文件是否存在。<br>-f filename判断文件是否存在，井且是否为普通文件。<br>-L filename判断文件是否存在，并且是否为符号链接文件。<br>-p filename判断文件是否存在，并且是否为管道文件。<br>-s filename判断文件是否存在，并且是否为非空。<br>-S filename判断该文件是否存在，并且是否为套接字文件。<br><br>文件权限判断<br>-r filename判断文件是否存在，并且是否拥有读权限。<br>-w filename判断文件是否存在，并且是否拥有写权限。<br>-x filename判断文件是否存在，并且是否拥有执行权限。<br>-u filename判断文件是否存在，并且是否拥有 SUID 权限。<br>-g filename判断文件是否存在，并且是否拥有 SGID 权限。<br>-k filename判断该文件是否存在，并且是否拥有 SBIT 权限。<br><br>文件比较<br>filename1 -nt filename2判断 filename1 的修改时间是否比 filename2 的新。<br>filename -ot filename2判断 filename1 的修改时间是否比 filename2 的旧。<br>filename1 -ef filename2判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法<br></code></pre></td></tr></table></figure><h4 id="作用域分隔符的差异"><a href="#作用域分隔符的差异" class="headerlink" title="作用域分隔符的差异"></a>作用域分隔符的差异</h4><p>使用反过来的方式表示结束，和大多数用 <code>&#123;&#125;</code> 或者用 缩进 做区分的方式不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if 和 fi<br>do 和 done<br>case 和 esac<br></code></pre></td></tr></table></figure><h4 id="函数调用方法的差异"><a href="#函数调用方法的差异" class="headerlink" title="函数调用方法的差异"></a>函数调用方法的差异</h4><ul><li>调用不用加小括号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">sayhello</span></span>() &#123;<br><span class="hljs-built_in">echo</span> hello<br>&#125;<br><br>sayhello<br></code></pre></td></tr></table></figure><ul><li>参数直接跟在调用的后面</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">greet</span></span>() &#123;<br><span class="hljs-built_in">echo</span> hello <span class="hljs-variable">$1</span>, welcome<br>&#125;<br><br>greet longalong<br></code></pre></td></tr></table></figure><ul><li>没有形参进行接收，全部用位置表示，且从 1 开始计数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">sayit</span></span>() &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> <span class="hljs-variable">$3</span> <span class="hljs-variable">$4</span> <span class="hljs-variable">$5</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;11&#125;</span> <span class="hljs-comment"># 超过 10 以上</span><br><span class="hljs-built_in">echo</span> 参数总数为 : <span class="hljs-variable">$#</span><br><span class="hljs-built_in">echo</span> 所有参数为 : $*<br>&#125;<br><br>sayit longalong IS VERY HANDSOME<br></code></pre></td></tr></table></figure><ul><li>return 仅返回 0-255 的数字，一般表示运行情况，而真正想要被变量接收的，则用 echo 实现</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">whatisreturn</span></span>() &#123;<br><span class="hljs-built_in">echo</span> hello<br><span class="hljs-built_in">echo</span> world<br><span class="hljs-built_in">return</span><br>&#125;<br><br>re=`whatisreturn`<br><br><span class="hljs-built_in">echo</span> $?   <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$re</span>  <span class="hljs-comment"># hello world</span><br></code></pre></td></tr></table></figure><h4 id="for-循环的差异"><a href="#for-循环的差异" class="headerlink" title="for 循环的差异"></a>for 循环的差异</h4><p>有一些和其他语言不一样的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> (( i=0;i&lt;=5;i++ )); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;0..5&#125;; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `seq 0 5`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `cat xxx`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">int=1<br><span class="hljs-keyword">while</span>(( <span class="hljs-variable">$int</span>&lt;=5 ))<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$int</span><br>    <span class="hljs-built_in">let</span> <span class="hljs-string">&quot;int++&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=0<br><br>until [ ! <span class="hljs-variable">$a</span> -lt 10 ]<br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span><br>   a=`expr <span class="hljs-variable">$a</span> + 1`<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> *.sh<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$filename</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="分支语句的差异"><a href="#分支语句的差异" class="headerlink" title="分支语句的差异"></a>分支语句的差异</h4><ul><li><p>if 语句的差别主要在关系运算符上</p></li><li><p>多分支语句</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">num=<span class="hljs-variable">$1</span><br><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>    1)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你输入了 1&#x27;</span><br>    ;;<br>    2)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你输入了 2&#x27;</span><br>    ;;<br>    *)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你没有输入 1 和 2&#x27;</span><br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><h4 id="文本处理的差异"><a href="#文本处理的差异" class="headerlink" title="文本处理的差异"></a>文本处理的差异</h4><ul><li>字符串操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">str=<span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#str&#125;</span>  <span class="hljs-comment"># 井号取长度，和 arr 一样，大多数语言会用函数如 len() 或者属性如 .length </span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str:2:-2&#125;</span> <span class="hljs-comment"># 冒号为截取子串，大多数语言会用中括号加冒号，如 str[2:-2]</span><br></code></pre></td></tr></table></figure><ul><li>更多不好记的处理方式可以参考 <a href="http://c.biancheng.net/view/1120.html">C语言网教程</a></li></ul><h4 id="其他难理解的地方"><a href="#其他难理解的地方" class="headerlink" title="其他难理解的地方"></a>其他难理解的地方</h4><ul><li><p>在 shell 交互式命令行中经常需要转义，有些转义很难理解</p></li><li><p>有很多内建命令，具体参考 <a href="http://c.biancheng.net/view/1136.html">C语言网教程</a></p></li><li><p>一些场景下不允许空格，一些场景下又必须空格</p></li><li><p>多种重定向易蒙圈</p></li><li><p>几乎没有模块系统</p></li></ul><p>可以过一遍<a href="https://www.runoob.com/linux/linux-shell-process-control.html">菜鸟</a><br>可以看下<a href="https://zhuanlan.zhihu.com/p/102176365/">一个同事写的</a><br><a href="http://c.biancheng.net/view/942.html">C语言网教程</a> 的高级部分还是值得看一下，但要付费，姑且按照相关话题，在网上搜搜资料。</p><h2 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h2><p>先把 <a href="https://docs.ansible.com/">官方文档</a> 看一遍<br>然后把 <a href="https://github.com/geerlingguy/ansible-for-devops">ansible-for-devops</a> 里面的案例看一遍，这个项目的作者专门在搞 ansible，可以看 <a href="https://github.com/geerlingguy?tab=repositories">他的主页</a></p><h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><ul><li><p>ansible 是一个 linux 批处理任务工具，通过提供 分类、批量、顺序、选择、触发 等编排能力，实现远程任务管理能力。</p></li><li><p>ansible 主要用来做  基础设施准备 (配置管理+置备)、 服务CICD (部署自动化)、任务编排 (构建存储系统、构建集群等等)。</p></li><li><p>ansible 命令方式执行，类似于在多台机器上执行命令。(和 iterm 中使用 cmd + alt + i 类似)</p></li><li><p>最强大的地方在于其生态，可以从 <a href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a> 找到大量别人写好的 roles 、plugins 等等，可以很简便就集成使用。 实际上，和使用 docker-compose 起服务、使用 helm charts 起服务 一样，都可以在他人成果的基础上使用。</p></li></ul><h3 id="官方文档阅读笔记"><a href="#官方文档阅读笔记" class="headerlink" title="官方文档阅读笔记"></a>官方文档阅读笔记</h3><ul><li><p>ansible 使用 ini 文件 或者 yaml 文件 作为配置文件格式</p></li><li><p>inventory ： 用来标识要管理的机器，对机器进行  分组、配置连接方式(user、jump等)、动态监控云上机器并自动修改要管理的机器实例等。 <a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html">官方文档</a></p></li><li><p>playbook： 用来描述一系列任务的方式，分为  角色(role: 不同的系列任务)、任务(tasks: 一系列任务)，这是大多数项目使用 ansible 的方式。 <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.html">roles</a> <a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html">主要概念</a></p></li><li><p>templates:  用来动态生成 yaml/ini 配置文件的模板，使用 jinja2 (python)。<a href="https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters">jinja文档</a>  <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#playbooks-variables">ansible 中的变量</a>  <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_vars_facts.html#vars-and-facts">ansible 中特定的变量</a> [重要]</p></li><li><p>module： 模块，ansible 的要执行的各种功能是以模块呈现的，例如 copy、创建文件 等等，不同的模块有不同的参数，ansible 的各种 tasks (实际执行的任务)，都是用  模块 + 参数 的方式构成的。 <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#description">ansible 的默认模块</a>  [重要]</p></li><li><p>ansible 的概念结构可以参考 <a href="https://docs.ansible.com/ansible/latest/dev_guide/overview_architecture.html#modules">ansible architecture</a> [重要]</p></li><li><p>playbook 是一个 任务编排 工具，抽象来看，市面上有非常多的任务编排系统，他们所面对的问题域基本都是一样的，可以以此为例子对任务编排进行梳理。</p><ul><li><input disabled="" type="checkbox"> 调研多种任务编排系统，找到他们的共性问题</li></ul></li></ul><h3 id="简单试用"><a href="#简单试用" class="headerlink" title="简单试用"></a>简单试用</h3><ul><li><p>安装 ansible</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y ansible<br></code></pre></td></tr></table></figure></li><li><p>设置要管理的机器 (inventory)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">vim /etc/ansible/hosts<br><br>[chaos]<br>172.17.5.245<br>172.17.5.246<br>172.17.5.247<br></code></pre></td></tr></table></figure></li><li><p>使用 shell 查看信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">ansible chaos -m shell -a &quot;uname -a&quot;<br><br>172.17.5.245 | CHANGED | rc=0 &gt;&gt;<br>Linux prichaos003 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux<br>172.17.5.247 | CHANGED | rc=0 &gt;&gt;<br>Linux prichaos002 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux<br>172.17.5.246 | CHANGED | rc=0 &gt;&gt;<br>Linux prichaos001 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></table></figure></li></ul><h3 id="mac-下的使用"><a href="#mac-下的使用" class="headerlink" title="mac 下的使用"></a>mac 下的使用</h3><h4 id="安装-ansible"><a href="#安装-ansible" class="headerlink" title="安装 ansible"></a>安装 ansible</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果报错 No such file or directory @ xxx, </span><br><span class="hljs-comment"># 大概率是因为设置了国内源，这是由于国内源没有同步某些包，要不再换个源，要不就：</span><br><span class="hljs-comment"># export HOMEBREW_BOTTLE_DOMAIN=&#x27;&#x27;</span><br><br>brew install ansible<br><br><span class="hljs-comment"># pip install ansible</span><br></code></pre></td></tr></table></figure><h4 id="基本文件"><a href="#基本文件" class="headerlink" title="基本文件"></a>基本文件</h4><h5 id="config-file"><a href="#config-file" class="headerlink" title="config file"></a>config file</h5><p>这是 ansible 的配置文件，会按照 $ANSIBLE_CFG、./ansible.cfg、~/.ansible.cfg、/etc/ansible/ansible.cfg 几个路径搜寻。</p><p>用来配置 ansible 的默认行为。常用的配置说明可以参考 <a href="https://blog.csdn.net/vipygd/article/details/101868144">ansible.cfg常用配置</a></p><p>也可以查看 <a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html">官方文档</a></p><p>我的一个简单的配置长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">[defaults]<br>remote_port = 22<br>remote_user = root<br>forks = 10<br>retry_files_save_path = /tmp/.ansible-retry<br><br>host_key_checking = False<br>deprecation_warnings = False<br>command_warnings = False<br>gathering = smart<br><br>inventory = inventory/hosts<br></code></pre></td></tr></table></figure><h5 id="inventory"><a href="#inventory" class="headerlink" title="inventory"></a>inventory</h5><p>这是要被管理的机器的配置，主要是 host 和连接方式的配置。<br>文件大概长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">[nfs]<br>10.10.10.4<br><br>[server_init]<br><br>[server]<br>10.10.10.5 ansible_ssh_user=root<br><br>[agent]<br>10.10.10.6<br>10.10.10.7<br><br>[remove_server]<br>10.10.10.5<br><br>[remove_agent]<br>10.10.10.6<br>10.10.10.7<br><br>[k3s:children]<br>server_init<br>server<br>agent<br><br></code></pre></td></tr></table></figure><p>更多用法可以查看 <a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html">官方文档</a></p><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><ul><li><p>执行一个简单的 shell 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible nfs  -m shell -a <span class="hljs-string">&#x27;uptime&#x27;</span><br><span class="hljs-comment"># 10.10.10.4 | CHANGED | rc=0 &gt;&gt;</span><br><span class="hljs-comment"># 11:57:12 up 418 days, 13:03,  1 user,  load average: 0.04, 0.04,  0.05</span><br></code></pre></td></tr></table></figure></li><li><p>打开调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 调试常用 debug 模块，可以定向打印出一些信息，自己学习的时候可以看更多的信息，用 -v 或 -vvv 打开 ansible 的日志。</span><br><br>ansible all  -m shell -a <span class="hljs-string">&#x27;uptime&#x27;</span> -vvv<br><br><span class="hljs-comment"># 一大堆信息，可以用于帮助理解 ansible 究竟干了啥</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="调试一下-template"><a href="#调试一下-template" class="headerlink" title="调试一下 template"></a>调试一下 template</h4><p>ansible 的 template 在 playbook 下使用，极大扩展了 ansible 的灵活性，有啥是一个模板解决不了的呢？毕竟模板意味着编程能力。</p><p>tempalte 使用的是 python 的 jinja2 作为模板语言。就开发而言，用模板生成内容有两种模式，通过编程拼接模板 和 在模板中编程，毫无疑问，ansible 是 在模板中编程 的路子。</p><p>template 需要两个主题： 模板、变量。</p><p>变量的来源在 ansible 中比较多，主要分为两类： 内置变量、用户生成变量。<br>变量的使用主要有两个方面： tempalte 中， task 的逻辑语句中。</p><ul><li><a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html">特殊变量官方文档</a></li><li><a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html">普通变量使用官方文档</a></li></ul><p>用户生成变量的地方主要有这么几个： <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#understanding-variable-precedence">参考官方文档</a></p><ul><li>在特定文件中生成，例如 inventory 文件、playbook文件、role文件等。</li><li>在命令行中传入 <code>--extra-vars xx=xxx xx2=xxxx</code> (简写为 <code>-e</code>)</li></ul><p>具体可以查看 <a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#where-to-set-variables">变量使用官方文档</a></p><p>写 ansible 的 playbook 需要两方面的核心知识：</p><ul><li>理解具体的业务逻辑，这样才能抽象出合适的 role </li><li>理解 ansible 的运行逻辑，主要包括 各配置文件及字段含义 ( <a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html">config字段</a> 、<a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html">palybook的字段</a>、 <a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html">inventory字段</a>)、<a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html">变量</a>、<a href="https://docs.ansible.com/ansible/latest/collections/all_plugins.html">plugin</a> (plugin极其重要，以后写配置时经常去里面查询各种字段含义)</li></ul><p>需要注意的是，ansible 新版本在 plugin/module 的使用上和之前 2.9 的版本有一些差别，主要是没有命名空间的概念，例如，都是使用 file 模块(管理远端文件及文件夹)，现在的版本是<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/file_module.html#ansible-collections-ansible-builtin-file-module">这样写</a>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">a</span> <span class="hljs-string">directory</span> <span class="hljs-string">if</span> <span class="hljs-string">it</span> <span class="hljs-string">does</span> <span class="hljs-string">not</span> <span class="hljs-string">exist</span><br>  <span class="hljs-attr">ansible.builtin.file:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/some_directory</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">directory</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">&#x27;0755&#x27;</span><br></code></pre></td></tr></table></figure><p>而 2.9 的版本是<a href="https://docs.ansible.com/ansible/2.9/modules/file_module.html#examples">这样写</a>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">a</span> <span class="hljs-string">directory</span> <span class="hljs-string">if</span> <span class="hljs-string">it</span> <span class="hljs-string">does</span> <span class="hljs-string">not</span> <span class="hljs-string">exist</span><br>  <span class="hljs-attr">file:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/some_directory</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">directory</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">&#x27;0755&#x27;</span><br></code></pre></td></tr></table></figure><p>看到这样的写法，找不到对应的字段说明先不要慌张，说明是 2.9 之前的版本，具体可以查看 <a href="https://docs.ansible.com/ansible/2.9/modules/list_of_files_modules.html">module index</a></p><p>为了简单调试，我们直接使用 命令行传入。;</p><p>使用了 <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#ansible-collections-ansible-builtin-template-module">template</a>、 <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/copy_module.html#examples">copy</a>、<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#examples">shell</a> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">send</span> <span class="hljs-string">files</span><br>  <span class="hljs-attr">ansible.builtin.copy:</span><br>    <span class="hljs-attr">src:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.src &#125;&#125;</span>&quot;</span><br>    <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.dest &#125;&#125;</span>&quot;</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.mode &#125;&#125;</span>&quot;</span><br>  <span class="hljs-attr">with_items:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">src:</span> <span class="hljs-string">&quot;test.sh&quot;</span>, <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;/tmp/longtest/test.sh&quot;</span> ,<span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;0755&quot;</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">src:</span> <span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;/tmp/longtest/hello.txt&quot;</span> ,<span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;0644&quot;</span> &#125;<br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">cat</span> <span class="hljs-string">run</span><br>  <span class="hljs-attr">ansible.builtin.shell:</span><br>    <span class="hljs-attr">cmd:</span> <span class="hljs-string">cat</span> <span class="hljs-string">/tmp/longtest/hello.txt</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">sh</span> <span class="hljs-string">run</span><br>  <span class="hljs-attr">ansible.builtin.shell:</span><br>    <span class="hljs-attr">cmd:</span> <span class="hljs-string">sh</span> <span class="hljs-string">/tmp/longtest/test.sh</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">template</span> <span class="hljs-string">send</span> <span class="hljs-string">files</span><br>  <span class="hljs-attr">ansible.builtin.template:</span><br>    <span class="hljs-attr">src:</span> <span class="hljs-string">pingpong.yaml.j2</span><br>    <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;/tmp/longtest/pingpong.yaml&quot;</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-number">0640</span><br></code></pre></td></tr></table></figure><p>以下是 templates/pingpong.yaml.j2 的一部分内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pingpong</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">config.yaml:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    app_name: &quot;pingpong&quot;</span><br><span class="hljs-string">    server:</span><br><span class="hljs-string">      port: 8080</span><br><span class="hljs-string">    log:</span><br><span class="hljs-string">      level: &quot;info&quot;</span><br><span class="hljs-string">    companyName: &quot;longtest&quot;</span><br><span class="hljs-string">    ping:</span><br><span class="hljs-string">      Enable: &#123;&#123;EXT_PINGPONG_ENABLE&#125;&#125;</span><br><span class="hljs-string">      CronPattern: &quot;0 */2 * * * *&quot;</span><br><span class="hljs-string">      Host: &quot;&quot;</span><br><span class="hljs-string">      Auth:</span><br><span class="hljs-string">        Enable: false</span><br></code></pre></td></tr></table></figure><p>运行以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible-playbook -e <span class="hljs-string">&#x27;EXT_GLOBAL_DOMAIN=https://longalong.cn EXT_PINGPONG_ENABLE=true&#x27;</span> ping.yaml  -vv<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs text">PLAYBOOK: ping.yaml **************************************************************************************************************************************************************************<br>1 plays in ping.yaml<br><br>PLAY [server] ********************************************************************************************************************************************************************************<br><br>TASK [Gathering Facts] ***********************************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/ping.yaml:2<br>ok: [101.42.240.235]<br><br>TASK [ping : ping test send files] ***********************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:2<br>ok: [101.42.240.235] =&gt; (item=&#123;&#x27;src&#x27;: &#x27;test.sh&#x27;, &#x27;dest&#x27;: &#x27;/tmp/longtest/test.sh&#x27;, &#x27;mode&#x27;: &#x27;0755&#x27;&#125;) =&gt; &#123;&quot;ansible_loop_var&quot;: &quot;item&quot;, &quot;changed&quot;: false, &quot;checksum&quot;: &quot;fd4ef272800af37c1e5a82235c4f1fdf35d10cfb&quot;, &quot;dest&quot;: &quot;/tmp/longtest/test.sh&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;item&quot;: &#123;&quot;dest&quot;: &quot;/tmp/longtest/test.sh&quot;, &quot;mode&quot;: &quot;0755&quot;, &quot;src&quot;: &quot;test.sh&quot;&#125;, &quot;mode&quot;: &quot;0755&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;path&quot;: &quot;/tmp/longtest/test.sh&quot;, &quot;size&quot;: 71, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;<br><br><br>ok: [101.42.240.235] =&gt; (item=&#123;&#x27;src&#x27;: &#x27;hello.txt&#x27;, &#x27;dest&#x27;: &#x27;/tmp/longtest/hello.txt&#x27;, &#x27;mode&#x27;: &#x27;0644&#x27;&#125;) =&gt; &#123;&quot;ansible_loop_var&quot;: &quot;item&quot;, &quot;changed&quot;: false, &quot;checksum&quot;: &quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;, &quot;dest&quot;: &quot;/tmp/longtest/hello.txt&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;item&quot;: &#123;&quot;dest&quot;: &quot;/tmp/longtest/hello.txt&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;src&quot;: &quot;hello.txt&quot;&#125;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;path&quot;: &quot;/tmp/longtest/hello.txt&quot;, &quot;size&quot;: 11, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;<br><br>TASK [ping : ping test cat run] **************************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:11<br><br><br>changed: [101.42.240.235] =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;cat /tmp/longtest/hello.txt&quot;, &quot;delta&quot;: &quot;0:00:00.053376&quot;, &quot;end&quot;: &quot;2023-02-15 15:01:48.824142&quot;, &quot;msg&quot;: &quot;&quot;, &quot;rc&quot;: 0, &quot;start&quot;: &quot;2023-02-15 15:01:48.770766&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;hello world&quot;, &quot;stdout_lines&quot;: [&quot;hello world&quot;]&#125;<br><br>TASK [ping : ping test sh run] ***************************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:15<br>changed: [101.42.240.235] =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;sh /tmp/longtest/test.sh&quot;, &quot;delta&quot;: &quot;0:00:00.055170&quot;, &quot;end&quot;: &quot;2023-02-15 15:01:51.329984&quot;, &quot;msg&quot;: &quot;&quot;, &quot;rc&quot;: 0, &quot;start&quot;: &quot;2023-02-15 15:01:51.274814&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;hi there, i am an ansible test now is 2023年 02月 15日 星期三 15:01:51 CST&quot;, &quot;stdout_lines&quot;: [&quot;hi there, i am an ansible test now is 2023年 02月 15日 星期三 15:01:51 CST&quot;]&#125;<br><br>TASK [ping : ping test template send files] **************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:19<br>changed: [101.42.240.235] =&gt; &#123;&quot;changed&quot;: true, &quot;checksum&quot;: &quot;c6f37e5b898f9bcd1033afe74751741eee722ab0&quot;, &quot;dest&quot;: &quot;/tmp/longtest/pingpong.yaml&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;50ad443f786f2ff265c5f967710a1103&quot;, &quot;mode&quot;: &quot;0640&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;size&quot;: 2755, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1676444511.604792-82491-153536252047673/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;<br><br>PLAY RECAP ***********************************************************************************************************************************************************************************<br>101.42.240.235             : ok=5    changed=3    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 <br></code></pre></td></tr></table></figure><h3 id="可视化管理工具-awx"><a href="#可视化管理工具-awx" class="headerlink" title="可视化管理工具 awx"></a>可视化管理工具 awx</h3><p>awx 是 ansible 的可视化管理工具，是 tower 的开源版。</p><p>不得不说，awx 的文档真的是有点……</p><p>还没跑通，回头再看下吧</p><p><a href="https://github.com/ansible/awx">awx github 地址</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>这篇文章可以看一下： <a href="https://docs.ansible.com/ansible/latest/tips_tricks/ansible_tips_tricks.html#playbook-tips">playbook-tips</a></li></ul><hr><blockquote><p>Don’t turn away from possible futures before you’re certain you don’t have anything to learn from them.<br>— <cite>Richard Bach</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>batch</tag>
      
      <tag>ansible</tag>
      
      <tag>批任务</tag>
      
      <tag>批处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常规的charts编写方式</title>
    <link href="/longblog/posts/22_11_22_00_15_normal_helm_charts.html"/>
    <url>/longblog/posts/22_11_22_00_15_normal_helm_charts.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用了 k8s 作为基础设施之后，就需要关心 <code>如何管理部署</code>，最原始的清单管理方式在 <code>多环境</code> 下就开始失效了，这个时候可以用 <a href="https://kubectl.docs.kubernetes.io/guides/introduction/kustomize/">customize</a> , 相当于有一个 base 的清单，不同环境的各自修改自己的，在部署前进行合并覆盖。</p><p>但如果你的应用更加复杂，拥有好几个服务，这时用清单管理就不太方便了，而用 helm charts 就是一个不错的方式。</p><h2 id="helm-charts"><a href="#helm-charts" class="headerlink" title="helm charts"></a>helm charts</h2><p>helm 的使用可以参考 <a href="/longblog/posts/22_11_03_15_06_simple_usage_of_helm.html" name="helm的一些简单使用" >helm的一些简单使用</a><br>也有简单的关于 <a href="/longblog/posts/22_11_03_15_06_simple_usage_of_helm.html#charts 组织方式" name="helm的一些简单使用" >helm charts 的简单介绍</a></p><p>helm charts 和 k8s 原生的清单相比，一部分职能相当于是 清单模板管理器，templates 目录下存放的，就是用 模板语法包裹起来的清单，最后渲染的结果，就是一份份的资源清单。</p><p>但 helm 通过模板语法，给清单增加了逻辑判断能力，极大地增加了清单的扩展性。</p><p>charts 的优点在于： 强大。 缺点在于： 有额外学习的成本。</p><h2 id="从清单的视角看-templates"><a href="#从清单的视角看-templates" class="headerlink" title="从清单的视角看 templates"></a>从清单的视角看 templates</h2><p>对于 k8s 清单，最常见的资源包括：</p><ul><li>持久类的 pvc</li><li>访问类的 service / ingress</li><li>服务类的 deployment / daemonset / statefulset</li><li>配置类的 configmap / secrets</li></ul><blockquote><p>更详细的资源参考 <a href="/longblog/posts/22_10_24_11_17_summary_of_kubectl.html#api-server" name="kubectl的一些总结" >kubectl的一些总结</a></p></blockquote><p>一个常见的服务，就包含上面这些。 如果服务中希望访问集群信息，可能还需要 ClusterRole 和 RoleBinding 用来绑定权限。</p><p>在 charts 的 templates 中，我们主要编写的也就是这些资源的模板。</p><h2 id="charts-的主要关注点"><a href="#charts-的主要关注点" class="headerlink" title="charts 的主要关注点"></a>charts 的主要关注点</h2><p>对于 charts 的编写过程，主要关注这几类事务：</p><ol><li>公共项 ( 镜像仓库、服务名、公共配置 )</li><li>勾稽关系类 ( 模块开关、service name 等 )</li></ol><p>一个抽象得当的 charts ，在同类型的业务应用服务中，通常可以直接复用，修改一下 values.yaml 即可使用。</p><h2 id="观摩三方charts"><a href="#观摩三方charts" class="headerlink" title="观摩三方charts"></a>观摩三方charts</h2><h3 id="minio"><a href="#minio" class="headerlink" title="minio"></a>minio</h3><ul><li>用 <code>_helpers.tpl</code> 定义了一些公共的名字，例如 minio.name</li><li>用 <code>_helpers.tpl</code> 做了 k8s 版本的判断，例如 minio.deployment.apiVersion</li><li>把 shell 脚本放到 template 中，相当于给 shell 加了一层 template，并在 configmap 中用 include 引入了 (这里加了 $.Template.BasePath)</li><li>在 clusterroles.yaml 中，有 .Capabilities 的使用，这个可以拿到 k8s 的信息</li><li>if 判断中，大量使用了 <code>and</code> <code>or</code> 操作</li><li>用了 helm 的 hook 做部署和更新时触发的 job </li><li>secrets.yaml 中使用了 base64 存储 accesskey</li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li>NOTES.txt 可以在部署完之后被看到</li></ul><h3 id="spinnaker"><a href="#spinnaker" class="headerlink" title="spinnaker"></a>spinnaker</h3><ul><li>templates 中的层级多了一层目录，区分不同类型的资源</li></ul><h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><ul><li>把 init.sql 放在了 charts 中，并且在 init-configmap.yaml 中通过 <code>(.Files.Glob &quot;init/*&quot;).AsConfig</code> 的方式把文件放到 configmap 中</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>charts 的写法都是基于 k8s 清单来的，所以，要写一个 charts ，第一步是把这个应用所需要的所有 manifest 写好，第二步是使用模板语法给特定申明项添加逻辑 (或判断、或取值)。</p><p>charts 的 template 语法还是需要学习和持续练习才能熟练掌握的，如果本身使用的不多，其实也可以先大体浏览一次官网，然后找一大堆的 charts 做参考，在真正要封装 charts 的时候，再对照着别人的 charts 改改，这或许是最高效的方式。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>charts 在绝大多数时候已经很够用了。 但在一些场景下，业务有特定领域的模型，如果还是按照 k8s manifest 的各个项，就增加了运维同学对相关概念的转换负担，这种时候就会使用另一个强大的武器： CRD + operator。具体可以参考 <a href="/notpublish/index.html" name="k8s的扩展点之一--CRD" >k8s的扩展点之一–CRD</a></p><hr><blockquote><p>You really can change the world if you care enough.<br>— <cite>Marian Wright Edelman</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>helm</tag>
      
      <tag>k8s</tag>
      
      <tag>charts</tag>
      
      <tag>template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单搞一波混沌测试</title>
    <link href="/longblog/posts/22_11_21_19_17_easy_test_of_chaos_monkey.html"/>
    <url>/longblog/posts/22_11_21_19_17_easy_test_of_chaos_monkey.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做提升私有部署稳定性的事，做了服务性能压测、磁盘压测等工作，但依然不太敢相信服务的稳定性，主要是因为私有部署时，服务除了问题要进行 debug 实在是太难了，所以不论为稳定性付出多少努力都是有道理的。</p><p>要提升服务的稳定性，需要从两个维度下手：</p><ul><li>服务本身的质量</li><li>基础设施的稳定性</li></ul><p>前者，一般通过 <code>手工测试</code>、<code>单元测试</code>、<code>接口测试</code>、<code>e2e测试</code>、<code>压测</code> 四种方式保证，其中，<code>手工测试</code>是最常用的；<code>单元测试</code>需要推动业务方去做，比较难搞；<code>接口测试</code>也需要推动业务方去做，比较难搞； <code>e2e 测试</code>仍然需要推动业务方去搞；压测在私有部署中也需要，但整体来看需求不大(一般私有部署的用户量不大，性能不会成为问题)……</p><p>目前，我们有手工测试和基本的接口测试。</p><p>后者，可以通过 <code>性能压测</code>、<code>稳定性测试</code>、<code>破坏性测试</code> 等方式进行，其中，<code>性能测试</code> 是最常用的，俗称 <code>压测</code>，压测可以针对中间件，例如 数据库、缓存中间件、消息队列等等，也可以针对基础设施的，比如 负载、磁盘、网络。 <code>稳定性测试</code> 是指对业务系统进行整体性的不定负载、长时间运行，为了测试业务系统在长时间运行过程中是否有内存泄漏等其他问题。 <code>破坏性测试</code> 是指模拟对系统进行故障注入，测试系统在一定故障场景下能否继续提供服务，并最终自行恢复的能力。</p><p>本期，我们仅探讨破坏性测试的一种通用方案 – 混沌测试。</p><h2 id="关于混沌测试"><a href="#关于混沌测试" class="headerlink" title="关于混沌测试"></a>关于混沌测试</h2><p>产生的背景： 服务(环境)越来越复杂，很难通过人工去判断会出现哪些问题、不会出现哪些问题，因此，服务的设计开始出现 <code>面向失败的设计</code> (design for failure) 的理念。实践中，一般通过一系列故障注入工具工具，对运行中的服务进行故障注入，通过验证系统是否能持续提供服务来判断服务的稳定性。整体测试和验证的方案，我们称之为 混沌测试。</p><p>混沌测试的内容，可以参考 <a href="https://chaos-mesh.org/zh/docs/basic-features/#%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5">chaos-mesh</a></p><p>混沌测试的核心，是 ① 破坏性故障注入  ② 检查故障影响范围  ③ 检查是否能自行恢复</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在调研中，发现两款流行的混沌测试方案：</p><ol><li>由 Netflix 开源的 <a href="https://github.com/Netflix/chaosmonkey">chaos-monkey</a></li><li>由 TiDB 开源的 <a href="https://chaos-mesh.org/zh/docs/">chaos-mesh</a></li></ol><p>两款工具在能力上相差不大，但 chaos-monkey 需要和 spinnaker 结合，而 chaos-monkey 有开箱即用的控制面板，为了快速实验，选择 chaos-monkey 作为混沌测试的工具。</p><p>整体的搭建过程，可以参考 <a href="https://chaos-mesh.org/zh/docs/production-installation-using-helm/">chao-mesh 官网</a></p><blockquote><p>集群搭建可以参考 <a href="/notpublish/index.html" name="记一次k3s环境搭建记录 或者 [[网络受限环境k3s安装记录]]" >记一次k3s环境搭建记录 或者 [[网络受限环境k3s安装记录]]</a></p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>todo</li></ul><hr><blockquote><p>Wrinkles should merely indicate where smiles have been.<br>— <cite>Mark Twain</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>chaos</tag>
      
      <tag>混沌测试</tag>
      
      <tag>质量保证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sharecard是什么？</title>
    <link href="/longblog/posts/22_11_16_12_05_what_is_share_card.html"/>
    <url>/longblog/posts/22_11_16_12_05_what_is_share_card.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>偶尔有一些社群里会每天分享一些带有金句的图片，有些是正能量的，有些是情感抒发的等等。</p><p>类似于这样：</p><p><img src="https://static.longalong.cn/img/20221116121238.png"></p><p>从实现上来看，很多都是由 设计 / 运营 同学制作一个 ps / sketch 模板，然后每天修改其中的文字和图片。</p><p>我也想每天早上看到这种能激活人，让人元气满满的图片，甚至希望能发给家人们，让他们也元气满满。但我懒，不想每天占用注意力去制作图片，于是想弄一个自动生成分享卡片的工具……</p><h2 id="简单展示"><a href="#简单展示" class="headerlink" title="简单展示"></a>简单展示</h2><p>你有一段话，想分享出去，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">你看不见我，不代表我不存在。你来与不来，我就在这里，讲述我的打工故事。<br><br>谁看见了不说一句社畜辛苦了呢。<br></code></pre></td></tr></table></figure><p>然后可以变成这样：</p><p><img src="https://static.longalong.cn/img/20221116121825.png"></p><p>或者使用图片，变成这样：</p><p><img src="https://static.longalong.cn/img/20221116121932.png"></p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>周末花了一天把基本 demo 搞出来了，勉强能用，更多信息可以看项目介绍： <a href="https://github.com/iamlongalong/sharecard">https://github.com/iamlongalong/sharecard</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>根据项目中的 todo 继续优化吧~</p><hr><blockquote><p>Be your own hero, it’s cheaper than a movie ticket.<br>— <cite>Doug Horton</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>sharecard</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的集群日志采集方案</title>
    <link href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html"/>
    <url>/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当一个程序运行时，为了掌握程序的运行情况，我们需要对程序进行日志采集。无论是传统的机器部署，还是基于 k8s 的服务部署，日志采集的整体逻辑是一样的： ① 日志落盘 ② 日志采集 ③ 日志处理 ④ 日志存储 ⑤ 日志展示 ⑥ 日志归档</p><p>本文，我们一起搭建一套简单的日志采集体系。</p><h2 id="日志流程"><a href="#日志流程" class="headerlink" title="日志流程"></a>日志流程</h2><h3 id="日志落盘"><a href="#日志落盘" class="headerlink" title="日志落盘"></a>日志落盘</h3><ul><li>传统部署</li></ul><p>传统服务运行时，可以通过将日志写到一个目录下的文件中。</p><blockquote><p>TODO: 跑通一个日志库的完整使用</p></blockquote><ul><li>k8s</li></ul><p>stdout 直接输出到容器日志文件</p><h3 id="日志采集"><a href="#日志采集" class="headerlink" title="日志采集"></a>日志采集</h3><ul><li>filebeat</li><li>fluent-bit/fluentd (详细见实操 <a href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html#实操" name="简单的集群日志采集方案" >简单的集群日志采集方案</a>)</li></ul><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><ul><li>logstash</li><li>fluent-bit</li></ul><h3 id="日志存储"><a href="#日志存储" class="headerlink" title="日志存储"></a>日志存储</h3><ul><li>es</li><li>loki</li></ul><h3 id="日志展示"><a href="#日志展示" class="headerlink" title="日志展示"></a>日志展示</h3><ul><li>kibana</li></ul><h3 id="日志归档"><a href="#日志归档" class="headerlink" title="日志归档"></a>日志归档</h3><ul><li>es-rotate (这块儿流程跑一下)</li></ul><h3 id="基于日志的告警"><a href="#基于日志的告警" class="headerlink" title="基于日志的告警"></a>基于日志的告警</h3><ul><li><a href="https://www.elastic.co/guide/en/kibana/current/alerting-getting-started.html">kibana-alert</a> (elastic watcher)</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><input disabled="" type="checkbox"> 找一套轻量的日志采集方案</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="fluentd-k8s-实操"><a href="#fluentd-k8s-实操" class="headerlink" title="fluentd k8s 实操"></a>fluentd k8s 实操</h3><p>由于集群的日志都会在当前机器的文件系统存放，所以实际上只需要起一个 fluentd 进程，并且能够读取日志目录即可。</p><p>如果在集群中，则需要以下操作： ① 启动 fluentd 的进程容器 ② 把 k8s 日志目录挂到容器中。 为了解决对 每台机器 的日志采集，需要采用部署中的 daemonset。</p><p>另外，由于一些插件可能会用到集群信息，需要给部署集绑定集群角色。</p><p>具体可以查看： <a href="https://docs.fluentd.org/quickstart">fluentd 的官方文档</a></p><p>实际的部署文件如下： (参考<a href="https://github.com/fluent/fluentd-kubernetes-daemonset">官方案例</a>)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;namespaces&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;pods&quot;</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;get&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;watch&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;list&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">input.conf:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    &lt;source&gt;</span><br><span class="hljs-string">      @type tail</span><br><span class="hljs-string">      tag k8s.fluentd.log.*</span><br><span class="hljs-string">      path /var/log/containers/*.log</span><br><span class="hljs-string">      pos_file /var/log/k8s.fluentd.log.pos</span><br><span class="hljs-string">      refresh_interval 3s</span><br><span class="hljs-string">      read_from_head true</span><br><span class="hljs-string">      rotate_wait 30s</span><br><span class="hljs-string">      &lt;parse&gt;</span><br><span class="hljs-string">        @type regexp</span><br><span class="hljs-string">        expression ^(?&lt;time&gt;[^ ]+) (?&lt;stream&gt;stdout|stderr) (?&lt;logtag&gt;[^ ]*) (?&lt;log&gt;.*)$</span><br><span class="hljs-string">        time_type string</span><br><span class="hljs-string">        time_format %Y-%m-%dT%H:%M:%S.%N%z</span><br><span class="hljs-string">        localtime true</span><br><span class="hljs-string">        keep_time_key true</span><br><span class="hljs-string">      &lt;/parse&gt;</span><br><span class="hljs-string">    &lt;/source&gt;</span><br><span class="hljs-string"></span><br>  <span class="hljs-comment"># 这些都是根据自己的情况配置，可以输出到文件、到es、到kafka、到logstash等,具体配置可以查看 [官方文档](https://docs.fluentd.org/output/file)</span><br>  <span class="hljs-attr">output.conf:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    &lt;match k8s.**&gt;</span><br><span class="hljs-string">      @type file</span><br><span class="hljs-string">      path /xxx/log</span><br><span class="hljs-string">      add_path_suffix true</span><br><span class="hljs-string">      path_suffix &quot;.log&quot;</span><br><span class="hljs-string">      append true</span><br><span class="hljs-string">      &lt;format&gt;</span><br><span class="hljs-string">        @type json</span><br><span class="hljs-string">      &lt;/format&gt;</span><br><span class="hljs-string">      &lt;buffer tag&gt;</span><br><span class="hljs-string">        @type file</span><br><span class="hljs-string">        path /xx/log/fluentd.log.buffer</span><br><span class="hljs-string">        chunk_limit_size 8MB</span><br><span class="hljs-string">        total_limit_size 64MB</span><br><span class="hljs-string">        flush_mode interval</span><br><span class="hljs-string">        flush_interval 1s</span><br><span class="hljs-string">        retry_max_interval 30</span><br><span class="hljs-string">        retry_forever true</span><br><span class="hljs-string">        flush_thread_count 4</span><br><span class="hljs-string">      &lt;/buffer&gt;</span><br><span class="hljs-string">    &lt;/match&gt;</span><br><span class="hljs-string"></span><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-attr">seccomp.security.alpha.kubernetes.io/pod:</span> <span class="hljs-string">&#x27;docker/default&#x27;</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">system-node-critical</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">fluentd</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">fluent/fluentd-kubernetes-daemonset:v1.15-debian-forward-amd64-1</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">FLUENTD_ARGS</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">--no-supervisor</span> <span class="hljs-string">-q</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">3Gi</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">100Mi</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/fluent/config.d</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">outputlog</span><br>          <span class="hljs-attr">mountPath:</span> &#123;&#123; <span class="hljs-string">EXT_K3S_LOG_PATH</span> &#125;&#125;<br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">outputlog</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> &#123;&#123; <span class="hljs-string">EXT_K3S_LOG_PATH</span> &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="fluentbit-k8s-实操"><a href="#fluentbit-k8s-实操" class="headerlink" title="fluentbit k8s 实操"></a>fluentbit k8s 实操</h3><p>fluentd 是一个 ruby + c 的实现，可能还是有些问题吧，主要是多了一些系统依赖，于是又搞了一个 纯c 写的 fluentbit， 这有<a href="https://docs.fluentbit.io/manual/about/fluentd-and-fluent-bit">官方文档</a>写的两者的关系和差别。 fluentd 的缺点是有 ruby 的环境依赖，优点是拥有 1000+ plugins。 fluentbit 的缺点是目前仅有 70+ 插件，优点是无环境依赖，一个二进制就可以跑。</p><p>k8s 使用 helm 部署，可以直接参考 <a href="https://docs.fluentbit.io/manual/installation/kubernetes">官方文档</a>， 这是默认的 <a href="https://github.com/fluent/helm-charts/blob/main/charts/fluent-bit/values.yaml">values.yaml</a></p><p>对于一个日志采集器而言，主要就是配置这么几个环节(管道)：</p><ul><li><a href="https://docs.fluentbit.io/manual/pipeline/inputs">input</a>: 用于配置从何处采集日志，例如文件夹、http、mqtt 等等</li><li><a href="https://docs.fluentbit.io/manual/pipeline/parsers/json">parser</a>: 处理拿到的日志格式，例如 把 docker 日志处理成 json、把 ng 日志处理成 json 等等。</li><li><a href="https://docs.fluentbit.io/manual/pipeline/filters/modify">filter</a>: 过滤操作，可以修改、添加一些信息，例如加 pod name 之类的。</li><li><a href="https://docs.fluentbit.io/manual/pipeline/outputs/elasticsearch">output</a>: 日志的输出，可以是 kafka、file、es、nats </li></ul><p>值得一提的是，fluentbit 支持用 golang build 成 lib 的方式，具体可以参考 <a href="https://docs.fluentbit.io/manual/development/golang-output-plugins">官方文档</a></p><hr><blockquote><p>Life is really simple, but we insist on making it complicated.<br>— <cite>Confucius</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>operation</tag>
      
      <tag>云原生</tag>
      
      <tag>k8s</tag>
      
      <tag>log</tag>
      
      <tag>日志</tag>
      
      <tag>elk</tag>
      
      <tag>efk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis实验环境搭建</title>
    <link href="/longblog/posts/22_11_11_21_24_redis_enviroment.html"/>
    <url>/longblog/posts/22_11_11_21_24_redis_enviroment.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>redis 作为一个非常非常常用的缓存中间件，几乎应用于市面上 90% 以上的互联网公司。我们在学习 redis 时，需要环境来做实验，因此，记录搭建一下 redis 的环境，用作 handbook。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>本地的 redis 搭建直接参考 <a href="https://github.com/iamlongalong/redis-instances">redis-instances</a> 即可，以下是项目的简介：</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>当我想要在本地用 redis cluster 做测试时，自然而然想到起个 docker ，但在 mac 上，这却非常难搞。</p><p>一番各种尝试之后，对其中的恶心深恶痛绝，遂希望建个小工具库，一来自己可以快速启动测试环境，二来也可以帮助遇到同样问题的码友们不遭受此罪，能把精力放到真正有价值的事上。</p><p>这是为了本地测试 redis cluster 而使用 docker-compose 启动的 6 节点 redis cluster。</p><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><p>先执行 <code>./prepare.sh</code> ，这是为了准备 config 文件和 data 目录<br>再执行 <code>./run.sh</code>, 这将会启动 6 个 docker 容器，并将端口映射到主机<br>然后执行 <code>./cluster.sh</code>， 这会将 6 个节点组成 3主3从 的集群<br>当你确认不再使用后，使用 <code>./remove.sh</code> 删掉所有信息<br>redis 使用的官方的 6.0 版本。</p><p>组建好集群后，对集群进行验证：</p><p><code>redis-cli -c cluster info</code><br><code>redis-cli -c cluster nodes</code><br>如果要自己重新配置 <code>redis.conf</code>, 有以下需要注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">1. daemonize no    # 这个是 redis 后台运行的配置，docker 启动时不能后台运行，否则容器会退出导致启动失败<br>2. port $&#123;PORT&#125;    # 为了批量生成 redis.conf ， 使用了 envsubst 来渲染文件，如果使用不同 port ，则需要改成这样<br>3. dir &quot;/data&quot;     # 数据文件存放位置， 对应 docker-compose 中的 volume 挂载<br>4. logfile &quot;/data/redis.log&quot;  # 日志文件<br>5. bind &quot;0.0.0.0&quot;  # 需要暴露 port ，否则会组建集群失败<br>6. cluster‐enabled yes  # 集群模式需要打开该配置<br>7. cluster‐config‐file nodes.conf  # 集群信息文件，改不改名都可以，但默认为 nodes-6379.conf 容易误导<br>8. protected‐mode no  # 要外部访问，就需要把该模式关掉<br>9. appendonly yes   # 开启 aof 模式<br></code></pre></td></tr></table></figure><h3 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h3><p>docker 网络有几种模式，默认的是 bridge 模式，这种模式下，所有容器网络均由 docker0 这个网桥分配，容器相互访问可以通过 docker0 网桥转发。 一种是 host 网络，用的是主机网卡。 一种是 容器网络，可以多个容器共用一个网络空间，k8s 的 pause 容器就起这个作用。还有 overlay 网络、自定义网络(自定义的ip段等)。 我们最常用的是 bridge 网络，但这样有个问题，ip 的变动会导致一些有状态服务出问题。 于是，其中一种解决方法是 <code>--link</code> 模式，类似于给一个网络空间下加入了 服务名 ，可以解析到对应的 ip，但这种方式用起来比较麻烦。 另一种解决方案是 自定义网络，在指定了 subnet 之后，可以指定特定的 ip ，也可以指定 服务名，在存在多个服务时，是很常用的方式。 如果端口不冲突，使用同一个 <code>hostname</code> 也是不错的选择，例如 <code>--network=container:nginx01</code>。</p><p>在 redis-cluster 的场景中，我们有两个需求： </p><p>① 每个 redis 实例之间均可以通信<br>② 外部能访问每个 redis 实例。 前者是为了组集群，后者是为了外部访问。</p><p>这两个条件，有如下方案可行：</p><ol><li>直接使用 <code>host network</code>，每个 redis 实例使用不同端口。</li><li>直接使用 bridge 网络，通过 ip 访问，为了保证 脚本的确定性，可以使用自定义网络，并且指定 ip。</li></ol><p>这两种方案在 linux 下均可。</p><p>在 mac 上，由于实现方式的不同， mac 上无法直接访问 containerIP , 也无法使用 host network，可以参考 <a href="https://github.com/docker/for-mac/issues/2670">docker/for-mac#2670</a> ， 所以在 mac 上就行不通了。</p><p>为了直接使用主机网络，有四种方案可以尝试：</p><p>直接在宿主机上运行 redis 进程，并使用不同端口。<br>使用 <code>-p</code> 暴露端口，并配置 subnet 指定容器 ip 和宿主机相同(多个容器共用，或者封装特定的多redis进程的镜像)。</p><p>配置 ss 进行代理，对特定网段的网络请求转发到由 ss 代理的 docker 网络中。<br>修改 redis-cluster 的组集群 ip 获取，改由环境变量传入。</p><p>这几种方式权衡下来，还是觉得直接在宿主机上运行 redis-cluster 的成本最低。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>既然做了 redis-cluster 的本地集群组建，那么回头再增加一些其他类型的资源组建，为他人学习、测试等提供便利。</p><ul><li><input checked="" disabled="" type="checkbox"> redis 主从组建 ✅ 2022-11-11</li><li><input checked="" disabled="" type="checkbox"> k8s 下的 redis 搭建 ✅ 2022-11-11</li><li><input checked="" disabled="" type="checkbox"> k8s 下的 redis-cluster 搭建 ✅ 2022-11-11</li><li><input disabled="" type="checkbox"> 增加 redis 性能测试的实验</li><li><input disabled="" type="checkbox"> redis 使用上的一些事儿</li></ul><hr><blockquote><p>Avoid having your ego so close to your position that when your position falls, your ego goes with it.<br>— <cite>Colin Powell</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>redis-cluster</tag>
      
      <tag>实验</tag>
      
      <tag>环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nfs、localpath作为k8s-storage-class</title>
    <link href="/longblog/posts/22_11_11_20_48_k8s_nfs_storage_class.html"/>
    <url>/longblog/posts/22_11_11_20_48_k8s_nfs_storage_class.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>k8s 作为一个容器调度和管理平台，在无状态的应用调度上有着非常强大的能力。如果我们希望有状态服务也能在 k8s 中运行，那么，在存储上，就需要使用 storage class。</p><h2 id="localpath"><a href="#localpath" class="headerlink" title="localpath"></a>localpath</h2><p>当我们使用 k3s 时，默认会提供 localpath 的 <a href="https://github.com/rancher/local-path-provisioner">storage class</a>。 如果要在 k8s 上安装，可以这么操作</p><ul><li><p>拉取资源清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.23/deploy/local-path-storage.yaml<br></code></pre></td></tr></table></figure></li><li><p>部署资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认挂载地址为 /opt/local-path-provisioner, 可自行更改</span><br><span class="hljs-comment"># k3s 自带provisioner默认地址为 /var/lib/rancher/k3s/storage</span><br>kubectl apply -f local-path-storage.yaml<br></code></pre></td></tr></table></figure></li><li><p>测试部署一下</p><blockquote><p>参考 <a href="/longblog/posts/22_11_11_21_24_redis_enviroment.html" name="redis实验环境搭建" >redis实验环境搭建</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加 bitnami 的 charts 库</span><br>helm repo add bitnami https://charts.bitnami.com/bitnami<br><span class="hljs-comment"># 拉取 redis 的 chart</span><br>helm fetch bitnami/redis --untar<br></code></pre></td></tr></table></figure></li><li><p>修改 redis 持久化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim redis/values.yaml<br><span class="hljs-comment">#修改 sc</span><br>storageClass: <span class="hljs-string">&quot;rancher.io/local-path&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>部署应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm install redis redis/<br></code></pre></td></tr></table></figure></li><li><p>查看服务情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@prichaos002 ~]<span class="hljs-comment"># kg svc</span><br>NAME             TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE<br>kubernetes       ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP    106m<br>redis-headless   ClusterIP   None           &lt;none&gt;        6379/TCP   2m38s<br>redis-master     ClusterIP   10.43.29.39    &lt;none&gt;        6379/TCP   2m38s<br>redis-replicas   ClusterIP   10.43.83.221   &lt;none&gt;        6379/TCP   2m38s<br><br>[root@prichaos002 ~]<span class="hljs-comment"># kgp</span><br>NAME               READY   STATUS    RESTARTS   AGE<br>redis-master-0     1/1     Running   0          2m41s<br>redis-replicas-0   1/1     Running   0          2m41s<br></code></pre></td></tr></table></figure></li><li><p>查看持久化情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@prichaos002 ~]<span class="hljs-comment"># kg sc</span><br>NAME                   PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE<br>local-path (default)   rancher.io/local-path   Delete          WaitForFirstConsumer   <span class="hljs-literal">false</span>                  107m<br><br>[root@prichaos002 ~]<span class="hljs-comment"># kg pv</span><br>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                 STORAGECLASS   REASON   AGE<br>pvc-57b88546-33f4-4b01-a777-ad634a8fcc19   8Gi        RWO            Delete           Bound    default/redis-data-redis-replicas-0   local-path              68m<br>pvc-784fdcdd-bd97-4a56-8775-a919ab90184c   8Gi        RWO            Delete           Bound    default/redis-data-redis-master-0     local-path              3m9s<br><br>[root@prichaos002 ~]<span class="hljs-comment"># kg pvc</span><br>NAME                          STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>redis-data-redis-replicas-0   Bound    pvc-57b88546-33f4-4b01-a777-ad634a8fcc19   8Gi        RWO            local-path     68m<br>redis-data-redis-master-0     Bound    pvc-784fdcdd-bd97-4a56-8775-a919ab90184c   8Gi        RWO            local-path     3m13s<br></code></pre></td></tr></table></figure></li><li><p>查看实际磁盘情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@prichaos002 ~]<span class="hljs-comment"># tree /var/lib/rancher/k3s/storage</span><br>/var/lib/rancher/k3s/storage<br>├── pvc-57b88546-33f4-4b01-a777-ad634a8fcc19_default_redis-data-redis-replicas-0<br>│   ├── appendonlydir<br>│   │   ├── appendonly.aof.2.base.rdb<br>│   │   ├── appendonly.aof.2.incr.aof<br>│   │   └── appendonly.aof.manifest<br>│   └── dump.rdb<br>└── pvc-784fdcdd-bd97-4a56-8775-a919ab90184c_default_redis-data-redis-master-0<br>    └── appendonlydir<br>        ├── appendonly.aof.1.base.rdb<br>        ├── appendonly.aof.1.incr.aof<br>        └── appendonly.aof.manifest<br><br>4 directories, 7 files<br></code></pre></td></tr></table></figure></li></ul><h2 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h2><p>在 k8s 中，所有提供存储能力的组件，实际都是一套实现了 CSI (容器存储接口) 的程序。如果要使用 nfs 作为存储能力提供者，也同样要这么一个实现了接口的程序。</p><ul><li>创建 nfs server</li></ul><p>参考 <a href="/longblog/posts/22_10_20_16_40_operation_record_of_nfs_server_and_client.html" name="一次nfs实操记录" >一次nfs实操记录</a></p><ul><li>可以使用 <a href="https://github.com/helm/charts/tree/master/stable/nfs-client-provisioner">helm</a> 创建，也可以直接写清单创建 </li></ul><blockquote><p>有一些坑可以参考 参考 <a href="https://blog.51cto.com/coderaction/5252351">nfs-provisioner</a></p></blockquote><ul><li><p>查看 sc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@prichaos002 ~]<span class="hljs-comment"># kg sc</span><br>NAME                   PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE<br>local-path (default)   rancher.io/local-path   Delete          WaitForFirstConsumer   <span class="hljs-literal">false</span>                  132m<br>managed-nfs-storage    nfs/provisioner         Delete          Immediate              <span class="hljs-literal">false</span>                  39s<br></code></pre></td></tr></table></figure></li><li><p>修改 redis storageclass</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">storageClass:</span> <span class="hljs-string">&quot;nfs-client&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>在新的 namespace 创建 redis </p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm install redis-nfs --namespace redisnfs --create-namespace redis/<br></code></pre></td></tr></table></figure><ul><li><p>查看 sc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@prichaos002 ~]<span class="hljs-comment"># kg sc</span><br>NAME                   PROVISIONER                                    RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE<br>local-path (default)   rancher.io/local-path                          Delete          WaitForFirstConsumer   <span class="hljs-literal">false</span>                  175m<br>nfs-client             cluster.local/nfsprovisioner-nfs-provisioner   Delete          Immediate              <span class="hljs-literal">true</span>                   6m5s<br></code></pre></td></tr></table></figure></li><li><p>查看 nfs 下的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@prichaos002 data]<span class="hljs-comment"># tree nfs/</span><br>nfs/<br>├── redisnfs-redis-data-redis-nfs-master-0-pvc-54312889-47cd-45ac-8cc9-582cfb57aedc<br>│   └── appendonlydir<br>│       ├── appendonly.aof.1.base.rdb<br>│       ├── appendonly.aof.1.incr.aof<br>│       └── appendonly.aof.manifest<br>└── redisnfs-redis-data-redis-nfs-replicas-0-pvc-a61c1d54-c38c-4db7-80db-39a2bc4d1715<br>    └── appendonlydir<br>        ├── appendonly.aof.1.base.rdb<br>        ├── appendonly.aof.1.incr.aof<br>        └── appendonly.aof.manifest<br><br>4 directories, 6 files<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>更详细的信息，可以参考 <a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">nfs-provisioner</a></p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上两种是最简单的 k8s 持久化方式。当然，如果在公有云上，则有公有云提供的各种存储方案，例如 阿里云的 nas 等。</p><p>上述两种均为集中式的存储方案，还有一些分布式的存储方案，后续可以记录一下，例如： rook、 longhorn、ceph 等等。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>存储插件是可扩展的，其拓展方式有两种：  CSI 和 FlexVolume，一些简单介绍可以查看 <a href="https://blog.csdn.net/qq_34556414/article/details/120167155">存储插件 FlexVolume</a></p><hr><blockquote><p>Happiness resides not in possessions, and not in gold, happiness dwells in the soul.<br>— <cite>Democritus</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>云原生</tag>
      
      <tag>k8s</tag>
      
      <tag>k3s</tag>
      
      <tag>nfs</tag>
      
      <tag>存储</tag>
      
      <tag>storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给sshw增加scp能力</title>
    <link href="/longblog/posts/22_11_07_16_21_power_sshw_with_scp.html"/>
    <url>/longblog/posts/22_11_07_16_21_power_sshw_with_scp.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>运维侧的工作中，非常频繁地使用 terminal，经常需要往服务器上拷贝文件，或者把服务器上文件拿到本地。</p><p>以往是直接使用 ssh <a href="mailto:&#117;&#x73;&#101;&#x72;&#x40;&#120;&#120;&#x2e;&#120;&#x78;&#46;&#120;&#120;&#x2e;&#x78;&#120;">&#117;&#x73;&#101;&#x72;&#x40;&#120;&#120;&#x2e;&#120;&#x78;&#46;&#120;&#120;&#x2e;&#x78;&#120;</a> 的方式登录机器终端，但记住 ip 是不容易的，因此使用了 ssh config，文件大致是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Host</span> <span class="hljs-string">rebig</span><br>  <span class="hljs-string">HostName</span> <span class="hljs-string">xx.xx.xx.xx</span><br>  <span class="hljs-string">User</span> <span class="hljs-string">root</span><br>  <span class="hljs-string">Port</span> <span class="hljs-number">8522</span><br><span class="hljs-string">Host</span> <span class="hljs-string">big</span><br>  <span class="hljs-string">HostName</span> <span class="hljs-string">xxx.xx.x.xx</span><br>  <span class="hljs-string">ProxyCommand</span> <span class="hljs-string">nc</span> <span class="hljs-string">-X</span> <span class="hljs-number">5</span> <span class="hljs-string">-x</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:1086</span> <span class="hljs-string">%h</span> <span class="hljs-string">%p</span><br>  <span class="hljs-string">User</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>一开始还挺好，但随着管理的机器越来越多，这种方法也很难搞，因为记不住名字！！</p><h2 id="sshw"><a href="#sshw" class="headerlink" title="sshw"></a>sshw</h2><p>经过调研，发现了 <a href="https://github.com/yinheli/sshw">sshw</a> ，国内一哥们儿发起的，主要的能力是：</p><ul><li>自动输入密码</li><li>ssh 跳板</li><li>机器分组</li><li>机器选择</li><li>连接后执行命令</li></ul><p>都是非常实用的能力，用着非常舒服。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>日常登录服务器没啥问题，但当我想要使用 scp 进行文件拷贝的时候，还是需要去复制地址和密码，用得少还能接受，但最近因为一些工作，需要经常使用 scp，老的方式就有点不太好接受了。</p><p>因此，决定给 sshw 增加子命令 scp</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li>需要保证和 sshw 很好地融合，不会显得很突兀</li><li>sshw 的跳板机制非常棒，需要用上</li><li>sshw 的节点选择非常友好，需要用上</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>代码的实现可以看 <a href="https://github.com/iamlongalong/sshw">https://github.com/iamlongalong/sshw</a></p><h2 id="展示一波"><a href="#展示一波" class="headerlink" title="展示一波"></a>展示一波</h2><p><img src="https://raw.githubusercontent.com/iamlongalong/sshw/master/assets/sshw-scp-demo.gif" alt="demo of sshw scp"></p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>目前，这个 scp 仅实现了最简单的 拷贝文件，但工作中，常有需要拷贝目录的情况，因此希望增加目录拷贝能力。</p><p>另外，一些大文件的拷贝过程比较慢，如果没有进度条的话……就等着抓狂吧😖……，因此希望增加拷贝的进度条。</p><ul><li><input checked="" disabled="" type="checkbox"> 增加拷贝进度条 ✅ 2022-11-08</li><li><input disabled="" type="checkbox"> 增加目录拷贝 (再看吧，需求多了再弄)</li></ul><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>过程中有几个有意思的收获：</p><ul><li>golang 命令行选择工具 <a href="https://github.com/manifoldco/promptui">promptui</a></li><li>golang 命令行进度条 <a href="https://github.com/schollz/progressbar">progressbar</a></li><li>golang 自动打包的方案 <a href="https://goreleaser.com/quick-start/">goreleaser</a> </li><li>真正用上了 terminal 录制工具 terminal，其他可以参考 <a href="/longblog/posts/22_10_21_11_33_resolve_terminal_screen_record.html" name="解决终端录制问题" >解决终端录制问题</a></li></ul><hr><blockquote><p>A man’s growth is seen in the successive choirs of his friends<br>— <cite>Ralph Waldo Emerson</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>terminal</tag>
      
      <tag>devops</tag>
      
      <tag>scp</tag>
      
      <tag>ssh</tag>
      
      <tag>sshw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能工程的储备知识</title>
    <link href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html"/>
    <url>/longblog/posts/22_11_06_02_14_knowledges_of_performance.html</url>
    
    <content type="html"><![CDATA[<p>压测需要很多的储备知识，例如：</p><ol><li>基础设施层<ul><li>硬件(cpu、disk、mem)</li><li>网络(tcp/ip、丢包、抓包、routes)</li><li>操作系统</li><li>容器、容器调度平台(docker、containerd、k8s、helm、kubectl)</li></ul></li><li>云平台 (熟悉阿里云控制台)</li><li>基础服务层<ul><li>关系数据库<ul><li>表结构设计</li><li>索引原理及命中分析</li><li>explain及执行计划优化</li><li>死锁日志排查</li><li>(将来)数据库分表设计及方案</li><li>nosql 数据库<ul><li>表结构设计(字段设计)</li><li>索引原理及命中分析</li><li>分片原理及查询分析</li></ul></li><li>缓存数据库<ul><li>数据结构实现原理及适用场景</li><li>数据结构性能</li><li>redis分片原理</li><li>redis监控分析</li></ul></li><li>消息队列<ul><li>kafka高性能原理及相关配置</li><li>幂等性问题及预防</li><li>消息持久问题及消息丢失预防</li><li>kafka心跳维持机制及commit机制</li><li>Kafka partition分配机制</li><li>Kafka topic对性能的影响</li></ul></li><li>搜索服务<ul><li>es索引原理</li><li>es分片方案及聚合方案</li><li>es索引设计</li><li>es分词方案</li><li>es查询打分机制</li><li>异构数据同步方案(logstash、canal)</li><li>es接口操作</li></ul></li><li>日志服务<ul><li>日志体系（elk、efk）</li><li>kibana看板操作熟练</li></ul></li><li>apm服务<ul><li>tracing</li></ul></li><li>监控服务<ul><li>exporter各类指标含义</li><li>prometheus查询语言熟练</li><li>grafana看板操作熟练</li></ul></li></ul></li></ul></li><li>测试工具<ul><li>数据库 benchmark 工具<ul><li>YCSB (HBASE、mongodb、redis、Cassandra等)</li><li>redis-benchmark</li><li>mysqlslap、tpcc</li><li>pgbench、pgbench-tools</li><li>kafka-producer-perf-test.sh</li></ul></li><li>通用 http 请求压测工具<ul><li>ab、wrk、go-stress-testing</li><li>jmeter、metersphere、pts</li><li>postman、loadRunner、locust</li><li>k6</li></ul></li><li>通用 rpc 请求压测工具<ul><li>k6、jmeter</li></ul></li><li>通用 ws 请求压测工具<ul><li>k6</li></ul></li><li>通用 网络、磁盘、cpu 压测工具<ul><li>Iperf</li><li>fio、dd</li><li>memtester</li><li>sysbench、stress</li></ul></li><li>混沌测试工具<ul><li>chaos monkey</li></ul></li><li>各业务专用压测工具</li></ul></li><li>监控工具<ul><li>系统监控工具<ul><li>通用监控工具<ul><li>Top</li><li>Htop</li><li>Glances</li><li>nmon</li><li>netdata</li><li>Sysstat</li><li>dstat</li></ul></li></ul></li><li>磁盘监控<ul><li>Iostat</li><li>Iotop</li></ul></li><li>网络监控<ul><li>nethogs</li><li>iftop</li><li>Netstat</li><li>Ss</li></ul></li><li>cpu监控<ul><li>Vmstat</li><li>Uptime</li><li>pidstat</li><li>(锁监控、缓存命中监控)</li></ul></li><li>内存监控<ul><li>free</li></ul></li><li>进程监控<ul><li>ps</li></ul></li><li>容器系统监控工具<ul><li>Pod exporter(暂时用的cadvisor)</li></ul></li><li>服务监控工具<ul><li>服务 exporter</li></ul></li></ul></li></ol><p>文档直通车：</p><ul><li><a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html" name="WIP-kafka的高吞吐原因" >WIP-kafka的高吞吐原因</a></li><li><a href="/longblog/posts/22_11_06_01_47_some_thought_of_performance.html" name="压测的一些思考" >压测的一些思考</a></li><li><a href="/longblog/posts/22_11_06_01_49_some_thought_about_performance.html" name="关于压测本身的梳理" >关于压测本身的梳理</a></li><li><a href="/longblog/posts/21_12_02_how_to_do_load_test.html" name="如何做好压测" >如何做好压测</a></li><li><a href="/notpublish/index.html" name="简单的性能测试方案" >简单的性能测试方案</a></li><li><a href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html" name="关于磁盘和网络的性能的问题" >关于磁盘和网络的性能的问题</a></li><li><a href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html" name="记一次服务性能的调优排查" >记一次服务性能的调优排查</a></li></ul><hr><blockquote><p>Friendship is an arrangement by which we undertake to exchange small favors for big ones.<br>— <cite>Montesquieu</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>性能</tag>
      
      <tag>压测</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于压测本身的梳理</title>
    <link href="/longblog/posts/22_11_06_01_49_some_thought_about_performance.html"/>
    <url>/longblog/posts/22_11_06_01_49_some_thought_about_performance.html</url>
    
    <content type="html"><![CDATA[<h3 id="整体分类"><a href="#整体分类" class="headerlink" title="整体分类"></a>整体分类</h3><p>目前来看，压测可以分为这四类：</p><ol><li>业务无关的中间件压测</li><li>业务有关的中间件压测</li><li>基于 http 的业务压测</li><li>其他类型的业务压测</li></ol><h3 id="业务无关的中间件压测"><a href="#业务无关的中间件压测" class="headerlink" title="业务无关的中间件压测"></a>业务无关的中间件压测</h3><h5 id="为什么要做？"><a href="#为什么要做？" class="headerlink" title="为什么要做？"></a>为什么要做？</h5><p>一个业务系统中，会使用到很多中间件，例如 kafka、mongodb、mysql、redis、etcd 等等，往往这些中间件都承载着非常重要的职责，有些是作为 数据存储/管理，有些作为 消息传递，有些作为 状态维护，因此，这些中间件本身的 稳定性、性能 是一个会明显对业务系统有较大影响的存在。</p><p>当我们需要验证系统的稳定性和性能时，中间件就是不可避免要关注的部分。</p><p>一般来说，常用的流行开源中间件，只要使用场景得当，性能和稳定性不会是大问题，另外，在万物上云的大背景下，这类中间件会由云厂商提供 SLA，稳定性上有保证。因此，对中间件压测的优先级往往会放得比较低，再加上任务紧，到最后，也基本都不会再单独做中间件的压测 (基本会和业务压测一起就验证了)。</p><p>上面的方法在很多情况下是没啥大问题的。但如果要做中间件性能优化，则必须要知道 benchmark 的值，再对比业务压测结果，找到优化方向。</p><h5 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h5><ul><li>工具体系</li><li>指导手册</li></ul><h4 id="业务有关的中间件压测"><a href="#业务有关的中间件压测" class="headerlink" title="业务有关的中间件压测"></a>业务有关的中间件压测</h4><h5 id="为什么要做？-1"><a href="#为什么要做？-1" class="headerlink" title="为什么要做？"></a>为什么要做？</h5><ol><li>如果做了业务无关的中间件压测了，还有必要做业务有关的中间件压测吗？</li></ol><p>当然要，这样才能认识到真实业务场景中对中间件的需求如何。业务中的使用方式形态各异，往往和我们使用 benchmark 得到的数据有很大差异，业务有关的压测才能更加真实反映出中间件的容量。<br>另外，通过对 benchmark 和 业务压测数据 反复做比较，才更容易得出 “为什么业务使用方式下的性能差这么多” 的答案。</p><ol start="2"><li>如果做了业务压测，还有必要做业务有关的中间件压测吗？</li></ol><p>不一定，如果这个中间件仅用于做过的业务，那么不做单独的压测，问题也不大。如果这个中间件被多个业务使用，那么只要业务压测没有真实覆盖整体的场景，就需要做。很好理解，一个redis-cluster被多个模块(或者子系统)使用，但压测仅做了某个某块的，如何能回答“这个redis-cluster能支撑整个系统多少访问” 这个问题呢？</p><h5 id="怎么做？-1"><a href="#怎么做？-1" class="headerlink" title="怎么做？"></a>怎么做？</h5><ol><li>整体思路为：根据业务访问情况，构造数据和请求。</li><li>周边工具链<ol><li>中间件观测工具</li><li>业务发压项目的设计 (数据模式、观测性)</li></ol></li></ol><p>对于 http 的压测</p><ol><li>和接口管理、接口测试相结合</li><li>封装 jmeter？</li></ol><p>对于其他类型的压测</p><ol><li>可扩展式设计</li><li>平台提供平台性功能，具体实现自行开发<ol><li>压测配置管理</li><li>压测计划管理</li><li>压测流程、报告管理</li></ol></li><li>工具类提供<ol><li>中间件压测最佳实践</li><li>流量录制、流量回放等最佳实践</li><li>http、websocket、rpc、dubbo 压测最佳实践</li></ol></li></ol><h4 id="整体的压测"><a href="#整体的压测" class="headerlink" title="整体的压测"></a>整体的压测</h4><h5 id="为什么要做？-2"><a href="#为什么要做？-2" class="headerlink" title="为什么要做？"></a>为什么要做？</h5><p>软件项目是一个耦合的系统，系统瓶颈可能造成整个系统的瘫痪，对于一个持续增长的项目而言，“这个项目在当前的架构下，技术层面的上限在哪里?” 这个问题是比较重要的，尤其是对那些被认为会获得快速增长项目。为了回答好这个问题，我们只有通过压测模拟用户量，用实验的方式得到答案。</p><p>“技术层面的上限” 实际上不是一个完整的阶段，它还包括着 如果遇到某些瓶颈，又如何能尽可能小成本地提升这个上限？</p><p>所以，我们可以这样认为什么是压测：<br>压测是一个 通过模拟不同场景下大量用户访问的方式，找到“根据系统负载情况，逐步调整系统的架构，以达到持续、正常提供服务”的路径 的体系。</p><h5 id="怎么做？-2"><a href="#怎么做？-2" class="headerlink" title="怎么做？"></a>怎么做？</h5><ul><li><p>压测目标清晰<br>明确压测目标是一切的开始，目标一定要足够清晰才能指导后续的行动。不论是个人还是团队，清晰的目标都是一件事情能够推行下去的基础，否则，“价值感缺失”将会极大降低效率，甚至让整个行动夭折。</p></li><li><p>指标体系完善<br>压测的主要流程就是在特定场景的压力下，通过分析各项指标，找到各类不合理的证据，从而推动架构的改进。可以说，指标体系是压测人员的眼睛。</p></li><li><p><input disabled="" type="checkbox">  梳理指标体系有哪些方面</p></li><li><p><input disabled="" type="checkbox">  基于这一节做 check list</p></li><li><p>场景梳理清晰</p></li><li><p>得到链路支持</p></li><li><p>工具给力</p></li><li><p>流程清晰，问题跟踪到位</p></li></ul><h5 id="做到什么程度？"><a href="#做到什么程度？" class="headerlink" title="做到什么程度？"></a>做到什么程度？</h5><ul><li>目标是什么？<ul><li>回答线上容量问题</li><li>找到架构优化方向</li></ul></li><li>有什么难点？<ul><li>指标体系，完善的监控指标需要付出很大精力</li><li>统合综效，全局优化往往需要打破局部最优</li><li>跨团队沟通，链路压测涉及到的跨团队协作沟通需要具备很强的动员能力和项目管理能力</li><li>在生产环境中的压测，涉及到众多数据的细节敲定，避免影响线上数据</li><li>以压测工具选型开始的压测流程体系建立及维护</li></ul></li><li>交付的是什么？<ul><li>用让人信服的报告，回答线上容量问题<ul><li>当前架构能支撑的用户数？</li><li>为了提升最大qps，需要做的操作流程有什么？</li><li>预案完备(发现过程、操作过程、验收过程)，通过演练熟练掌握操作</li><li>找到了多少个架构问题，提出了多少架构问题的优化方案，评估这些优化带来的业务价值有多大？</li><li>中间件使用合理性？</li><li>服务伸缩性是否提升？</li><li>服务稳定性、可扩展性是否提升？</li><li>资源成本是否降低？</li></ul></li><li>压测的工程化体系建立<ul><li>流程是否清晰、交付是否明确？</li><li>有多少文档输出？</li><li>有多少分享输出？</li><li>压测工具体系建设如何？</li><li>他人上手压测的难度如何？</li></ul></li></ul></li></ul><h3 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h3><ul><li><a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html" name="WIP-kafka的高吞吐原因" >WIP-kafka的高吞吐原因</a></li><li><a href="/longblog/posts/22_11_06_01_47_some_thought_of_performance.html" name="压测的一些思考" >压测的一些思考</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/longblog/posts/21_12_02_how_to_do_load_test.html" name="如何做好压测" >如何做好压测</a></li><li><a href="/notpublish/index.html" name="简单的性能测试方案" >简单的性能测试方案</a></li><li><a href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html" name="关于磁盘和网络的性能的问题" >关于磁盘和网络的性能的问题</a></li><li><a href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html" name="记一次服务性能的调优排查" >记一次服务性能的调优排查</a></li></ul><hr><blockquote><p>Never say there is nothing beautiful in the world anymore. There is always something to make you wonder in the shape of a tree, the trembling of a leaf.<br>— <cite>Albert Schweitzer</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>性能</tag>
      
      <tag>压测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>压测的一些思考</title>
    <link href="/longblog/posts/22_11_06_01_47_some_thought_of_performance.html"/>
    <url>/longblog/posts/22_11_06_01_47_some_thought_of_performance.html</url>
    
    <content type="html"><![CDATA[<p>压测的目的，在于保证系统达到某个量级的情况下不会死掉，在岗位划分上，专门做这件事的人可以被称作 性能工程师 ， 主要的工作就是做压测、性能分析、性能优化、服务可靠性提升。我们做压测，同样要向这些目标看齐，把整个系统的抗压能力提升起来。</p><p>整体来看，性能是一个系统工程，需要整个体系做配合，因此，性能可以提升到很高的高度，作为一个十分重要的事。当然，对于具体模块的性能优化，也可以是一个独立的模块，例如，对于部分 http 请求的性能优化、对于数据合并方式的性能优化。</p><p>站在类架构的角度考虑问题，可以考虑这些问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs text">1. 高可用<br>    - 分布式集群<br>    - 负载均衡<br>    - 探活<br>    - 容错/限流/熔断<br>    - 监控/告警/链路追踪<br>2. 高可扩展<br>    - 无状态<br>    - 模块化<br>    - 生产/消费模型<br>3. 高性能<br>    - 异步<br>        - 队列优化<br>        - 弹性优化<br>    - 多线程<br>        - 线程池优化<br>    - 数据/算法优化<br>        - 合适的数据结构<br>        - 数据压缩<br>    - 基础设施优化<br>        - 存储优化<br>        - 网络优化<br>        - 基础组件优化<br>    - 缓存优化<br>        - CDN优化<br>        - PWA优化<br>        - 数据库缓存优化<br></code></pre></td></tr></table></figure><p>上面罗列的这些，只是一些可优化的方向，对于具体模块的优化，需要有针对性的分析。</p><p>从整个性能测试的流程上来看，可以分成以下部分：</p><ol><li><p>性能需求指标<br>要有清晰明确的压测目标，目标需要根据场景进行划分。</p></li><li><p>压测场景与模型<br>要有明确的模型知道真实业务场景如何，并据此构建性能测试时的模型。一般来说，可以有： ① 基准场景  ② 容量场景  ③ 稳定性场景  ④ 异常场景。我们当前的压测场景，主要是基于 基准场景 和 容量场景 两类做具体的压测。</p></li><li><p>压测环境准备<br>需要尽量保证和线上近乎一样的数据量，近乎一样的基础设施。</p></li><li><p>压测数据准备<br>需要尽量保证和线上近乎一样的数据。压测脚本尽量和真实业务场景一致。</p></li><li><p>压测实施与监控<br>完善的监控体系，最好有压测时的监控大盘，主要的目的是能近实时地发现性能瓶颈点。</p></li><li><p>压测数据收集<br>指标有哪些，如何收集。常见的指标，类似于： ① TPS 平均值 ② TPS 95分位值  ③ 系统资源使用(CPU、MEM、load average、net、disk iops) ④ 中间件状态(mongo、redis、kafka、db)</p></li><li><p>性能分析与证据收集</p></li><li><p>压测报告与优化方案</p></li><li><p>优化实施控制<br>需要建立优化的反馈机制，保证优化方案得到落实，并且优化结果证明优化确实有效。</p></li></ol><p>整个性能测试的体系，可以参考：</p><p>要关注的内容：<br>资源层面：</p><ol><li>网关的网络流量</li><li>ingress的网络流量</li><li>node的网络情况</li><li>node的socket连接情况</li><li>node的CPU使用情况</li><li>node的mem使用情况</li><li>pod的网络情况</li><li>pod的socket连接情况</li><li>pod的cpu使用情况</li><li>pod的mem使用情况</li></ol><p>中间件层面：</p><ol><li>mongodb的cpu和内存消耗</li><li>mongodb的平均响应时长</li><li>mongodb的缓冲队列</li><li>mongodb的iops</li><li>mongodb的ops</li><li>redis的平均响应时间</li><li>redis的慢响应</li><li>redis的qps</li><li>redis的内存耗用情况</li><li>redis的命中率等</li><li>pg的平均响应时间</li><li>pg的慢响应</li><li>pg的qps</li><li>pg的内存使用情况</li><li>kafka的情况？[待补充]</li></ol><p>业务指标层面：</p><ol><li>api 的接口响应时长</li><li>api 的错误率</li><li>task 的数量</li><li>task 的平均处理时长</li><li>messenger的ws握手时长</li><li>messenger的消息吞吐量</li><li>messenger的消息送达率</li><li>messenger的消息顺序性</li><li>messenger的报错情况</li><li>merger的消息吞吐量</li><li>merger的消息平均处理时长</li><li>merger的报错情况</li><li>单个文件的消息处理能力(从客户端角度)</li></ol><p>目标：</p><ol><li>从基础设施的角度，弄清楚一些基础基准测试。</li><li>从业务的角度，弄清楚不同量级下，我们的瓶颈将会是什么，如何证明。</li></ol><p>执行记录：</p><ol><li>当前 【所有】 配置情况</li><li>执行操作计划 (何时开始，何时停止)</li></ol><p>要做的事：</p><ol><li>对各个模块做 bench，例如，网络、磁盘、中间件，得到基准值。 各个模块要做的基准测试 </li><li>对 lancer-service 的相关模块抽取出来，作为独立的压测工具，增加对每条消息的统计，增加分析查询接口。</li><li>针对需要覆盖的性能测试场景，做好数据准备。</li></ol><p>其他的一个想法：<br>如何让想法得到落地，以达到真正促进业务发展的目的？ =&gt; 成为一个对性能负责的人。</p><p>一些问题：</p><ol><li>是否需要线上全链路压测？<br>没必要。压测的目的，是尽量还原真实业务场景下，为了达到既定的性能需求指标，找到性能瓶颈并优化，同时保证在既定水位线以内系统不崩溃。那么，我们只要能尽量还原真实业务场景即可，通过增加一定的冗余来解决模型偏差带来的不准确即可。线上压测有两大问题： 1. 开发成本高，人员精力分配上存在问题。2. 需要对系统掌控能力很强，几乎不能出错误，否则影响面将非常广。</li></ol><p>要做的一些事：</p><ol><li>梳理当前要做的压测目标，使用更专业的流程框架，赶紧做出第一版压测。</li><li>建立整个性能测试过程的控制文档，将性能测试标准化。</li><li>和他人协作、交流、培训，让其他人也能很快上手性能测试。</li></ol><p>文档直通车：</p><ul><li><a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html" name="WIP-kafka的高吞吐原因" >WIP-kafka的高吞吐原因</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/longblog/posts/22_11_06_01_49_some_thought_about_performance.html" name="关于压测本身的梳理" >关于压测本身的梳理</a></li><li><a href="/longblog/posts/21_12_02_how_to_do_load_test.html" name="如何做好压测" >如何做好压测</a></li><li><a href="/notpublish/index.html" name="简单的性能测试方案" >简单的性能测试方案</a></li><li><a href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html" name="关于磁盘和网络的性能的问题" >关于磁盘和网络的性能的问题</a></li><li><a href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html" name="记一次服务性能的调优排查" >记一次服务性能的调优排查</a></li></ul><hr><blockquote><p>How many cares one loses when one decides not to be something but to be someone.<br>— <cite>Coco Chanel</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>性能</tag>
      
      <tag>压测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-自动代理自愈机制的探讨</title>
    <link href="/longblog/posts/22_11_06_01_01_discuss_about_resecure_of_proxy.html"/>
    <url>/longblog/posts/22_11_06_01_01_discuss_about_resecure_of_proxy.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为工作的需要，会搭建 proxy 机器，但有时候机器会出故障，出故障后的恢复过程现在是手动的，虽然也不算麻烦，但终归是把人的精力打成碎片的一个祸害，因此，考虑如何保证机器出故障后能及时处理并自愈？</p><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>要实现这个能力，需要从基础设施层和应用层两个方面进行。</p><p>基础设施，主要包含 创建/删除机器节点、对机器节点进行操作配置。</p><p>应用层，主要包含 更新节点信息。</p><p>基础设施的角度看，这是一个 IaC 的问题，要实现的方案可以有这么几类：</p><ul><li>基于传统 ecs 的方案</li><li>基于 k8s 的方案</li></ul><p>传统 ecs 在 IaC 的方案上，主要有这么几种：</p><ul><li>ansible、puppet 这类任务管理方案</li><li>terraform 这种基础设施管理工具</li><li>各云平台自己的 IaC 方案</li></ul><p>基于 k8s 的 IaC 的方案，主要为： operator + 节点控制器 的方式。</p><p>整个链条的流程是这样的：</p><p>健康检测 =&gt; 检查失败 =&gt; 更换节点 =&gt; 更新配置 =&gt; 剔除坏节点 =&gt; 更新配置<br>负载检测 =&gt; 负载超额 =&gt; 新增节点 =&gt; 更新配置<br>负载检测 =&gt; 负载过低 =&gt; 删除节点 =&gt; 更新配置</p><p>这个事情，可以往复杂了做，也可以简单点实现功能，复杂点，可以用 ansible 或者 terraform ，简单点，可以写代码实现。</p><h2 id="简单实验"><a href="#简单实验" class="headerlink" title="简单实验"></a>简单实验</h2><ol><li>建立健康检查机制 <a href="/longblog/posts/22_11_06_00_54_health_check_and_monitor.html" name="WIP-健康检查与监控梳理" >WIP-健康检查与监控梳理</a></li><li>建立出错反馈机制 <a href="/notpublish/index.html" name="事件中心和通知系统关系" >事件中心和通知系统关系</a></li><li>尝试写 aliyun 的 worker (可 serverless 部署)</li></ol><p>其他思考：</p><ul><li>能否基于 serverless </li></ul><p>查看 <a href="https://github.com/iamlongalong/goproxy">https://github.com/iamlongalong/goproxy</a></p><hr><blockquote><p>In all things of nature there is something of the marvelous.<br>— <cite>Aristotle</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>自愈</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-健康检查与监控梳理</title>
    <link href="/longblog/posts/22_11_06_00_54_health_check_and_monitor.html"/>
    <url>/longblog/posts/22_11_06_00_54_health_check_and_monitor.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>健康检查，是几乎任意一个运行的项目都需要做的。</p><ul><li>需要健康检查的场景<ul><li>中间件</li><li>业务系统</li></ul></li><li>现有方案<ul><li>promethues</li><li>datadog</li><li>ping</li><li>云拨测</li><li>错误检测平台</li><li>其他</li></ul></li><li>健康检查的环节<ul><li>检查</li><li>记录</li><li>告警配置</li><li>数据统计</li></ul></li><li>检查出错的反馈机制<ul><li>通知</li><li>看板</li><li>自愈处理</li></ul></li><li>自动化故障巡检机制</li><li>健康检查的自我检查</li><li>资源受限环境的使用</li></ul><h2 id="调研的一些项目"><a href="#调研的一些项目" class="headerlink" title="调研的一些项目"></a>调研的一些项目</h2><ul><li><a href="https://github.com/sourcegraph/checkup">https://github.com/sourcegraph/checkup</a></li><li><a href="https://github.com/alexliesenfeld/health">https://github.com/alexliesenfeld/health</a> (example 有更多)</li><li><a href="https://www.aiops.com/docs/ca/">https://www.aiops.com/docs/ca/</a></li><li><a href="https://github.com/dimiro1/health">https://github.com/dimiro1/health</a></li><li><a href="https://github.com/Purple-Devs/health_check">https://github.com/Purple-Devs/health_check</a> rails 参考</li><li><a href="https://github.com/andreas-schroeder/kafka-health-check">https://github.com/andreas-schroeder/kafka-health-check</a>  kafka</li><li><a href="https://github.com/lausser/check_nwc_health">https://github.com/lausser/check_nwc_health</a></li><li><a href="https://github.com/InVisionApp/go-health">https://github.com/InVisionApp/go-health</a></li><li><a href="https://github.com/etherlabsio/healthcheck">https://github.com/etherlabsio/healthcheck</a></li><li><a href="https://github.com/kuberhealthy/kuberhealthy">https://github.com/kuberhealthy/kuberhealthy</a></li><li><a href="https://github.com/megaease/easeprobe">https://github.com/megaease/easeprobe</a> (强大)</li><li><a href="https://github.com/labring/lvscare">https://github.com/labring/lvscare</a> lvs and ipvc health check</li><li><a href="https://github.com/toricls/pingbot">https://github.com/toricls/pingbot</a> base on serverless</li><li><a href="https://github.com/hootsuite/healthchecks">https://github.com/hootsuite/healthchecks</a>  microservice ，可形成 <a href="https://github.com/hootsuite/health-checks-api">https://github.com/hootsuite/health-checks-api</a></li><li><a href="https://github.com/Talento90/go-health">https://github.com/Talento90/go-health</a> (依赖项健康检查)</li><li><a href="https://github.com/grpc-ecosystem/grpc-health-probe">https://github.com/grpc-ecosystem/grpc-health-probe</a>  grpc</li><li><a href="https://github.com/tevino/tcp-shaker">https://github.com/tevino/tcp-shaker</a> </li><li><a href="https://github.com/AppsFlyer/go-sundheit">https://github.com/AppsFlyer/go-sundheit</a></li><li><a href="https://github.com/revsys/django-health-check">https://github.com/revsys/django-health-check</a> django 参考</li><li><a href="https://github.com/orf/gping">https://github.com/orf/gping</a>  ping with a graph in rust</li><li><a href="https://github.com/smartping/smartping">https://github.com/smartping/smartping</a> 互 ping 网络</li><li><a href="https://github.com/keen/pingpong">https://github.com/keen/pingpong</a> with graph</li><li><a href="https://github.com/laixintao/pingtop">https://github.com/laixintao/pingtop</a> ping time like top</li><li><a href="https://github.com/aprilmadaha/pingmesh">https://github.com/aprilmadaha/pingmesh</a> 大规模互 ping 网络</li></ul><hr><blockquote><p>If you seek truth, you will not seek victory by dishonorable means, and if you find truth you will become invincible.<br>— <cite>Epictetus</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>健康检查</tag>
      
      <tag>health check</tag>
      
      <tag>devops</tag>
      
      <tag>operation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>helm的一些简单使用</title>
    <link href="/longblog/posts/22_11_03_15_06_simple_usage_of_helm.html"/>
    <url>/longblog/posts/22_11_03_15_06_simple_usage_of_helm.html</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在 k8s 的体系中，是以 <code>清单</code> 的方式去 定义资源的，因此，使用 k8s 的重点就是 <code>创建、使用、维护 清单</code> ，原始的 k8s 资源清单就是用 </p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://v3.helm.sh/zh/docs/helm/helm/">https://v3.helm.sh/zh/docs/helm/helm/</a></p><h2 id="helm-repo-操作"><a href="#helm-repo-操作" class="headerlink" title="helm repo 操作"></a>helm repo 操作</h2><ul><li><p>添加 repo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add xxx https://xxx.xx.xx/xx --username xxx --password xxx<br></code></pre></td></tr></table></figure></li><li><p>查看现有 repo </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo ls <br></code></pre></td></tr></table></figure></li><li><p>更新 repo ( 把远端charts元信息拉到本地缓存 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo update<br></code></pre></td></tr></table></figure></li><li><p>在 helm 官方仓库搜索 charts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm search hub xxx <br></code></pre></td></tr></table></figure></li><li><p>在 repo 内搜索charts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm search repo xxreponame | grep xxx<br><br><span class="hljs-comment"># 或者</span><br>helm search repo xxx<br><br><span class="hljs-comment"># 或者</span><br>helm search repo xxx |grep xxreponame<br></code></pre></td></tr></table></figure></li></ul><h2 id="helm-安装插件"><a href="#helm-安装插件" class="headerlink" title="helm 安装插件"></a>helm 安装插件</h2><ul><li><p>查看已安装插件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">helm plugin list</span><br></code></pre></td></tr></table></figure></li><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm plugin install https://xxx.xxx.xxx<br></code></pre></td></tr></table></figure></li><li><p>推送私仓插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>helm plugin install https://github.com/chartmuseum/helm-push<br><br><span class="hljs-comment"># 使用</span><br>helm cm-push xxx https://xxx.xx.xx/xx/xxx<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用-helm-部署-charts"><a href="#使用-helm-部署-charts" class="headerlink" title="使用 helm 部署 charts"></a>使用 helm 部署 charts</h2><ul><li><p>拉取 charts 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm pull xxrepo/xxname --untar<br></code></pre></td></tr></table></figure></li><li><p>查看渲染出来的清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm template xx<br></code></pre></td></tr></table></figure></li><li><p>模拟运行一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm install xxname --dry-run --namespace xxx xxrepo/xxname<br></code></pre></td></tr></table></figure></li><li><p>部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm install xxname --namespace xxx --verify --<span class="hljs-built_in">set</span> xx.xx=xx.xx --<span class="hljs-built_in">set</span> xx.xx1=xx.xx1 -f xxvalues.yaml -f xx1values.yaml  xxrepo/xxname<br></code></pre></td></tr></table></figure></li><li><p>查看已部署的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm list<br></code></pre></td></tr></table></figure></li><li><p>卸载部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm uninstall xxname<br></code></pre></td></tr></table></figure></li></ul><h2 id="helm-制作-charts"><a href="#helm-制作-charts" class="headerlink" title="helm 制作 charts"></a>helm 制作 charts</h2><ul><li><p>创建模板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm create xxname<br></code></pre></td></tr></table></figure></li><li><p>检查 charts 格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm lint xxname<br></code></pre></td></tr></table></figure></li><li><p>下载依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm dependency update<br></code></pre></td></tr></table></figure></li></ul><h2 id="charts-组织方式"><a href="#charts-组织方式" class="headerlink" title="charts 组织方式"></a>charts 组织方式</h2><ul><li>Chart.yaml<ul><li>用来描述 当前 charts</li><li>版本管理</li></ul></li><li>requirements.yaml<ul><li>当前 chart 依赖的 charts</li></ul></li><li>charts<ul><li>依赖的 charts 的 zip 包</li></ul></li><li>templates<ul><li>渲染清单的模板</li></ul></li><li>values.yaml<ul><li>用于渲染的可修改的值</li></ul></li></ul><h2 id="charts-template-语法"><a href="#charts-template-语法" class="headerlink" title="charts template 语法"></a>charts template 语法</h2><p>整体来说，是 golang  template 的语法</p><p>有一些独特的方法，可以参考 <a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/">https://helm.sh/zh/docs/chart_template_guide/getting_started/</a></p><h2 id="一些好用的技巧"><a href="#一些好用的技巧" class="headerlink" title="一些好用的技巧"></a>一些好用的技巧</h2><ol><li>helper 的使用</li></ol><hr><blockquote><p>The most effective way to do it, is to do it.<br>— <cite>Amelia Earhart</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>云原生</tag>
      
      <tag>helm</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你活着，总得为点什么吧？</title>
    <link href="/longblog/posts/22_11_03_13_48_why_you_live_such_a_life.html"/>
    <url>/longblog/posts/22_11_03_13_48_why_you_live_such_a_life.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>2022年11月3日，开启这个话题的讨论</p></blockquote><p>前两天，跟同事聊天，问周末一般都做点啥，有看剧的，有钓鱼的，有逛公园的。有个同事是个游戏爱好者，说你们一个个都不玩游戏，错过了多少有趣的体验啊。</p><p>然后一个同事分享了一张图：</p><p><img src="https://static.longalong.cn/img/20221103135934.png"></p><p>感觉这个话题十分有趣，遂又查了一下，这是  原问题的链接: <a href="https://www.zhihu.com/question/58400340">找个不打游戏的男朋友有多难</a></p><p>有一些回答的角度是： 他不打游戏，他总得投入点什么吧？</p><p>这个角度很有意思，往日常了说，这是个个人爱好和个人精力分配的问题。往形而上地说，这是一个社会运行机制的问题，也是一个存在价值的问题。</p><p>近几年因为一些原因，普遍的经济状况都不大好，各行业原来的运行逻辑都受到了挑战，因此 <code>躺平</code> 的文化逐渐盛行，实际和上面这个话题在一些层面上是想通的。</p><p>看到一则知乎回答：<br><img src="https://static.longalong.cn/img/20221103140919.png"></p><p>这样的社会背景下，很多人都会面临这个问题的洗礼，开始正视： 究竟什么才是我所追求的？</p><p>这个问题对个人的价值是毋庸置疑的，这可能是很多人跳出 <code>传统的社会思维惯性</code> 的开始，也开始真正地拥抱 <code>多元价值主张</code>  。</p><p>有些人，选择的是躺平，也有些人，选择了其他更符合自己心意的方式过一生。</p><p>前段时间B站播出了 《三悦有了新工作》，女主最开始看起来，就是在经历这个过程，一开始，她也选择了 <code>躺平</code>，之后一系列的故事也让她对人生有了更多的感受，找到了自己的价值倾向。</p><hr><blockquote><p>2022年11月10日，继续思考这个话题</p></blockquote><p>很长一段时间，我工作的动力都不是很足，很多时间处在迷离、徘徊的状态。觉得自己很多问题没有想明白，比如： 你为什么要工作？ 你为什么要在这家公司工作？你为什么要拼死拼活地在这家公司工作？</p><p>工作动力的不足，来源于未能将自己的价值倾向和工作关联起来。如果你自己本就不清楚自己的规划，那么，不仅是工作，任何事情的动力都不会足。整个人将会变成任由外部事务推动的状态，而非发自内心的动力驱动。所以，要解决工作动力，还是得解决价值倾向。</p><p>有稳定价值倾向的人，会很稳定，会行为倾向稳定、会情绪稳定，因为他有一套稳定的判断行为的标准。而价值倾向不稳定的人，会比较苦恼，因为他们会发现，站在不同的角度，一件事、一个行为 的价值是不好判断的。如果他们心态乐观，可能会觉得怎么做都是对的，如果他们心态悲观，可能会觉得怎么做都是错的。</p><p>不过价值倾向这个东西，基本决定了你是谁，所以也不应当急于定一个，需要不断地问自己： 诚然，站在不同的角度有不同的看法，价值判断本就没有对错，只有立场之分……那么，你的立场是什么？</p><p>立场，实际上是看哪个角度更符合自己的诉求，也就要看你所求的究竟是什么？</p><p>人生是一场修行，每个人都在修自己的道。但或许，很多人都在追求一个相同的东西 – <code>念头通达</code>。我们都在找一个让自己安心的状态。人世浮沉，我们在其中飘摇，和冬日的猫咪一样，我们大多都凭借 <code>本能</code> 探索和寻找温暖的火炉。</p><p>本能，核心就是趋利避害。但同样，本能，大多趋向的是更原始的、更动物性的利。就像我们对碳水的热爱、对安逸的享受一样。但在复杂的现代社会中，有些本能对长远利益的实现甚至是有害的，比如 短期碳水带来的快乐 和 长期健康 之间的矛盾，所以，遵从内心，还要站在更长远的利益。</p><p>上面讨论的，不过是一些基础的、原始的利益和价值。社会发展到现在这个阶段，早就出现了一系列的 <code>价值主张派别</code> ，维度有很多，有社会治理层面的、有个人生活层面的、有工作层面的、有家庭层面的 等等，这些组成了我们的具有统一价值倾向的团体，例如 家庭(尊老爱幼、血浓于水)、企业或行业(为xx提供xx价值)、国家(社会主义核心价值观) 等等，也有一些联系不紧密的群体，例如消费主义人群、二次元群体、奋斗逼群体 等等。</p><p>当在一个群体中时，要能接纳这个群体基本的价值倾向，这是融入其中的基本条件。如果你希望在这个群体中拥有更大的影响力，就需要更加符合这些价值倾向<del>(或者更能掌控)</del>。</p><p>价值倾向，只是一切的开始，而每个人一生中所有的时间，都走在通往一些价值倾向的路上。有些人走得快些、有的人走得慢些，原因有2，其一，对价值的倾向摇摆不定；其二，能力限制。</p><p>以前听过一句话：当一个人的能力配不上他的欲望时，就会感到痛苦。 (这里的欲望，姑且理解成价值倾向的具体体现吧。)</p><p>痛苦，是害，欲望，是利。利害终究是成对出现的。</p><p>趋利避害的方法有两个，其一，降低欲望，其二，提升能力。</p><p>欲望的含义非常广泛，不仅指个人对金钱、权力等的追求，更泛化的，包括对他人行为的期待、对事物状态的期待等等。 降低欲望，例如，不要强求他人会按照你的想法行事，不要强求你一定会拥有什么……</p><p>欲望这个东西，是无穷的，他本就是人的本能演化出来的东西，欲望会随着满足程度的提高而升级，就像马斯洛的需求层次一样。降低欲望是一种方式，虽然无法解决欲望，但在有生之年，压制欲望还是能让人通过减少痛苦来达到 <code>相对幸福</code> 的目的。或许这也是一些低欲望社会在群体层面用脚投出票的逻辑吧。</p><p>降低欲望可以通过 <code>屏蔽</code> 的方式，具体可以有：</p><ul><li>屏蔽信息<ul><li>避免去看别人的美好生活</li></ul></li><li>屏蔽内心<ul><li>避免和自己 1v1 对话</li></ul></li><li>建立屏障<ul><li>思维屏障，建立一些思维惯性，比如 <code>看着好而已，实际做的话也没意思</code> 之类的葡萄思维</li><li>身体屏障，建立一些让自己忙的事，比如 <code>刷剧</code>、<code>游戏</code> 、<code>睡觉</code> 等等</li></ul></li></ul><blockquote><p>这些方式不完全代表 <code>降低欲望</code>，有些甚至可能是 <code>满足欲望</code>，例如有些人就是喜欢打游戏。仅举例一些可能的方式而已。</p></blockquote><p>降低欲望，是一种低成本减轻痛苦的方式，因此，网络上也有很多让人放下欲望的文章，受到不少人喜欢，类似的还有 <code>收起情绪</code>、<code>戒掉面子</code> 等等。</p><p>听过一句话： 能战胜欲望的，只有更高级的欲望。多用在讲 <code>自律</code> 的主题中。这和上面的思路是相反的，但也没有对错之分，适用于不同的场景罢了。<code>高级</code> 这个词我认为换成 <code>强烈</code> 或许更好理解。这是在没有触碰到 <code>能力带来的选择限制</code> 前，不同欲望间的竞争。</p><p>采用 <code>降低欲望</code> 这种方式的人，从外在看起来，有一种 <code>躺平</code> 的气质，<code>没关系</code>、<code>无所谓</code> 、<code>算了</code> 是口头语，常被一些人描述为 <code>逃避</code>。也不得不承认 <code>逃避虽然可耻，但有用</code> 。若真能做到 <code>月入一千八，整天笑哈哈</code> ，自己快乐了，对他人也没有伤害，开开心心在这世间走上一遭，不也挺好吗？不同人不同选择罢了，也无可厚非。 就像《三悦》中的台词：</p><p><img src="https://static.longalong.cn/img/20221125144558.png"></p><p>减少痛苦的另一种方式，是提升能力。</p><p>和降低欲望的 <code>避世</code> 心态相反，提升能力 是一种 <code>入世</code> 的心态。</p><blockquote><p>避世或入世，是两种选择的思路，大隐小隐之争也无所谓了，抓到耗子都是好猫。</p></blockquote><p>在职场上，选择了这种方式的人通常看起来就是 <code>卷</code>，大有 <code>卷天卷地卷自己</code> 的气势，因为存在 <code>卷眼看人卷</code> 效应，所以他们眼中的世界和卷饼有点像 :-)</p><p>但要注意，这里的 <code>能力</code>，不完全等同于平常我们所说的 <code>开发能力、沟通能力、xxx能力</code> ，而是指 <code>能帮助你满足自己诉求(欲望)的能力</code> ，上面说的这些能力算是其中的一部分。</p><p>在职场中，一定会接收到 <code>好好工作，提升工作能力就能升职加薪，然后你就会有钱，然后就会生活得很快乐</code> 这样的观念洗礼，但一定要留个心眼，多问自己几次： 是不是这样的？有没有更好的？</p><p>一味提升工作能力还有没有效？这不好说，只能说是一种可能性吧，因为社会发展的阶段问题，不确定工作能力还能不能成为一个突破点。在提升工作能力的同时，还需要增加看待事物的视角、抓住特定的时机、获得好的外部助力…… 这些都是需要考虑的。</p><p>但如果你在梳理了自己现状、探索了各种外部可能性后，还是得出了 <code>提升工作能力确实是最有可能性的方式</code> 这个结论，那么也恭喜你，先这么搞着吧，行动个一年半载再回头来思考。</p><blockquote><p>能得出这个结论的，估计都是和我一样的 “三无青年” 吧 ( bushi )，只能仰仗工作谋出路了，惨嘻嘻……</p></blockquote><blockquote><p>在 <code>卷人</code> 的世界中，应该存在一个 <code>有效卷度</code> 的衡量标准，去衡量哪些卷是有价值的、哪些是无效卷，然后用一个共识去计算：<code>卷力值 = 卷度 * (有效卷率 - 2 * 无效卷度)</code>  <em>( 2 是随便写的，这个可调参 :-) )</em></p></blockquote><blockquote><p>卷人至高理念： (玩笑，勿当真 -.-)<br>屌丝版：只要卷不死，就往死里卷<br>文人版：哪管什么真理无穷，进一寸有一寸的欢喜</p></blockquote><p>从 <code>开源节流</code> 的视角来看，<code>降低欲望</code> 是节流，<code>提升能力</code> 是开源。虽然看起来是截然不同的两个方向，但他们从来都不是非此即彼的，往往，只有小孩子才做选择。</p><p>这两种方式 都是有惯性的，<code>开源</code> 会让你上瘾，<code>节流</code> 也会让你上瘾。我们需要偶尔内观一下，看看自己是不是走上了某一条路而忽略了另一条？</p><hr><blockquote><p>11月15日，思考这个话题</p></blockquote><p>对于个人而言，存在价值倾向的问题，对于组织而言也一样。个人价值倾向的缺失，会导致个人动力不足，而组织价值的缺失，同样会导致组织的混乱。但组织的价值问题相对好解，因为组织有其存在的基本原因： 满足客户需求，实现客户价值，获取经济回报。 因此，组织的价值问题往往只要弄清楚 <code>你的客户是谁？</code>  <code>你为客户解决了什么问题？</code>  基本都能找到价值。所以，在组织中，大都会建立 <code>以 &quot;用户价值&quot; 为价值锚点的体系</code>。</p><p>之前有看到一个谈 <code>关注圈</code> 和 <code>影响圈</code> 的，核心观点是，关注圈是那些我们只是看看但改变不了什么的事情，比如俄乌局势、过年能收多少红包、哪个明星又逃税啦……，而影响圈是那些我们通过行为能够改变结果的事情，比如自己练练做饭，然后过年去丈母娘家里露一手，女婿的位置可能就稳了，我们应当少在关注圈的事上花费过多精力，应当把更多精力投入到影响圈的事上，然后逐步扩大影响圈的范围。</p><p>其实总结一句话：做好你能做的事。</p><p>前段时间和一个同事聊天，他是一个工作十多年的研发同学，他说他以前也是 <code>很冲</code> 的人，看到公司的一些问题都会直接提出来，但现在不了。<br>我说，这算是被职场磨平的棱角？<br>他说，是也不是，现在是不说了，而是遵从自己的内心，有哪些能推动的就去推，推不动的也没办法，等机会吧。</p><p>我想，有些人是真的被磨平了，而有些人，是变得圆滑了，看起来棱角少了，但真正解决问题的能力提升了。</p><p>这个同事算是捋顺了他的思路，以公司的价值为价值标准，关心自己能做的事。 可能也会累，也会得不到理解，但他有他的价值标准，得到了自己的认可就够了。想必，内心始终是平静的吧。</p><p>如果你能以公司的价值作为自己的价值标准，那么恭喜你，也算是脱离了 <code>价值感缺失群体</code> ，也挺好。</p><p>如果你得出的结论是 <code>自己无法很好地拿公司的价值来评判自己</code>，那么可以继续追问：自己为什么这样认为？</p><p>如果答案是，不在意 <code>这家</code> 公司的价值，那么可能需要做的就是换一家你在意其价值的公司。<br>如果答案是，不在意 <code>公司</code> 的价值，那么可能需要回答一个问题： 为什么要工作？</p><p>我想，大多数人可能和我一样，在公司工作最直接的原因是 <code>养家糊口</code>，这是现状。依靠公司，可以降低自己直接和市场交易的交易成本，获取自己劳动所得。</p><p>最好的状态，是想做什么做什么，但目前做不到，必须得积累能力和资金，期望以后能做到，或者能尽早做到。</p><p>最期望的方式，是把你觉得有趣的事，做成能支持你长远发展的事，或者说，做成作品，这个作品能推动你发展。 比如，喜欢传媒的同学，做自媒体，达到能挣钱养活自己之后，既是在做自己感兴趣的事，又是在积累实力，还有概率将来 <del>躺平</del> 过自在的生活。 再比如，喜欢足球的同学，做足球运动员。喜欢写作的同学，做作家。喜欢农业的同学，开农场……</p><p>你觉得什么方式更好，就先低成本去试试，就像在攀岩的时候，先用脚去探一探下一个可能的支点，如果发现那个点还不错，就逐渐转移重心过去。</p><hr><blockquote><p>11月17日，思考这个话题</p></blockquote><p>虽然现代社会一直倡导 公平、正义，但一定要认识到，<code>公平</code> 是相对意义的公平，而非绝对意义的 <code>平均</code> 。</p><p>世界是不公平的，世界是混乱的，这是世界的现实，我认为也是本质(改变不了的特性)。</p><p>有些时候，当看到一些社会新闻的时候，你会感到很无奈，比如：一个明星出演一部剧费用是 1 亿元、红会捐款被私人挪用、xxx贪污几千万……</p><p>请认识到，这就是现实，甚至现实更残酷，比如，几乎所有大城市土著都不上班，他们靠着房租、高额退休金、高额社会福利金过得非常滋润，很多原住民靠拆迁收入千万以上…… 这只是金钱上的冰山一角而已，其他方面的还有更多……</p><p>这可能已经是还不错的了，世界上还有些人民，正在遭受着战乱，生命安全都还得不到保证…… 当然，也有些地区，过着富足安逸的生活……</p><p>世界是混乱的，是不公平的，这是现实。</p><p>相对于上面的这些背景来看，你想做什么？你要不要辛勤工作？要不要在公司里做事？这些问题都太过无力了……</p><p>所以，不要太忧愁，都是来这世上走一遭，开开心心也是过一生，忧虑烦躁也是过一生，知足才能常乐。我们每个人都有自己的人生角色，演好自己的这个角色就好，不用去羡慕条件更好的那些人，因为也有很多人过着朝不保夕的日子。</p><p>就像罗翔说过的一段励志语：</p><blockquote><p>有时候我们觉得自己抓的牌实在是太差了，但是再差的牌都得打下去，我们登上并非我们所选择的舞台，我们决定不了我们的出身，我们决定不了我们的智商，我们更决定不了这一生的贵人相助，很多时候我们羡慕别人的剧本，但是没有谁的剧本值得羡慕，你只能把你自己的剧本给演好，如果你的一生中真的遭遇到这些挫折，对不起，这就是你的剧本，你只有两种选择，一种是弃演，另一种选择就是把既定的选择给演好。</p></blockquote><p>人类一思考，上帝就发笑。不是不让你思考，而是思考过程中遇到难点不要太较真，不要没事就往哲学的终极问题上引。</p><p>放过自己，悦纳自己，游戏人生。就像多年以前听过的一个段子：人生嘛，不过就是笑笑别人的时候也让别人笑笑。</p><p>很多时候，放下了，才能拿得起。</p><p>做猪嘛，最重要的，当然是开心啦~</p><hr><blockquote><p>11月20日，思考这个问题</p></blockquote><p>如何能快乐？</p><p>认可自己的行为，就能每日笑呵呵。悦纳自己。</p><p>人是意义动物。建立一套对当前行为在 <code>意义</code> 上的解释。</p><p>意义，最终需要归于 <code>你在意什么</code> ，要想让意义变得持久，就需要 <code>稳定</code>，在变化的环境中，意义的基础 也是易变的。 稳定 可以是客观的稳定，也可以是主观的稳定。 比如，在一个稳定的环境中，<code>意义</code> 可能是 <code>其他人对你的评价</code> ，当你在这个环境中认可了这个价值点，然后环境发生了变化，大家不再提这个价值点了，于是 意义 就不再那么有意义了。</p><p>意义，不是凭空产生的，也不是靠自己感觉到的，意义来源于反馈。就像是奖励一样，当你有了一些行为，这些行为符合一些主体的利益，这些主体就产生一些反馈，这些反馈回到你这里，就成了 意义 的一部分。</p><p>反馈来源于多方面，主要可以分为 <code>生理性反馈</code> 、 <code>社会性反馈</code> 和 <code>自我解释性反馈</code> (都是自己造的词)。首先，要满足吃喝拉撒这些事儿，也可以认为是生存的本能。在现代社会，钱是一个不错的衡量方式。 社会性反馈，可以是被人认同。自我解释性反馈，来源于自己内心。</p><p>不同人的关注点不同，受到上面三种反馈的影响程度也不同。不过整体而言，生理性反馈是与生俱来的，影响程度较大。后两者与社会教育 和 个人性格相关。</p><p>快乐，其实就是： 吃好穿暖、被人认可、自我认可。</p><hr><blockquote><p>2022年11月25日，再次思考这个话题</p></blockquote><p>你总得做点什么?</p><p>遵从你内心的想法，去创造。</p><p>如果你真的在意钱，那你最好在过程中不要在意钱，而是要从结果上在意钱，战略上重视，战术上轻视。</p><p>要明白，如果时时刻刻总想着 <code>能不能挣更多的钱</code> 会让人 <code>陷入焦虑型短视</code> 中，所以，只要在战略上确定好了方向，在战术上只需要持续执行(以及复盘)就行了，那么，平常就不用焦虑，你只用做好日常项目管理即可。</p><p>我们是缺乏稳定的价值观的，因此会存在价值感缺失、迷茫的状态。不过，我们都想要自由自在的生活。这也可以成为价值的来源。</p><p>不要强求 30 岁就退休，目标可能是 35 岁能够自由工作。但这个过程中，去做那些真正有积累的事，积累能力，积累作品。</p><hr><blockquote><p>2022年11月28日，再次思考这个话题</p></blockquote><p>一直在思考的一个问题：你想要做什么？有一些新的想法。</p><p>从长远来看，我们的目标都是美好生活。 要做到这点，需要两方面的条件： ① 拥有选择生活方式的权力 ② 拥有对美好生活的想象力</p><p>美好生活的想象力，指的是，你知道哪些是美好生活的一部分，知道什么是更 “好” 的生活。这里面有很多主观的价值判断，是一个仁者见仁智者见智的问题，但也有人类共通的逻辑，比如对美的欣赏、对美食的渴望、对健康的追求等等。</p><p>这两项，需要协同上升，对美好生活的向往 是 选择生活方式的权力 的动力，同样，选择生活方式的权力提升，同样能够促进/激发更进一步的对美好生活的想象力。就像段子里说的：贫穷限制了我的想象力。</p><p>网络时代，实际上我们从来不缺对美好生活的想象力，这个世界有太多美好的事物了，那些 <code>有生之年一定</code> 系列大都是美好的。 我们最缺的，实际前者，这才是一切问题的根源。</p><p>在这个时代，宏观上，选择的权力来源于两个： 权力 和 货币。 但有时候，权力也受到另外一些权力的制约，所以拥有权力的选择权是有方向性的。 货币，适用范围更广。</p><p>货币，实际上是交易流通过程中，用来作为等价交换的媒介。如果想要囤积货币，也就需要在等价交换过程中，提供更多的价值。 这是基本逻辑。</p><p>价格和价值的关系，同样受到市场供需关系的影响，所以关注供需也是一个重要的方面。</p><p>对他人而言，一个人是否产出了价值，不要看他说了什么，而是看他做了什么。同样，对自己而言，事情不会因为你<code>希望什么</code>、<code>想了什么</code>或者<code>说了什么</code>而发生改变，但会因为你<code>做了什么</code>而发生改变。知行合一才能真正让认知服务于现实。那么，要做点什么呢？</p><p>格局，很重要。当你观察历史、观察名人传记等，你就会发现，小打小闹终究改变不了什么。比如你现在天天只是做一做工作，如果你不能真正想清楚工作能带给你什么、能为你的长远目标有什么贡献？ 那么，这份工作将永远只是一门工作，你也永远只是一个打工人。</p><p>要想有突破，就需要关注趋势，在趋势面前，所有个人都是渺小的，你只有找到真正的价值点，然后顺应趋势，发挥出自己的价值，才能有所获。</p><p>我现在做后端技术为主的工作，目的是什么？</p><p>如果，在经过多番比较还是拿不定主意时，也不用纠结，有两种可能：</p><ul><li>没有更多的信息，空比较价值不大</li><li>就当前的需求而言，这些选择问题都不大</li></ul><p>前者，先做吧，多拿点信息在比较。<br>后者，先做吧，既然都经过这么多比较了，选择一个，做到极致，都不会差的。</p><hr><blockquote><p>2022年11月30日，再次思考这个问题</p></blockquote><p>我现在在做的工作，是以后端为主的软件开发工作，我为什么要做这项工作？</p><p>后端的价值，在于 <code>稳定性、可扩展的服务设计</code> ，另外，后端还兼具 <code>服务运行环境维护</code> 的职能，还兼具一部分 <code>服务数据分析</code>、 <code>服务运行安全</code> 的职能。软件开发，都比较注重 <code>工程化</code>，因此，掌握工程化的能力，增强开发效率，是重点之一。</p><p>和后端相对应的前端，主要价值在于 <code>用户交互</code> ，根据交互的媒介、交互的细节不同，前端展现出了极大的丰富性，app、小程序、web、pc端 等等，交互方式更为多样，游戏、编辑器、动画、图表表单……</p><p>我做后端，主要的目标： ① 掌握一套服务端设计、开发和运行体系<br>我做前端，主要的目标： ① 掌握一套最常用的开发体系</p><p>我为什么要掌握这些？</p><p>从将来看，我需要快速进行开发工作，能够快速做各类想法的尝试和验证。这包括前端和后端。我需要尽可能将自己的精力从具体的开发和维护中解放出来，才能将更多的精力放在对 趋势 的探索上。</p><p>为什么认为技术是廉价的?</p><p>技术的价值需要依托业务来实现，从中国的技术市场上来看，业务的价值大于技术的价值。当前的技术体系都是建立在开源世界上的，因此，只要拥抱开源世界，大多数问题是无需自己解决的，大都是通用性很广的方案。而我们需要做的，就是用好这些工具，做一些粘合的工作，而这些工作的门槛大都不高。门槛不高，也就意味着供需关系大多为买方市场 (企业)，也就意味着技术的廉价 (开发者)。</p><p>需要注意的是，并不是说所有的技术都是廉价的，只要是那些技术门槛较高的领域，开发者的议价能力都还行，这些领域，要不就是很垂直的领域，要不就是比较新兴的领域，例如，芯片、AI、图形、区块链 等等。</p><p>作品思维 之前聊过，从一生来看，<code>作品思维</code> 是一个怎么重视都不为过的基础思维。 中短期来看，我需要打造一个作品。中长期来看，我需要收集一套通用技术方案，主要包含这些部分：</p><p>服务端侧： ① 非常通用的 web 端开发脚手架及流程  ② 通用的管理后台开发脚手架及流程  ③ 非常通用的 serverless 开发流程<br>运维侧： ① 一套非常通用的企业级系统运维方案  ② 多个常用的运维工具<br>前端： ① 通用的微信小程序开发流  ② 通用的 web 开发流</p><p>这些是中期内要做的积累。长期要做些什么？ 这个问题还需继续思考，或许 趋势、杠杆 等关键词能带给我一些思路……</p><hr><blockquote><p>He who controls others may be powerful, but he who has mastered himself is mightier still.<br>— <cite>Laozi</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
      <tag>人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你还是半年前的你吗？</title>
    <link href="/longblog/posts/22_11_03_12_04_are_you_the_same_as_yourself_half_year_before.html"/>
    <url>/longblog/posts/22_11_03_12_04_are_you_the_same_as_yourself_half_year_before.html</url>
    
    <content type="html"><![CDATA[<ul><li><p>半年过去了，你的身体是否发生了变化？ 心灵是否发生了变化？你真的了解你自己吗？</p></li><li><p>记录的价值很大，不论是文字、图片、视频，不论是日常、工作、娱乐，不论是家里、户外、山中、城市。</p></li><li><p>让时间定格在某一刻。</p></li><li><p>记录你的情绪、记录你的状态、记录你的经历、记录你的想法。</p></li><li><p>让未来的你知道，原来你曾经也拥有过这样强烈的情绪，让你知道，曾经的你是如此的幸运，让你知道，曾经的你原来有着这样的奇妙想法。</p></li><li><p>认识自己，最好的方式就是理解自己的过去。</p></li><li><p>以人为镜，可以明得失；以己为镜，效果更佳。</p></li><li><p>通过记录曾经的自己，可以在一段时间以后，客观地评价自己，有时候甚至像是看另一个人的人生一样，这是一种挺有意思的体验。</p></li></ul><p>有此感想，来源于一个博主的公众号：</p><blockquote><p>从过去，到现在，再到不久的将来，这个世界会发生很多让自己非常有情绪的事情，不管自己能否因为这些情绪做点什么，至少可以做的一件事情就是：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">记住这个情绪，不要忘。<br></code></pre></td></tr></table></figure><p>最好找个地方，写下来，让未来的你，可以记得，自己曾经有那样的情绪。</p><blockquote><p>这篇文章后续再加工一下，聊一下 “记录” 对我们的价值，以及怎么形成记录的系统。</p></blockquote><p>【未完待续……】</p><hr><blockquote><p>All children are artists. The problem is how to remain an artist once he grows up.<br>— <cite>Pablo Picasso</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协同场景的状态同步探索之一</title>
    <link href="/longblog/posts/22_11_02_09_57_explore_of_co_operation_1.html"/>
    <url>/longblog/posts/22_11_02_09_57_explore_of_co_operation_1.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前两天在整理 <a href="/longblog/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html" name="消息系统进化史-零号机" >消息系统进化史-零号机</a> 的思路的时候，想到一种场景： 几个客户端之间想拥有一个公共的状态，任何一个客户端对该状态进行了更改，都能同步更改到其他客户端。</p><p>于是，在此思路上，做了 <a href="/longblog/posts/22_10_31_22_30_how_to_master_statement_management_in_fb_mode.html" name="如何搞定前后端一体的状态管理" >如何搞定前后端一体的状态管理</a> ，基本思路是： 用一个 map 去保存状态，并对 map 的每个值添加监听器，如果操作了某个值，则对监听者发送事件通知。 基于此，在对特定的事件进行封装，就能实现多客户端拥有全局统一的状态了。</p><h2 id="简单思考"><a href="#简单思考" class="headerlink" title="简单思考"></a>简单思考</h2><p>这确实有一些实用价值。在协同场景下，这类需求还是存在的。</p><ol><li>没有 demo</li><li>没有进一步封装的 sdk</li></ol><h2 id="协同场景的简单思考"><a href="#协同场景的简单思考" class="headerlink" title="协同场景的简单思考"></a>协同场景的简单思考</h2><p>协同场景，简单来说，就是： 存在一个公共的资源，有多个用户可以对其进行操作。</p><p>最典型的场景是： 多人游戏、文档协作。 当然也有一些其他的场景，例如  在线协同设计、在线白板(教学、演示等)。</p><p>协同场景的基本逻辑，和上面做的 responsive map 是一样的，都是保证协同的多方所共同持有的那个公共资源拥有一致的状态。 而这个状态，可以是一个 map，也可能是其他数据结构，这是根据业务实际情况而定的。</p><p>为了实现协同，必不可少的步骤就是： 任意一方将状态更新时，都同步到其他方去。</p><p>因此，有两个隐形要求： ① 状态是能够传输的  ② 更新通知时能够及时发送的。 说人话一点大概是这样：</p><ul><li>状态的数据结构是可以被序列化的</li><li>需要一套消息系统将消息发送出去</li></ul><p>从工作职能上，我们可以按照上面的分析，划分成 <code>协同业务</code> 和 <code>消息系统</code> 两个部分。 协同业务 负责从业务角度 <code>设计数据结构</code> 、<code>协同事件序列化</code>、<code>协同事件处理</code>； 消息系统 负责从全局角度 <code>设计消息传输系统</code> 。</p><p>数据结构，目标是： 用符合资源模型的数据结构去描述共有资源。 这个跟业务强相关，姑且不描述了。</p><p>协同事件序列化，目标是：将当前操作变成能够通过网络传输的数据。 </p><p>协同事件处理，目标是：将其他方发来的操作变动在自己的共有资源上进行还原。</p><p>一般来说，协同事件的传输内容有两个基本的方案： ① 同步操作。 ② 同步状态。 这两种方案均有其特点以及特定的应用场景。</p><p>例如，在一些棋牌类游戏中，由于公共资源的数据模型比较简单，因此，在任意游戏参与者做了操作之后，服务端都会把整个数据发送给各端。 比如，我打了一对 A，然后就剩下一张 3 了，服务器就会把当前所有牌的情况给各端发一次 (猜的，不一定真是这样啊)。</p><p>状态同步的缺点在于： 数据量大的时候会有性能问题。<br>状态同步的优点在于： 数据一致性很好保证。</p><p>因此，全量同步比较适用的场景是： 核心模型的数据结构不会特别复杂，对数据一致性要求很高。 </p><p>而有一些场景下，数据结构十分复杂，每次全量同步就会存在性能瓶颈 (序列化瓶颈、网络瓶颈、反序列化瓶颈、diff 瓶颈)。 这种时候，就只能使用 <code>操作同步</code> 的方案。</p><p>操作同步，意味着在每次对资源进行操作时，把每个操作进行序列化，并把这些操作消息传输到其他端。 在接收到操作的端上，将操作反序列化后，把操作在本地进行 <code>回放</code>。</p><p>举个例子，我们假设有一个直播间，他的基本数据模型是一个 map ，例如是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;room_name&quot;</span>: <span class="hljs-string">&quot;first room&quot;</span>,<br>  <span class="hljs-attr">&quot;desc&quot;</span>: <span class="hljs-string">&quot;this is a test room&quot;</span>,<br>  <span class="hljs-attr">&quot;picture&quot;</span>: <span class="hljs-string">&quot;https://xx.xx.com/xxxxxxx.jpg&quot;</span>,<br>  <span class="hljs-attr">&quot;room_detail&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;user_counts&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">&quot;users&quot;</span>: [&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;user001&quot;</span>,<br>  <span class="hljs-attr">&quot;avatar&quot;</span>: <span class="hljs-string">&quot;https://xx.xx.com/xxx001.jpg&quot;</span>,<br>  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;001&quot;</span><br>  &#125;,&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;user002&quot;</span>,<br>  <span class="hljs-attr">&quot;avatar&quot;</span>: <span class="hljs-string">&quot;https://xx.xx.com/xxx001.jpg&quot;</span>,<br>  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;002&quot;</span><br>  &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个用户对将这个房间的 desc 进行了修改，这将会产生这样的 option：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;desc&quot;</span>: <span class="hljs-string">&quot;this is a very fantastic room !&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者，你也可以做一层封装，类似于这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;desc&quot;</span>: &#123;<br><span class="hljs-attr">&quot;operation&quot;</span>: <span class="hljs-string">&quot;update&quot;</span>,<br><span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;this is a very fantastic room !&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际操作的数据结构设计，是跟业务直接相关的，不同的业务会有不同的设计，这里就只是举个例子。</p><p>这种操作同步的方案，优点在于： 传输的数据轻量，能支持比较复杂的数据模型。<br>缺点在于： 数据一致性比较难保证。</p><p>当下比较火热的协同产品，大都是比较复杂的数据模型，基本都选择了这类操作同步的方案。比如 在线文档。 </p><h2 id="数据一致性的一些方案"><a href="#数据一致性的一些方案" class="headerlink" title="数据一致性的一些方案"></a>数据一致性的一些方案</h2><p>上面我们有讲到，使用 <code>操作同步</code> 的方案，会有数据一致性的问题，那么，我们一起来看一下数据一致性一般有哪些常规方案。</p><p>解决数据一致性的问题，可以分成两类场景：</p><ol><li>单主模型</li><li>多主模型</li></ol><p>单主模型下，出现数据一致性问题的主要场景就是 <code>事务</code>，通常是直接通过加锁实现，差别基本只存在于锁类型。</p><p>多主模型是数据一致性的重灾区，一般来说，可以有这些方法：分布式锁、共识算法、OT (操作转换)、CRDT(无冲突复制数据类型) 。</p><p>在协同操作的场景中，由于对响应速度的追求是很高的，因此最终会走上 <code>多主模型</code> 的 OT 和 CRDT 的方案。由于 OT 有一些不好解决的缺陷，因此 CRDT 成为众多协同产品的技术实现方案。CRDT 的介绍，可以看<a href="https://www.zxch3n.com/crdt-intro/crdt-intro/">这篇文章</a> ，里面的连接挺全。</p><blockquote><p>关于 yjs 的介绍，可以参考 <a href="https://zhuanlan.zhihu.com/p/452980520">Yjs实现</a></p></blockquote><h2 id="vue-socket-io-的发现"><a href="#vue-socket-io-的发现" class="headerlink" title="vue-socket.io 的发现"></a>vue-socket.io 的发现</h2><p>在看 socket-io 的过程中，看到了一个有意思的项目： <a href="https://github.com/MetinSeylan/Vue-Socket.io">Vue-Socket.io</a> , 这个项目在 github 上的赞是有 3.9k 的 (2022/11)，其相关项目 <a href="https://github.com/probil/vue-socket.io-extended">vue-socket.io-extended</a> 的点赞也达到了 600+ 。 </p><p>前者的功能是很简约的，仅仅提供了接收事件的能力，一定程度上封装了 vue store 的 mutation 能力。</p><p>后者在实现上，封装了 vue.Use 用法，写法上更抽象一些，最大的优点在于 提供了 类型，对于开发是很友好的。</p><p>这两个项目其实都是比较简单，但不妨碍很多人对其点赞，因为这对前端同学来说，实现了很有想象空间的能力。所有，对于一个项目而言，评判的标准并不是项目有多复杂，而是这个项目有什么价值？实现了什么能力？占据了什么生态位？</p><p>另外提一嘴，一个后起的项目，如果没有一些强痛点的突破，一般很难发展起来，这是由于生态位被占据了。 但 vue-socket.io-extended 这个项目算是起来了，我归结其原因有 2 ： ① 类型提示，开发更友好 ② 文档齐全，demo 很多。 整体来说，<code>用户友好</code> 算是可以和 <code>生态位</code> 匹敌的因素了。</p><p>vue-socket.io 能解决的问题是： </p><ul><li>将本地事件发送到其他客户端</li><li>接收其他客户端发来的事件</li></ul><p>事件本身可以作为需要传递的东西，用于在多端间进行一些操作触发，例如，在一个直播间里，一个用户操作了 <code>鼓掌</code>，该事件在其他端也可以同步进行动画效果展示。</p><p>事件还可以和 状态 相关联，这类事件 专门为 修改状态 服务，上面这两个库核心能力就是将 socket.io 这个事件传输机制 和 vuex 这个状态管理器 结合。</p><p>状态能相互关联了，想象空间就更大了。 一个 app 的各项能力，实际都是有其数据模型的，模型和展示之间存在着绑定关系 (中间一般挡着一些业务逻辑)，那么，一个供多方使用的功能模块，只要在设计时，就按照多用户使用的场景进行建模，那么就能实现一个用户对自己客户端 model 的修改，也同步到其他端。</p><p>这样的好处是，开发多用户功能时，不用以全局的、通过网络通信的视角看待系统，只需将系统看做一个本地多用户系统即可，在降低开发者心智负担上，还是有不少的价值。</p><p>上面的两个库，实现了前端的 vuex 和 事件接收和发送的打通。在真实应用中，一些简单的场景可以直接使用，例如，一个聊天室中，<code>房间人员</code> 和 <code>房间消息</code> ，这种基本只有 <code>append</code> 和 <code>del</code> 操作的类型，在不考虑严格的顺序情况下，就可以使用。</p><p>那么，如果对于 <code>大家都会操作</code> 的场景，或者有比较严格的 <code>消息顺序</code> 的场景，还是否适用呢？</p><p>这就涉及到协同冲突的问题了。</p><h2 id="协同冲突问题"><a href="#协同冲突问题" class="headerlink" title="协同冲突问题"></a>协同冲突问题</h2><p>多端协同，每一端都拥有一份模型数据的拷贝，且每端都能对模型数据进行操作，那么，在操作的时候，由于有网络传输的存在，就有可能出现 客户端 A 操作了资源 x，然后操作开始往 客户端 B 传输，还没传输到的时候，客户端 B 也操作了 x，并且向 A 发送操作。 当双方都收到操作后，就变成了两个客户端的数据不一致了。</p><p>这种多端协同时，会产生各端数据不一致的情况，就叫做协同冲突。</p><p>处理冲突的方式一般有两种模式： 集中式 和 分散式。 集中式的代表是 OT，中文翻译为 <code>操作转换</code>，处理逻辑是，由中央程序来确定该给协同各方回复什么消息。优点是，数据结构简单明了。缺点是，场景复杂了之后，需要做的操作转换就非常复杂，开发上容易出错。</p><p>最常被举例的场景就是 <code>文档协同</code>，例如一段文字 <code>abc</code>  A 操作了 <code>删除1上的值a</code> 预期是 <code>bc</code>，同时 B 操作了 <code>在2的位置增加x</code> 预期是 <code>axbc</code>， 如果直接把 A 的操作给到 B，就会在 B 处变成 <code>xbc</code>，而 A 处就会变成 <code>bxc</code> ，两边就不一样了。 而 OT ，可能会把给 A 的操作变成 <code>在1的位置增加x</code>，A就成了 <code>xbc</code>，相当于处理了冲突。</p><p>上面是对于数组型顺序冲突的处理。 还有一些其他数据类型的冲突，例如 map。</p><p>另一种分散式的冲突处理方式，典型是 CRDT，这是一种通过在数据结构上下功夫，实现分散式协同过程中保持一致性的一种方案，典型的数据结构设计方案可以参考 Yjs 的实现。</p><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><ol><li>跑通流程</li><li>协同冲突的问题</li><li>封装 sdk</li><li>内网网络性能量化评估</li><li>设计好的接口 几乎是写一个库最有价值的内容！！！ 这就是 <code>建模</code> 的核心。这是软件工程师的核心技能之一。</li></ol><hr><blockquote><p>I will not be concerned at other men’s not knowing me; I will be concerned at my own want of ability.<br>— <cite>Confucius</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>异步通信</tag>
      
      <tag>消息系统</tag>
      
      <tag>协同</tag>
      
      <tag>cooperation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零号机之后的反思</title>
    <link href="/longblog/posts/22_11_01_13_46_review_of_mess_system_generation_zero.html"/>
    <url>/longblog/posts/22_11_01_13_46_review_of_mess_system_generation_zero.html</url>
    
    <content type="html"><![CDATA[<h2 id="零号机的回顾"><a href="#零号机的回顾" class="headerlink" title="零号机的回顾"></a>零号机的回顾</h2><p>在零号机中，我们实现了消息系统的基本能力 – 消息发送</p><p>这个过程也引发了很多思考，例如，为什么我们的接口设计使用的是 <code>xxx/xxx</code> 这种格式，它有什么可解释的含义？为什么不是 <code>xxx.xxx</code> 这种？是否有 <code>通道</code> 这个隐藏概念在里面?  一系列的问题和思考我在 <a href="https://blog.longalong.cn/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html">零号机</a> 中都有罗列。</p><p>在这些问题中，我觉得最值得思考的问题是 “消息系统的交互模型是怎样的？”, 这个问题是之后一切代码设计的基础。 </p><p>如果我们认为，<code>消息系统</code> 和 通常写的 以 http 为典型的业务系统没什么差别，不过都是 发送请求、检查参数、执行逻辑 ，只不过消息系统为了能及时反馈，拥有 ws 这类长连接而已。 那么，代码的设计就很容易变成 <code>零号机</code> 中的这种模式： 在 ws 之上，封装了 <code>请求</code> 和 <code>路由</code>，甚至可以认为，ws 只是一种实现实时通知的方式而已，稍微封装一下就可以变成基于 <code>任何传输层协议</code> 之上的消息系统了，比如基于 http 轮询、http2、tcp、quic 等等……</p><h2 id="从-rpc-框架中找思路"><a href="#从-rpc-框架中找思路" class="headerlink" title="从 rpc 框架中找思路"></a>从 rpc 框架中找思路</h2><p>如果我们走到了这一步，很可能这套框架就逐步走上了 <code>一套 rpc 框架</code> 的道路。如果看过鸟窝大佬的 <a href="https://github.com/smallnest/rpcx">rpcx</a> 框架，就会发现基本就是这样的思路。</p><p>那么，直接用一套 rpc 框架，能不能比较好地满足消息系统的需求呢？这需要继续分析。</p><p>现代的 rpc 框架，基本都会支持两种通信模型： ping/pong 和 stream。</p><p>前者，就是我们最常使用的 发送一个请求，等待一个响应 的模式，不论是 http 请求 还是 常用的 grpc 的请求，都是此类。 这种模型最大的特点就是： 简单可控、易理解。 </p><p>理解起来就是：我(客户端)向你(服务端)发了一个指令(请求)，你就一定会给我一个答案，不给我就等着，还是不给我可能会重发一次，还是不给我就认为你出问题了，然后就走了(也算是得到一个结果: 服务端挂了)。 </p><p>这种模式在代码的逻辑上，都是 <code>同步</code> 的(和语言实现的同步异步无关，仅指逻辑层面)，一定是 <code>发了请求就等着，等到结果就处理之后的逻辑</code>。</p><p>后者，stream，中文名 <code>流</code>，从通信模型的角度可以分成 3 种类型，发送端流、返回端流、双向流，分别对应着 ① 我可以发很多次，但只会收到一次回复 ② 我只会发一次，但会收到很多次回复 ③ 发送端和返回端都可以持续发。 其中，双向流最为典型，也是和我们场景最相符的，因此，要理解清楚这种模式的特征。</p><p>在双向流中，同样可以分为 <code>多个消息</code>，发送的消息可以是 <code>独立的</code>，也可能是 <code>有关联关系的</code>； <code>发送的消息</code> 和 <code>接收到的消息</code>，有可能是独立的，也有可能是有关联关系的。那么这里会存在这几个问题：</p><ul><li>如果是独立的，应该怎样处理这条消息</li><li>如果是关联的，应该怎样标识关联？又怎样处理？</li></ul><p>独立的消息，在消息系统中就像是收到一个外部的偶然消息一样。<br>关联消息，一个场景是：在消息系统中 我发了一个消息，并且我需要这条消息的处理状态。<br>关联消息，另一个场景是： 在消息系统中，我发了一条消息 1，我又发了一条消息 2，其中，如果消息 1 没有成功，不能发送消息 2。</p><p>因此，消息系统的框架需要处理这些场景。这个留待最后梳理。</p><h2 id="从事件机制中找思路"><a href="#从事件机制中找思路" class="headerlink" title="从事件机制中找思路"></a>从事件机制中找思路</h2><p>在程序世界中， <code>消息</code> 和 <code>事件</code> 就像是一个人，在不同的场合换上了不同衣服。 如果我们站在 <code>事件</code> 的角度看消息系统，是否有不同的启发呢？</p><p>和上面的 <code>用 rpc 的视角看消息系统</code> 不同，事件的视角下，我们处理的不再是 <code>请求</code> 了，而是一个我们关心的 <code>事件</code> 出现了，我们需要对这个事件做出反应。</p><p>对象实体上，通常包含这样几个角色： </p><ul><li><code>listener</code>，事件的监听者，也就是我们的业务逻辑处理器，需要在收到事件时进行处理。</li><li><code>publisher</code>，事件发布者，根据业务逻辑决定触发什么事件。</li><li><code>eventhub</code>，登记着各类 listener，并且提供 <code>发布一个事件</code> 的能力，在收到一个事件时，把事件分发给各类 listener。</li></ul><p>这几个只是逻辑上的角色，实现上不一定有直接的结构体来承接，但一定有承接这些职能的主体存在。</p><p>如果对前端了解一些，可能对这种模式就很熟悉了，毕竟整个前端体系都是以 <code>事件分发</code> 为基础的，在 nodejs 中，有现成的 <code>events</code> 官方库可以使用。 要创建一个事件管理器(eventhub)，可以直接这么用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> EventEmitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;events&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXEventHub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>&#123;<br>    <span class="hljs-comment">// …… 一些自己的业务逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 创建一个 hub</span><br><span class="hljs-keyword">let</span> hub = <span class="hljs-keyword">new</span> XXEventHub()<br><br><span class="hljs-comment">// 创建一个处理器</span><br><span class="hljs-keyword">let</span> listener = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 注册一个监听</span><br>hub.on(<span class="hljs-string">&quot;eventname1&quot;</span>, listener)<br><br><span class="hljs-comment">// 触发一个事件</span><br>hub.emit(<span class="hljs-string">&quot;eventname1&quot;</span>, &#123;<br>    <span class="hljs-comment">// 自定义事件结构</span><br>&#125;)<br><br><span class="hljs-comment">// 取消一个监听</span><br>hub.off(<span class="hljs-string">&quot;eventname1&quot;</span>, listener)<br><br></code></pre></td></tr></table></figure><p>大概就是这么简单。</p><p>一般来说，这类事件机制在前端都是只在当前页面生效的，要跨页面，就需要使用浏览器提供的 <code>postMessage</code> 的机制，或者自己用 后台<code>worker</code> 进行一次转发。</p><p>如果希望跨机器，就没有通用的、广泛实践的、开箱即用的技术方案了。 这类需求，在协同类产品中很常见，因此，很多协同类的产品，大都使用 websocket 作为连接通道，在服务端接收消息后再进行一次分发。</p><p>这类需求往往从前端产生，很多时候也是直接由前端同学直接上手做，因此在 nodejs 体系下这类工具还是比较成熟的，用的最最最多的，就是 <a href="https://socket.io/">socket.io</a> ，这几乎是每一个前端同学上手搞 ws 的必经之路。 这个库做的还是很不错的，sdk 从最初的 web端和 nodejs 端，逐渐扩展到很多语言生态，例如 <code>java</code>、<code>C++</code>、<code>Dart</code>、<code>Python</code>、<code>.NET</code>、<code>Go</code> 等。 </p><p>socket.io 是基于 engine.io 的，后者才是真正实现了 websocket 协议的库，而 socket.io 更多做的是 <code>定义交互 api</code> 、<code>实现session</code>、<code>实现降级</code> 之类的。</p><p>在接口上，socket.io 和上面说的 nodejs 的 EventEmitter 几乎保持了一致，对前端同学来说非常友好，官网的例子是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 服务器监听连接建立</span><br>io.on(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 服务器监听事件</span><br>  socket.on(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;client send hello : &quot;</span>, arg); <span class="hljs-comment">// client send hello : I am client</span><br><br>    socket.emit(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;I am server&quot;</span>)<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 客户端 监听事件</span><br>socket.on(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;server send hi : &quot;</span>, arg); <span class="hljs-comment">// server send hi : I am server</span><br>&#125;);<br><br><br><span class="hljs-comment">// 客户端 发送事件</span><br>socket.emit(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;I am client&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>回答一下关心的几个话题：</p><ul><li>是否支持重连和 session： 是</li><li>是否有 <code>通道</code> 的概念： 是</li><li>是否有 <code>回复</code> 的概念： 是 (有 ack，但机制不明朗)</li><li>集群支持如何： 简单使用还ok，扩展性待考察</li></ul><blockquote><p>补充一点，socket.io 有<a href="https://github.com/socketio/socket.io-admin-ui">admin 实现</a>，这对于数据观测而言非常有价值</p></blockquote><blockquote><p>不得不说，对于一些协同类小游戏而言，socket.io 是真的神器。比如像<a href="https://github.com/floatinghotpot/casino-server">这种游戏</a>，一个 redis + socket.io 就搞定所有事儿了。</p></blockquote><blockquote><p>大数据量下，socket.io 的集群机制不大好用，这时候消息系统使用 nats、go-emitter 这类扩展性更好的消息系统。</p></blockquote><h2 id="从流式中间件找灵感"><a href="#从流式中间件找灵感" class="headerlink" title="从流式中间件找灵感"></a>从流式中间件找灵感</h2><p>说到 <code>消息</code> ，一定跑不了 <code>消息中间件</code>，最出名的例如 <code>kafka</code>、<code>rocketMQ</code> 、<code>redis pub/sub</code> 、<code>nats</code>、<code>go-emitter</code> 等等。<br>我们可以分析一下这类中间件的实现，看看他们怎么处理的。</p><h2 id="通信协议的选择"><a href="#通信协议的选择" class="headerlink" title="通信协议的选择"></a>通信协议的选择</h2><ul><li>websocket</li><li>mqtt</li><li>http</li><li>webrtc</li></ul><h2 id="消息中间件和消息分发框架的异同"><a href="#消息中间件和消息分发框架的异同" class="headerlink" title="消息中间件和消息分发框架的异同"></a>消息中间件和消息分发框架的异同</h2><ul><li>消息中间件大多会持久化数据，消息分发框架大多不会</li><li>消息中间件无法在server端添加业务逻辑，消息分发框架主要就是在server端写业务逻辑</li><li>其他方面似乎很相似</li></ul><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li><input disabled="" type="checkbox"> 回顾一下 sarama 的 stream 的实现。</li></ul><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><ul><li><a href="/longblog/posts/22_10_28_15_04_envolution_of_a_message_system.html" name="一个消息系统的进化史" >一个消息系统的进化史</a></li><li><a href="/longblog/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html" name="消息系统进化史-零号机" >消息系统进化史-零号机</a></li></ul><hr><blockquote><p>Discipline is the bridge between goals and accomplishment.<br>— <cite>Jim Rohn</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>异步通信</tag>
      
      <tag>消息系统</tag>
      
      <tag>messenger</tag>
      
      <tag>socket.io</tag>
      
      <tag>websocket</tag>
      
      <tag>rpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搞定前后端一体的状态管理</title>
    <link href="/longblog/posts/22_10_31_22_30_how_to_master_statement_management_in_fb_mode.html"/>
    <url>/longblog/posts/22_10_31_22_30_how_to_master_statement_management_in_fb_mode.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在写 <a href="/longblog/posts/22_10_28_15_04_envolution_of_a_message_system.html" name="一个消息系统的进化史" >一个消息系统的进化史</a> ，写的过程也是不断思考的过程，于是，我自然而然地会去思考： 消息的触发机制往往是一个外部状态的变动，然后在消息系统的分发中枢做分发，那么，是否存在内部的状态变动而触发消息的需求呢？</p><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>在前端体系下，这是一个非常常见的需求，例如在浏览器中，维护一个 global 状态，其他各处的组件都可以监听这个状态的变动，由此触发一系列的连锁变动。在现代前端框架中，vue 下的 vuex，react 下的 redux 都是在做这件事。 即使是最原始的 OBM，监听元素变动事件也是这样的机制。</p><p>然而在服务端，这个场景不是特别典型。在当前流行的后端架构下，应用的分布式部署 和 无状态化 成为主流，<code>状态</code> 都是由中央数据库(中间件)维护的，即使要实现消息的分发，也几乎是位处中央的中间件去实现，例如 mysql、monogo、redis 等等。</p><p>而实际上，确实非常多的中央数据库都实现了 watcher 接口，例如 mongodb、redis、rocketMQ、zookeeper、etcd 等等。</p><h2 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h2><p>虽然主流的场景下直接使用中央数据库的 watcher 就可以了，但仍然也存在单机下，通过内存维护状态，并且有监听需求的场景，因此，决定写一个简单的可监听 map 变动的工具。</p><p>在消息系统的场景中，目前能想到的应用是： </p><p>单机上的 room 存在一些公共状态，在这个 room 中的很多成员都有修改这些状态的能力，例如 <code>房间名称</code> 、<code>房间描述</code>、<code>是否允许自由加入</code> 等等，如果把这些变成一个个的接口，则会有不少冗余的开发，如果把这些变成每个连接监听的状态，状态发生变动时，自动推送变动通知，则相当于客户端和服务端存在一个共同的状态管理了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// init a new responsive map</span><br>rmap := NewResponsiveMap()<br><br><span class="hljs-comment">// create a key listener</span><br>cityKeyListener := NewMapListener(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(me MapEvent)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;city changed, key: %s, option type: %s, oldval: %+v, newval: %+v\n&quot;</span>, me.Key, me.Option, me.OldVal, me.NewVal)<br>&#125;)<br><br><span class="hljs-comment">// watch key</span><br>rmap.Watch(cityKeyListener)<br><br><span class="hljs-comment">// set a city, this will trigger the listener above</span><br>rmap.Set(<span class="hljs-string">&quot;city.name&quot;</span>, <span class="hljs-string">&quot;beijing&quot;</span>)<br>rmap.Set(<span class="hljs-string">&quot;city.size&quot;</span>, <span class="hljs-string">&quot;huge&quot;</span>)<br><br><span class="hljs-comment">// try get, this will trigger too</span><br>v, err := rmap.Get(<span class="hljs-string">&quot;city.name&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;got city name : %s\n&quot;</span>, v)<br><br><span class="hljs-comment">// try del, this will trigger as well</span><br>err = rmap.Del(<span class="hljs-string">&quot;city&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于是在写 <a href="/longblog/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html" name="消息系统进化史-零号机" >消息系统进化史-零号机</a> 的过程中想到要实现该能力的，因此代码就先放在同一个仓库中了，详情见 <a href="https://github.com/iamlongalong/bigmess/tree/main/pkg/responsivemap">bigmess/pkg/responsivemap</a></p><p>在写完这个项目后，发现了另外两个项目，和我这个实现的理念不谋而合：</p><ul><li><a href="https://github.com/MetinSeylan/Vue-Socket.io">vue-socket-io</a> 以及其相同能力的实现 <a href="https://github.com/probil/vue-socket.io-extended">socket.io-extended</a></li><li><a href="https://github.com/itaylor/redux-socket.io">redux-socket.io</a></li></ul><p>实际上，状态的同步，如果以 <code>中心化</code> 的理念去设计，就需要在服务端有一个同样的数据模型，并且所有的触发操作以中心节点的变更为准。 如果是以 <code>去中心化</code> 的理念来设计，服务端只要有一个消息转发机制就行了。</p><p>去中心化的理念，在一些协同场景中，就会结合到 CRDT 之类的方案； 而中心化的理念，协同场景中就会有 OT 之类的方案。</p><p>甚至你会发现，上面这类 vue-socket.io 的能力，如果把基于 vuex 的部分变成基于 yjs 这类，就成了一个分布式的、拥有 CRDT 能力的协同操作场景了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul><li><input disabled="" type="checkbox"> 看情况考虑实现数组的监听</li><li><input disabled="" type="checkbox"> 将库进行分层组装，暴露该暴露的</li><li><input disabled="" type="checkbox"> 使用 eventhub 找到更好的实现监听机制的写法</li><li><input disabled="" type="checkbox"> 写一些 redis、zk、etcd、rocketMQ、mongodb 的监听机制的 demo #important </li><li><input disabled="" type="checkbox"> 在消息系统一号机中，使用该库形成前后一体状态管理</li><li><input disabled="" type="checkbox"> 考虑分布式状态管理的实现</li></ul><hr><blockquote><p>True happiness arises, in the first place, from the enjoyment of oneself, and in the next, from the friendship and conversation of a few select companions.<br>— <cite>Joseph Addison</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>实践</tag>
      
      <tag>golang</tag>
      
      <tag>事件机制</tag>
      
      <tag>responsive</tag>
      
      <tag>responsive map</tag>
      
      <tag>响应式map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息系统进化史-零号机</title>
    <link href="/longblog/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html"/>
    <url>/longblog/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我们回到最最最初的目标，实现一个最最最简单的消息分发系统。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>客户端有一些消息，想要发送给其他客户端。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>服务端有提供消息上传和分发的能力</li><li>客户端上传消息可以通过 http 也可以通过 websocket</li><li>考略到消息的实时性要求比较高，通过 websocket 分发</li></ul><h2 id="需求的技术分析以及调研"><a href="#需求的技术分析以及调研" class="headerlink" title="需求的技术分析以及调研"></a>需求的技术分析以及调研</h2><ul><li><p>有竞争力一点的是 nodejs 生态 和 golang 生态。 nodejs 是因为和客户端语言生态一致，或许将来可以直接提供一致的SDK，nodejs 的异步机制能提供高并发。服务端目前都是以 golang 为基本语言，要提供的这个能力在 golang 上没有什么硬伤，golang 也天然支持高并发。 考虑到项目的主维护团队是 服务端团队，且 nodejs 在部署侧、后续维护性等方面弱于 goalng，因此选择 golang 为基础生态。</p></li><li><p>websocket 需要先有 http 服务，可以使用原生的 golang http 包，也可以使用第三方的包。这不是个大问题的抉择，但考虑到其他服务主要使用的 <a href="https://github.com/gin-gonic/gin">gin</a> 这个 http 框架，为了少踩坑，也为了降低将来团队内维护的阻力，我们也采用 gin 框架作为 http 部分。</p></li><li><p>websocket 能力在 golang 下主要有 4 个实现，分别是 ① golang 官方库  ② <a href="https://github.com/gobwas/ws">gobws/ws</a> ③ <a href="https://github.com/gorilla/websocket">gorilla/websocket</a>④ <a href="https://github.com/googollee/go-socket.io">socket.io</a> 。从协议实现完善度上，官方库稍次，gobws 和 gorilla 和 socket.io 差不多。 从性能上，gobws 是最好的。 从易用性上，socket.io 是最好的，这是一个封装了很多东西的库，从 nodejs 版本复刻过来的，底层实现是基于 gorilla 的。gorilla 是一个没有封装太多东西的纯 websocket 实现，可定制空间更大。 考虑到社区中使用最多的是 gorilla 的库，并且我们当前对性能的需求没那么大，更在意易用性，因此选择 gorilla/websocket 的方案了。 </p></li></ul><blockquote><p>没有选 socket.io 是由于整体来看它没有那么直接，有些东西算是黑盒，例如 http 降级、session封装、二进制消息封装等等，对我们来说不够透明，现在也没有那么多的时间和精力去细致地调研</p></blockquote><ul><li><p>业务逻辑上，存在 ”房间“ 的概念，这个房间内的消息是可以广播出去的。</p></li><li><p>在接收到消息后，有一些消息不需要做业务逻辑处理，直接分发到对应的通道中 (不那么重要的消息)。也有一些类型的消息需要做一些业务逻辑处理，然后由业务逻辑决定是否分发、怎么分发 (有特殊含义的消息)。</p></li><li><p>客户端可以做消息过滤，有些消息可以选择不接收，有些消息要接收。但不是每个消息都能由客户端决定是否接收。</p></li><li><p>客户端加入房间需要做权限校验，未通过鉴权的不给加入房间。</p></li><li><p>客户端发送的消息有限制，不是每个客户端都能发送每种消息。</p></li><li><p>当前业务的量非常小，仅仅是 MVP 实验阶段，因此直接用单机部署即可。</p></li></ul><h2 id="技术设计"><a href="#技术设计" class="headerlink" title="技术设计"></a>技术设计</h2><ul><li>实现 room 的概念，room hub 的概念，room 提供 <code>pub</code>/<code>join</code>/<code>leave</code> 三个接口。</li><li>在 ws 的协议之上，设计 <code>消息码</code> 的概念，对应到 http 请求中的 <code>请求行</code>，用来标识不同的请求类型，以此分发到不同的 hanlder 上。 handler 是实际提供业务逻辑的方法。</li><li>根据业务场景，auth 受到 role 的约束，例如 <code>管理员</code> 拥有发送一些特定请求的权力，而 <code>成员</code> 仅能发送通用请求的能力，<code>观察者</code> 甚至无法发送消息，仅能被动接受消息。 当前角色的权限模型不清晰，在程序中先体现为简单的 <code>if/else</code> 判断。</li><li>消息的结构需要有统一的约定，考虑到请求可能会带一些 <code>元信息</code>，因此和 http 请求类似，存在 <code>header</code> 部分，除了 header，还有 <code>消息码</code> 和 <code>body</code>。 为了开发简单，序列化直接用 json 进行传输即可。</li></ul><h2 id="前期总结"><a href="#前期总结" class="headerlink" title="前期总结"></a>前期总结</h2><p>以上就是我们第一版的需求情况，简单来说，就是一个简单的、常规的 websocket 服务。</p><h2 id="其他层面的思考"><a href="#其他层面的思考" class="headerlink" title="其他层面的思考"></a>其他层面的思考</h2><ol><li>框架中是否应该直接包含 room 的机制？ 还是交给业务层自己做？</li><li>http 是 ping/pong 机制，ws 是什么机制？应该是什么机制？有什么利弊？</li><li>框架是怎么产生的？上来就设计？还是写业务代码，然后抽象、封装？</li><li>在消息驱动的系统中，接口名设计有些什么内在需求？</li><li>pub/sub 和 watch/listen 有什么异同？</li><li>消息码的设计用 path 做分组更合适，还是用 namespace 做分组更合适?</li><li>在框架之下是否需要存在 <code>通道</code> 这一个概念？ </li></ol><h2 id="技术设计的细节问题"><a href="#技术设计的细节问题" class="headerlink" title="技术设计的细节问题"></a>技术设计的细节问题</h2><h3 id="消息码的设计"><a href="#消息码的设计" class="headerlink" title="消息码的设计"></a>消息码的设计</h3><p>消息分发时，需要有标识来将请求分发到不同的流程。在 http 中, 这个标识是 <code>请求行</code> 也就是 <code>method + path</code> 的方式， 在 grpc 中，这是一个字符串，由 <code>包名 + 服务名 + 方法名</code> 构成，例如 <code>/xxxService.xxService/Doxxx</code> 。 在 ws 的设计中，我们可以用同样的方式来设计，结构可能如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;messageCode&quot;</span>: <span class="hljs-string">&quot;publish&quot;</span>,<br>    <span class="hljs-attr">&quot;header&quot;</span>: &#123;&#125;,<br>    <span class="hljs-attr">&quot;body&quot;</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但这样的区分度就不高了，没有 <code>分组</code> 的概念在当中，为了增加将来的可扩展性，增加分组，变成和 path 类似的格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;messageCode&quot;</span>: <span class="hljs-string">&quot;/fileroom/publish&quot;</span>,<br>    <span class="hljs-attr">&quot;header&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;customMeta&quot;</span>: &#123;<span class="hljs-attr">&quot;roomID&quot;</span>: <span class="hljs-string">&quot;123456&quot;</span>&#125;<br>    &#125;,<br>    <span class="hljs-attr">&quot;body&quot;</span>: <span class="hljs-string">&quot;A79a11209b123b90==&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然长得像是个阉割版的 http，但能解决我们的问题了，不错。</p><blockquote><p>为什么叫 messageCode ? 没为啥，一个称呼而已，就跟 http 叫 path、 rpc 中叫 method 一样，ws 中可以认为万物皆 “消息”，不妨就叫 消息码。</p></blockquote><p>在实现消息分发时，先不做分组的实现了，相当于虽然不在程序中处理分组，一个 messageCode 就是一个路由。但这种方式存在了分组的潜力，将来可以加上分组的概念，比如增加 分组 Middleware 之类的能力。</p><h3 id="房间的设计"><a href="#房间的设计" class="headerlink" title="房间的设计"></a>房间的设计</h3><p>在需求中，主要的场景是： 把同一个房间内的消息广播出去。 因此，我们要在程序中实现 <code>房间</code>。 </p><p>从行为上看，一个房间最起码需要具备这些能力： </p><ul><li>把一个 client 加入到房间中</li><li>把一个 client 移出某个房间</li><li>把一个消息在房间内广播</li></ul><p>client 最好有一个 id，用来全局唯一标识一个 client。 我们给 client 增加一个 <code>func ID() string</code> 的方法。</p><p>那么 room 的结构姑且为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IRoom <span class="hljs-keyword">interface</span> &#123;<br>     JoinRoom(c *Client) error <br>     Leave(ID <span class="hljs-keyword">string</span>) error<br>     BoardCast(msg *Message) error <br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个最简的 room 了，有什么更多的需求之后再说。</p><p>除了 <code>房间</code> 外，我们还需要一个 <code>房间管理器</code>，这个东西从行为上，需要有这些能力：</p><ul><li>在全局创建房间</li><li>获取房间的实例</li><li>销毁一个房间</li><li>给一些/所有房间广播消息</li></ul><p>那么这个管理器姑且为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IRoomHub <span class="hljs-keyword">interface</span> &#123;<br>    GetRoom(ID <span class="hljs-keyword">string</span>) (IRoom, <span class="hljs-keyword">bool</span>)<br>    CreateRoom(ID <span class="hljs-keyword">string</span>) (IRoom, error)<br>    GetOrCreateRoom(ID <span class="hljs-keyword">string</span>) (IRoom,error)<br>    DestoryRoom(ID <span class="hljs-keyword">string</span>) error<br>    BoardCast(msg *Message, roomIds ...<span class="hljs-keyword">string</span>) error<br>&#125;<br></code></pre></td></tr></table></figure><p>销毁房间的方法中，我们姑且只是把这个房间从管理器中移除，暂时不错更复杂的交互处理。</p><p>roomhub 姑且采用单例模式，毕竟现在来看，我们的 hub 只需要有一个就行了。</p><h3 id="message-的设计"><a href="#message-的设计" class="headerlink" title="message 的设计"></a>message 的设计</h3><p>在消息的处理过程中 ，我们需要持续将 message 往下传，那么 message 的格式应该是什么样的呢？</p><p>在 http 体系下，最常用的方式，就是不同接口定义不同的 model 类型，在接口中去做 Unmarshal 操作，然后将自定义的 model 往下传。 这样的好处在于，流程清晰，实现简单。 坏处在于，基于 model 的传递，意味着所有处理函数都是 <code>硬编码</code> 的，只能接收特定的参数，增加了冗余代码的工作量。</p><p>我们可以选择用 接口 的方式，message 分成的几个部分，分别用接口获取，接口类似于如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IMessage <span class="hljs-keyword">interface</span> &#123;<br>    MessageCode() MessageCode<br>    Header() MessageHeader<br>    Body() ???<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就会发现，前两部分都是确定的类型，但是 body 的类型是不定的，是根据接口自行定义的，如何解决 Imessage 往下传递时，保持同样的接口，而 body 又能实现多态呢？</p><p>有这么几种思路：</p><ol><li>全局统一实现 json decoder、pb decoder 等等，直接在解 IMessage 时就转成结构体 (需要在初始化时注册结构体)，然后用 <code>interface&#123;&#125;</code> 往下传递，使用的时候直接类型断言。</li><li>IMessage 不处理 body，而是直接以 <code>[]byte</code> 的结构传给下游处理，handler 增加一个 Decode() 的方法。</li><li>使用接口定义文档，定义好接口后，自动生成对应的 decode 方法，并生成对应的方法函数，以此降低手工维护冗余代码的工作量。</li></ol><p>这几种思路各有优劣，第一种，优点是，能够保证接出来的结构体能在多个 middleware 中使用，缺点是，用 interface{} 做类型断言比较难看。<br>第二种，优点是，流程清晰易理解，是现有的 http 体系下常用的方案，缺点是，middleware 中如果想使用 body，就得重复解body。<br>第三种，优点是，生成后的代码很好理解，开发时也很友好，缺点是，实现的成本较高，需要开发一系列的工具。</p><p>考虑到 第二种整体容易理解，开发成本也比较低，多个 middleware 要使用 body 的假设也不知道是否真的成立，因此先采用这种方案，后面遇到实际的问题再改吧。</p><p>另外，第三种方案之后可以考虑做一下，思路比较有意思。实际上，像 grpc 和 go-zero 都是采用的这种方案，确实十分好用。</p><h3 id="连接的建立过程"><a href="#连接的建立过程" class="headerlink" title="连接的建立过程"></a>连接的建立过程</h3><p>在通过了 ws 的格式校验后 (upgrade)，算是把连接建立好了，按理下一步就是业务逻辑，但是，很多业务逻辑都有相同的前置条件，例如 <code>鉴权</code>。 </p><p>而 ws 和 http 很大的不同就是，http 的鉴权往往是直接通过 header 中的 token ，或者通过 Cookie 中的 sessionID，然后从 <code>内存缓存</code> 中、<code>redis</code> 中、<code>数据库</code> 中、<code>外部系统</code> 等方式进行 校验 以及 获取 user 信息 (用户基本信息，看场景有时候也可以包含 role 等权限信息)。</p><p>在 http 中，我们鉴权是直接通过 MiddleWare 对所有接口 或者 一些接口组 进行鉴权，这是增量法，有时候根据情况会使用接口白名单的方式反向剔除一些，这是排除法。</p><p>ws 是一个 <code>有状态</code> 的协议。 相比于 http 需要每次传递 token， ws 可以直接把各自认可的东西放在内存里，我们可以称之为 <code>已认可状态</code>，这样就可以不用每次都传递相同的东西了，例如 token。 比如鉴权过程，不同接口的鉴权，我们直接在 client 中添加一个 key 为 “user”, 当这个值存在内容时，我们就认为已经做过登录验证了，其他类似。</p><p>实际上，ws 的这种 <code>状态</code> ，在 http 的生态下也是存在的，session 和它实现的功能是一样的，不同点在于，http 是不保证 <code>连接持续存在</code> 的，因此 http 不能使用 <code>连接</code> 来关联 session，所以呈现出了用一个唯一 id 来关联的现状。 而这种状态的关联，在 ws 下则直接以 <code>tcp连接</code> 来保证存续和映射。</p><p>基于以上分析，我们把 状态 交给 client 实例去负责，各个接口通过各自的 middleware 去做各自关心的逻辑，middleware 直接从 client 实例中去获取自己关心的状态值。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><a href="https://github.com/iamlongalong/bigmess/tree/main/m0">bigmess 零号机</a></p><h3 id="演示一下"><a href="#演示一下" class="headerlink" title="演示一下"></a>演示一下</h3><p>[TODO]</p><h2 id="结尾稍微总结一下"><a href="#结尾稍微总结一下" class="headerlink" title="结尾稍微总结一下"></a>结尾稍微总结一下</h2><p>这个项目写的比较简单，有很多地方都写得很丑，也没有可扩展性，但时间紧急，这版能基本能满足我们一期的需求了，之后我们把这些地方找出来，进行一些改进。</p><p>二期的需求正在策划中，详情可以从 <a href="/longblog/posts/22_10_28_15_04_envolution_of_a_message_system.html" name="一个消息系统的进化史" >一个消息系统的进化史</a> 查看后续进度。</p><h2 id="导航直通车"><a href="#导航直通车" class="headerlink" title="导航直通车"></a>导航直通车</h2><p><a href="/longblog/posts/22_10_28_15_04_envolution_of_a_message_system.html" name="一个消息系统的进化史" >一个消息系统的进化史</a></p><hr><blockquote><p>You’re never a loser until you quit trying.<br>— <cite>Mike Ditka</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>异步通信</tag>
      
      <tag>消息系统</tag>
      
      <tag>messenger</tag>
      
      <tag>实践项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个消息系统的进化史</title>
    <link href="/longblog/posts/22_10_28_15_04_envolution_of_a_message_system.html"/>
    <url>/longblog/posts/22_10_28_15_04_envolution_of_a_message_system.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>好的架构不是一蹴而就的，而是一步步演化出来的。</p><p>学习一个东西最好的方式，往往是先实践，再理论抽象，再实践。很多时候，几百万的文字，都不敌一次实践的演示。</p><p>所以，我希望从消息系统的最初状态，一步步演进出一套消息系统，在这个过程中去思考架构的各种问题。</p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>这是一个在线协同产品的消息系统部分，我们将从最原始的需求开始，随着业务需求的逐步变更、技术需求的变更，一步一个脚印地去认识一个消息系统的架构演进的抉择。</p><p>项目是编的，迭代步骤也是编的，目的是保证能更直观地理解架构的演进。</p><h2 id="迭代ing"><a href="#迭代ing" class="headerlink" title="迭代ing"></a>迭代ing</h2><h3 id="初代机"><a href="#初代机" class="headerlink" title="初代机"></a>初代机</h3><p><a href="/longblog/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html" name="消息系统进化史-零号机" >消息系统进化史-零号机</a></p><h3 id="一代机"><a href="#一代机" class="headerlink" title="一代机"></a>一代机</h3><p><a href="/notpublish/index.html" name="消息系统进化史-一号机" >消息系统进化史-一号机</a></p><h3 id="二代机"><a href="#二代机" class="headerlink" title="二代机"></a>二代机</h3><p><a href="/notpublish/index.html" name="消息系统进化史-二号机" >消息系统进化史-二号机</a></p><hr><blockquote><p>If you want your life to be more rewarding, you have to change the way you think.<br>— <cite>Oprah Winfrey</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>异步通信</tag>
      
      <tag>消息系统</tag>
      
      <tag>messenger</tag>
      
      <tag>实践项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb实验环境搭建记录</title>
    <link href="/longblog/posts/22_10_27_10_50_experiment_env_of_mongodb.html"/>
    <url>/longblog/posts/22_10_27_10_50_experiment_env_of_mongodb.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>mongodb 是一个非常通用的文档型数据库，在后端开发过程中经常被用到。为了能够更好地掌握 mongodb，我们需要一套快速可使用的环境，用于开发、测试等。</p><h2 id="基本形态"><a href="#基本形态" class="headerlink" title="基本形态"></a>基本形态</h2><ul><li>docker</li><li>k8s</li></ul><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p>通过在 <a href="https://hub.docker.com/search?q=mongodb">dockerhub</a> 上搜索 mongodb，发现有大量的镜像提供者。看到 mongo 官方的镜像 和 bitnami 提供的镜像 使用量最大，考虑到 bitnami 生态更加完善，因此选择 <a href="https://hub.docker.com/r/bitnami/mongodb">bitnami/mongodb</a> 作为镜像。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="拉镜像"><a href="#拉镜像" class="headerlink" title="拉镜像"></a>拉镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull bitnami/mongodb:6.0<br></code></pre></td></tr></table></figure><h4 id="直接通过-docker-运行"><a href="#直接通过-docker-运行" class="headerlink" title="直接通过 docker 运行"></a>直接通过 docker 运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建网桥</span><br>docker network create mongonet --driver bridge<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    -e ALLOW_EMPTY_PASSWORD=yes \<br>    -e MONGODB_EXTRA_FLAGS=&#x27;--wiredTigerCacheSizeGB=2&#x27; \<br>    -e MONGODB_ENABLE_JOURNAL=true \<br>    -e MONGODB_ROOT_PASSWORD=password123 \<br>    -e MONGODB_USERNAME=testuser \<br>    -e MONGODB_PASSWORD=123456 \<br>    -e MONGODB_DATABASE=testdb \<br>    -e MONGODB_REPLICA_SET_MODE=primary \<br>    -e MONGODB_REPLICA_SET_NAME=testreplicaset \<br>    -e MONGODB_PORT_NUMBER=27017 \<br>    -v /data/mongotest:/bitnami/mongodb \<br>    -v /data/mongotest/init:/docker-entrypoint-initdb.d \<br>    --name mongomaster \<br>    --network mongonet \<br>    -p 27017:27017 \<br>    bitnami/mongodb:6.0<br></code></pre></td></tr></table></figure><h4 id="配置-docker-compose-yaml-文件"><a href="#配置-docker-compose-yaml-文件" class="headerlink" title="配置 docker-compose.yaml 文件"></a>配置 docker-compose.yaml 文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.3&#x27;</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">mongonet:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mongodb:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/bitnami/mongodb:6.0</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;27017:27017&#x27;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/data/mongotest:/bitnami/postgresql&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/data/mongotest/init:/docker-entrypoint-initdb.d&#x27;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_EXTRA_FLAGS=&quot;--wiredTigerCacheSizeGB=2&quot;&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_ENABLE_JOURNAL=true&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_ROOT_PASSWORD=password123&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_USERNAME=testuser&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_PASSWORD=123456&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_DATABASE=testdb&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_REPLICA_SET_MODE=primary&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_REPLICA_SET_NAME=testreplicaset&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MONGODB_PORT_NUMBER=27017&#x27;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mongonet</span><br><br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 做mongodb从库搭建的实验</li><li><input disabled="" type="checkbox"> 做mongodb集群搭建实验</li></ul><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>charts 同样选择 <a href="https://github.com/bitnami/charts/tree/main/bitnami/mongodb">bitnami</a> 的库。</p><p>helm 下载及安装可以查看 <a href="/longblog/posts/22_10_20_12_10_experiment_env_of_postgresql.html#下载 helm" name="postgresql实验环境搭建" >postgresql实验环境搭建</a></p><h4 id="查看-charts"><a href="#查看-charts" class="headerlink" title="查看 charts"></a>查看 charts</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm fetch bitnami/mongodb --untar<br><span class="hljs-comment"># 看情况修改需要的参数</span><br></code></pre></td></tr></table></figure><h4 id="修改mongodb密码等基本信息"><a href="#修改mongodb密码等基本信息" class="headerlink" title="修改mongodb密码等基本信息"></a>修改mongodb密码等基本信息</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># vim values.yaml</span><br><span class="hljs-attr">auth:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">rootUser:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">rootPassword:</span> <span class="hljs-string">&quot;123456&quot;</span><br>  <span class="hljs-attr">usernames:</span> [<span class="hljs-string">&quot;testuser&quot;</span>]<br>  <span class="hljs-attr">passwords:</span> [<span class="hljs-string">&quot;123456&quot;</span>]<br>  <span class="hljs-attr">databases:</span> [<span class="hljs-string">&quot;testdb&quot;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>更详细的配置，可以参考 <a href="https://github.com/bitnami/charts/tree/main/bitnami/mongodb">bitnami 的 github</a></p></blockquote><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm install mongodb .<br></code></pre></td></tr></table></figure><h3 id="修改-service"><a href="#修改-service" class="headerlink" title="修改 service"></a>修改 service</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit svc mongodb<br><br><span class="hljs-comment"># 修改 Cluster 为 LoadBalancer/NodePort </span><br></code></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongo mongodb://root:123456@xxx.xxx.xx.xx:27017/?authSource=admin<br></code></pre></td></tr></table></figure><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>二进制也可以安装，可以在网上查下资料，姑且不做操作了。下面安装 mongo 是为了使用 client。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置 mongodb 源</span><br>cat &lt;&lt;<span class="hljs-string">eof &gt; /etc/yum.repos.d/mongodb-org-5.0.repo</span><br><span class="hljs-string">[mongodb-org-6.0]</span><br><span class="hljs-string">name=MongoDB Repository</span><br><span class="hljs-string">baseurl=https://repo.mongodb.org/yum/redhat/7Server/mongodb-org/6.0/x86_64/</span><br><span class="hljs-string">gpgcheck=1</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc</span><br><span class="hljs-string">eof</span><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装稳定版</span><br>yum install -y mongodb-org<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当然也可以指定版本安装</span><br>sudo yum install -y mongodb-org-6.0.0 mongodb-org-server-6.0.0 mongodb-org-shell-6.0.0 mongodb-org-mongos-6.0.0 mongodb-org-tools-6.0.0<br></code></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul><li>增加 mongodb 的维护教程</li><li>增加 mongodb 的原理教程</li><li>增加 mongodb 监控的添加</li></ul><p>更详细的 mongodb 参数可以查看<a href="https://mongodb.net.cn/manual/reference/parameters/">中文文档</a></p><hr><blockquote><p>Take up one idea. Make that one idea your life - think of it, dream of it, live on that idea. Let the brain, muscles, nerves, every part of your body, be full of that idea, and just leave every other idea alone. This is the way to success.<br>— <cite>Swami Vivekananda</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>operation</tag>
      
      <tag>mongodb</tag>
      
      <tag>mongo</tag>
      
      <tag>database</tag>
      
      <tag>实验环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql实验环境搭建</title>
    <link href="/longblog/posts/22_10_25_12_13_experiment_env_of_mysql.html"/>
    <url>/longblog/posts/22_10_25_12_13_experiment_env_of_mysql.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>mysql 是一个非常非常通用的关系型数据库，在后端开发中非常经常被用到。这里做一下 mysql 实验环境的搭建记录。</p><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p>通过在 <a href="https://hub.docker.com/search?q=mysql">dockerhub</a> 上搜索 mysql，发现有大量的镜像提供者。之前已经用过 bitnami 的 pg 了，考虑到 bitnami 生态更加完善，因此选择 <a href="https://hub.docker.com/r/bitnami/mysql">bitnami/mysql</a> 作为镜像。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>搭建过程比较简单，直接参考 <a href="https://hub.docker.com/r/bitnami/mysql">bitnami/mysql</a> 的文档即可。</p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="拉镜像"><a href="#拉镜像" class="headerlink" title="拉镜像"></a>拉镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull bitnami/mysql:5.7.40<br></code></pre></td></tr></table></figure><h4 id="直接通过-docker-运行"><a href="#直接通过-docker-运行" class="headerlink" title="直接通过 docker 运行"></a>直接通过 docker 运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run \<br>    -e MYSQL_USER=root \<br>    -e MYSQL_PASSWORD=password123 \<br>    -e MYSQL_DATABASE=testmysql \<br>    -e ALLOW_EMPTY_PASSWORD=yes \<br>    -e MYSQL_ROOT_PASSWORD=password123 \<br>    -e MYSQL_REPLICATION_MODE=master \<br>    -e MYSQL_REPLICATION_USER=user_repl \<br>    -e MYSQL_REPLICATION_PASSWORD=password123 \<br>    -v /data/mysqltest:/bitnami/mysql \<br>    --name mysqlmyster \<br>    -p 3306:3306 \<br>    bitnami/mysql:5.7.40<br></code></pre></td></tr></table></figure><h4 id="配置-docker-compose-yaml-文件"><a href="#配置-docker-compose-yaml-文件" class="headerlink" title="配置 docker-compose.yaml 文件"></a>配置 docker-compose.yaml 文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.3&#x27;</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">mysqlnet:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/bitnami/mysql:5.7.40</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;3306:3306&#x27;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/data/mysqltest:/bitnami/mysql&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/data/mysqltest/init:/docker-entrypoint-initdb.d&#x27;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MYSQL_USER=root&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MYSQL_PASSWORD=password123&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MYSQL_DATABASE=testmysql&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MYSQL_ROOT_PASSWORD=password123&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MYSQL_REPLICATION_MODE=master&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MYSQL_REPLICATION_USER=user_repl&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;MYSQL_REPLICATION_PASSWORD=password123&#x27;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">mysqlnet</span><br></code></pre></td></tr></table></figure><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>charts 同样选择 <a href="https://github.com/bitnami/charts/tree/main/bitnami/mysql">bitnami</a> 的库<br>如何添加 helm 库，可以参考 <a href="/longblog/posts/22_10_20_12_10_experiment_env_of_postgresql.html#下载 helm" name="postgresql实验环境搭建" >postgresql实验环境搭建</a></p><h5 id="查看-charts"><a href="#查看-charts" class="headerlink" title="查看 charts"></a>查看 charts</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm fetch bitnami/mysql --untar<br><span class="hljs-comment"># 看情况修改需要的参数</span><br></code></pre></td></tr></table></figure><h5 id="修改-values-yaml-中的-auth"><a href="#修改-values-yaml-中的-auth" class="headerlink" title="修改 values.yaml 中的 auth"></a>修改 values.yaml 中的 auth</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">auth:</span><br>  <span class="hljs-attr">rootPassword:</span> <span class="hljs-string">&quot;password123&quot;</span><br>  <span class="hljs-attr">createDatabase:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">&quot;testmysql&quot;</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;root&quot;</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;123456&quot;</span><br>  <span class="hljs-attr">replicationUser:</span> <span class="hljs-string">&quot;repl_user&quot;</span><br>  <span class="hljs-attr">replicationPassword:</span> <span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm install mysql ./mysql<br></code></pre></td></tr></table></figure><h3 id="修改-service"><a href="#修改-service" class="headerlink" title="修改 service"></a>修改 service</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit svc xxxx<br><br><span class="hljs-comment"># 修改 Cluster 为 LoadBalancer/NodePort </span><br></code></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">k <span class="hljs-built_in">exec</span> -it mysql-0 -- mysql -uroot -p123456<br></code></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 继续完成 k8s 的部署 ✅ 2022-10-26</li><li><input disabled="" type="checkbox"> 完成 mysql 的复制集搭建</li><li><input disabled="" type="checkbox"> 完成 mysql 的备份恢复等维护工作</li></ul><hr><blockquote><p>Do not overrate what you have received, nor envy others. He who envies others does not obtain peace of mind.<br>— <cite>Buddha</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>operation</tag>
      
      <tag>database</tag>
      
      <tag>实验环境</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT简单实践</title>
    <link href="/longblog/posts/22_10_24_16_53_practice_of_mqtt.html"/>
    <url>/longblog/posts/22_10_24_16_53_practice_of_mqtt.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在物联网中，MQTT 是一个非常通用的协议，为了能更好地认识和理解 mqtt，需要实际跑起来一个 mqtt 的项目。这里将会记录实践 MQTT 的过程。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>MQTT 协议的实现过程中有 3 个角色: ① publisher (发布者)  ② broker (服务器) ③ subscriber (订阅者)。</p><p>消息包含两个部分： 消息主题(topic)、消息内容 (payload)</p><p>MQTT 协议会解决： 建立连接、session、顺序、消息质量、消息加密、消息传输 这些问题，当然有些特性是可配置的，比如消息质量、消息加密等。</p><h2 id="broker-选择"><a href="#broker-选择" class="headerlink" title="broker 选择"></a>broker 选择</h2><p>服务器实现比较多，例如 <a href="https://github.com/moscajs/aedes">aedes</a>、<a href="https://github.com/hivemq/hivemq-community-edition">hivemq</a>、<a href="https://github.com/eclipse/mosquitto">mosquitto</a>、<a href="https://github.com/VolantMQ/volantmq">volantmq</a>、<a href="https://github.com/emqx/emqx">EMQX</a>、<a href="https://github.com/moquette-io/moquette">moquette</a>、<a href="https://github.com/fhmq/hmq">hmq</a>、Rabbimq + mqtt plugin 等等，更多信息可以参考 <a href="https://www.jianshu.com/p/cf91f4bea071">MQTT broker 选型</a><br>基于一系列原因，我选择了 EMQX 这个实现，这里是 <a href="https://hub.docker.com/_/emqx/tags">官方 docker 镜像</a>，这里是 <a href="https://www.emqx.io/docs/zh/v5.0/">中文文档</a>。</p><h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p>k8s 中可以这么操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行pod</span><br>k run emqx --image  emqx:4.4.4 --label app=emqx<br><br><span class="hljs-comment"># 创建外部访问</span><br>k create svc loadbalancer emqx --tcp=18083:18083  --tcp=1883:1883<br></code></pre></td></tr></table></figure><p>如果在 docker 中的话这么操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name emqx -p 18083:18083 -p 1883:1883 emqx:4.4.4<br></code></pre></td></tr></table></figure><p>当然，你也可以加些环境变量作为 emqx 的配置，具体参考：<a href="https://www.emqx.io/docs/zh/v5.0/admin/cfg.html">emqx 配置文件</a><br>比较重要的可以设置一下消息保留: retainer</p><h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>发现了 <a href="https://github.com/emqx/MQTTX/blob/main/README-CN.md">MQTTX</a> 这个控制台。<br>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install --cask mqttx<br></code></pre></td></tr></table></figure><p>或者直接从 <a href="https://github.com/emqx/MQTTX/releases/tag/v1.8.3">github</a> 上下载安装包</p><p>可以先尝试从控制面板上进行 mqtt 的消息发送和接收，建立感性认识。</p><h2 id="client-选择"><a href="#client-选择" class="headerlink" title="client 选择"></a>client 选择</h2><p>使用 golang 的 eclipse 的 <a href="https://github.com/eclipse/paho.mqtt.golang">paho.mqtt.golang</a>，虽然这包名很不 golang……<br>其他客户端可以参考 <a href="https://www.emqx.com/zh/mqtt-client-sdk">mqtt-client-sdk</a> 。</p><p>稍微写点代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subit</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>urlStr := <span class="hljs-string">&quot;mqtt://xxx.xxx.xx.xx:1883&quot;</span><br>u, err := url.Parse(urlStr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>cfg := autopaho.ClientConfig&#123;<br>BrokerUrls: []*url.URL&#123;u&#125;,<br>Debug:      log.Default(),<br>PahoDebug:  log.Default(),<br>KeepAlive:  <span class="hljs-number">10</span>,<br>ClientConfig: paho.ClientConfig&#123;<br>PingHandler: paho.DefaultPingerWithCustomFailHandler(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err error)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ping fail &quot;</span>, err)<br>&#125;),<br>Router: paho.NewStandardRouter(),<br>&#125;,<br>&#125;<br><br>cfg.Router.RegisterHandler(<span class="hljs-string">&quot;longtesttopic&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *paho.Publish)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;on longtesttoic : %s\n&quot;</span>, p.Payload)<br>&#125;)<br><br>m, err := autopaho.NewConnection(context.Background(), cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;new connect fail &quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Second * time.Duration(rand.Intn(<span class="hljs-number">10</span>)))<br><br>res, err := m.Publish(context.Background(), &amp;paho.Publish&#123;<br>Topic:      <span class="hljs-string">&quot;longtesttopic&quot;</span>,<br>QoS:        <span class="hljs-number">1</span>,<br>Properties: &amp;paho.PublishProperties&#123;&#125;,<br>Payload:    []<span class="hljs-keyword">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;hello world %s&quot;</span>, time.Now().String())),<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;publish fail : %s\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;publish ok : %+v&quot;</span>, res)<br>&#125;<br>&#125;()<br><br>err = m.AwaitConnection(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>_, err = m.Subscribe(context.Background(), &amp;paho.Subscribe&#123;<br>Subscriptions: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]paho.SubscribeOptions&#123;<br><span class="hljs-string">&quot;longtesttopic&quot;</span>: &#123;QoS: <span class="hljs-number">1</span>&#125;,<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>time.Sleep(<span class="hljs-number">60</span> * time.Second * <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上是一个简单的测试。</p><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><p>整体来说，mqtt 的协议是很简单的，和 websocket 一样简单，但是有 <code>消息质量</code> 的概念，一些场景下更好用，ws 没有 topic 这些概念，适用范围更广。</p><p>和 ws 相比，mqtt broker 算是一个特色，有比较成型的项目可以用，基于 ws 的 mqtt  在一些小场景里可能还挺好用。</p><p>MQTT broker 相比于 RocketMQ 这类消息队列，其实还比较类似，都是支持大量 topic 的，这点和 kafka 的数据结构有些差别。</p><p>发现一个比较有意思的项目： <a href="https://github.com/dgiot/dgiot/blob/master/README-CN.md">DGIOT工业物联网平台</a><br>后面可以看下 golang broker 的实现 <a href="https://github.com/VolantMQ/volantmq">volantmq</a></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 参考 MQTT sdk 的设计，参考 socket.io 等的设计，设计一个 ws 下的通信框架。</li><li><input disabled="" type="checkbox"> 把 MQTT 用在物联网小项目中</li></ul><hr><blockquote><p>A leader or a man of action in a crisis almost always acts subconsciously and then thinks of the reasons for his action.<br>— <cite>Jawaharlal Nehru</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>通信协议</tag>
      
      <tag>实践</tag>
      
      <tag>异步通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s熟练度标准</title>
    <link href="/longblog/posts/22_10_24_12_46_level_of_k8s.html"/>
    <url>/longblog/posts/22_10_24_12_46_level_of_k8s.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这几年，运维体系的变化主要就是从原来的以 自动化工具 + 云计算(ansible/puppet + ecs + 各中间件) 为主 逐渐变成以 k8s + 各中间件 为主。 因此对 k8s 的认识和熟练度就变得越来越重要。<br>我们通常去评判一个人在某块技能上的水平，通常使用类似于 <code>初级</code>、<code>中级</code>、<code>高级</code>、<code>专家</code> 这类标准，可以认为是站在 <code>熟练度</code>  这个维度做的划分。但光说 <code>熟练度</code> 这个东西有点虚，需要有一些标准来度量，因此在这里做了简单的我的一点认识。</p><blockquote><p>需要注意的是，这里对 k8s 的熟练度，仅仅指 k8s 这个应用的熟练度，而非基于 k8s 的整个云原生体系的熟练度，也并非是基于 k8s 这个平台的微服务体系的熟练度。</p></blockquote><h2 id="k8s-熟练度标准"><a href="#k8s-熟练度标准" class="headerlink" title="k8s 熟练度标准"></a>k8s 熟练度标准</h2><p>以下是我定义的 k8s 初级熟练度的一些标志：</p><ol><li>熟练使用 kubectl 进行 k8s 基本操作<ul><li>查看资源、创建资源、修改资源、删除资源、查看字段含义、查看资源状态</li></ul></li><li>自行定义及修改内置的资源对象<ul><li>例如 deploy、replicasets、daemonsets、statefulsets、service、ingress、endpoint、configmap、secret、events、role、sc、pv、pvc 等</li></ul></li><li>事件触发机制及处理流程<ul><li>api-server、informer(controller-manager)、scheduler、kubelet、网络插件、coredns</li></ul></li><li>CRD 的定义和简单使用<ul><li>操作第三方 operator、使用 CRD 创建 operator</li></ul></li></ol><p>以下是我定义的 k8s 中级熟练度的一些标志：</p><ol><li>熟悉 k8s 的 CRD，能熟练自定义 CRD 并开发相关功能 (转化、业务逻辑)</li><li>能完整理清 k8s 网络流程 (网络实现原理及跟踪)</li><li>能对 k8s 的实现有整体模块级理解 (模块划分及各模块基本实现)</li><li>熟悉当前 k8s 各生态位及当前状态</li></ol><p>以下是我定义的 k8s 高级熟练度的一些标志：</p><ol><li>能对 k8s 部分运行逻辑有代码级认识</li><li>能对 k8s 各部分能力极限有定量性认识</li></ol><p>对 k8s 的熟练度我计划是达到 中级熟练度，目前大约在初级的 50% ，不过没有进行考察型检测，这部分要做好，做到 ”可衡量“。可以参考市面上的 k8s 标准。</p><p>以上仅仅是对 k8s 的熟练度，一般在做业务时，对 k8s 的熟练度要求不是特别高，基本在初级的 50% 就能做绝大多数业务运维(前提是k8s本身比较稳定，比如用的公有云)。</p><p>除了要对 k8s 本身具备一定熟练度，对业务运维而言，更多的还是需要了解 <code>业务本身</code> ，业务系统中例如  服务提供的能力、服务可观测性、服务可恢复性、服务可扩展性 等。</p><p>另外，不得不说，最快学习和掌握 k8s 的资料其实是<a href="https://kubernetes.io/zh-cn/docs/home/">官方文档</a></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 参考市面上对 k8s 认证的标准</li><li><input disabled="" type="checkbox"> 参考 k8s 官网的标准、k8s 指导手册的标准</li><li><input disabled="" type="checkbox"> 增加对运维能力的度量标准 ！</li><li><input disabled="" type="checkbox"> 把 k8s <a href="https://kubernetes.io/zh-cn/docs/home/">官方文档</a> 整体读一遍！！</li></ul><hr><blockquote><p>As an organizer I start from where the world is, as it is, not as I would like it to be.<br>— <cite>Saul Alinsky</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>云原生</tag>
      
      <tag>k8s</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubectl的一些总结</title>
    <link href="/longblog/posts/22_10_24_11_17_summary_of_kubectl.html"/>
    <url>/longblog/posts/22_10_24_11_17_summary_of_kubectl.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>kubectl 是 k8s 的命令行工具，可以认为，如果对 kubectl 使用熟练了，就对 k8s 达到初级熟练度推进到 25% 了，相关标准可以参考 <a href="/longblog/posts/22_10_24_12_46_level_of_k8s.html" name="k8s熟练度标准" >k8s熟练度标准</a> ，本文对 kubectl 命令做一次整体整理。</p><h2 id="api-server"><a href="#api-server" class="headerlink" title="api-server"></a>api-server</h2><p>在整理 kubectl 之前，我们先看 api-server，为什么？因为 kubectl 实际上是一个 api-server 的 client SDK，了解清楚了 api-server，kubectl 就清楚 90% 了。</p><p>api-server 是 k8s 对外接口的入口，负责一切对 <code>元数据</code> 的修改，是 k8s 几大核心组件中的一个。 [notes:这里可以增加 k8s 的核心逻辑图]</p><p>可以认为，我们所有的操作，实际都是在给 api-server 发送不同的指令。那么，api-server 的指令有哪些类型呢？</p><ul><li>工作负载类资源<ul><li>包括一切会影响到 pod 的资源，例如： Pod、副本控制器 (ReplicationController)、副本集 (ReplicaSet)、部署集 (deployment)、有状态应用集(StatefulSet)、任务(job 和 cronjob)、自动扩缩容(AutoScaler)</li></ul></li><li>网络连通类资源<ul><li>包括一些会影响到 pod 访问的资源，例如： service(clusterIP、NodePort、LoadBalancer、headless)、endpoints、ingress</li></ul></li><li>外部存储类资源<ul><li>secrets</li><li>configmap</li><li>卷挂载类，例如： 卷(volume)、持久化卷(persistentVolume)、持久化卷申明(persistentVolumeClaim)、存储类(StorageClass)、存储引擎(CSIDriver)</li></ul></li><li>身份与鉴权类资源<ul><li>ServiceAccount (账户)</li><li>CertificateSigningRequest (证书签名请求)</li><li>角色类，例如： Role、ClusterRole、RoleBinding、ClusterRoleBinding</li></ul></li><li>集群及管理类资源<ul><li>Node</li><li>Namespace</li><li>Event</li></ul></li><li>扩展类资源<ul><li>CRD</li><li>MutatingWebhookConfiguration</li><li>ValidatingWebhookConfiguration</li></ul></li></ul><h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h2><p>作为一个运行在终端的与远端 k8s server 通信的 cli，kubectl 主要目标是：</p><ol><li>与 k8s server 做互信认证<ul><li>kubeconfig 配置</li><li>kubectl conifg 管理 ( <code>k config</code> )</li></ul></li><li>合理封装 api-server 的命令，供用户操作<ul><li>创建资源<ul><li><code>k create</code></li><li><code>k expose</code></li><li><code>k diff</code></li><li><code>k run</code></li><li><code>k apply</code></li><li><code>k kustomize</code></li><li><code>k replace</code></li></ul></li><li>操作资源<ul><li><code>k get/edit/delete/set/patch svc/deploy/nodes/pv/xxx</code></li></ul></li><li>调度和选择<ul><li><code>k label</code></li><li><code>k taint</code></li><li><code>k cordon/uncordon</code></li><li><code>k drain</code></li></ul></li><li>部署集操作<ul><li><code>k rollout (history)</code></li><li><code>k scale</code></li><li><code>k autoscale</code></li></ul></li><li>调试使用<ul><li><code>k logs</code></li><li><code>k describe</code></li><li><code>k exec</code></li><li><code>k cp</code></li><li><code>k port-forward</code></li><li><code>k proxy</code></li><li><code>k top pod/node</code></li><li><code>k attach/auth/debug</code> </li></ul></li></ul></li><li>提供用户操作过程中的常用工具<ul><li>获取所有 api-resource ( <code>k api-resources</code> )</li><li>解释资源字段含义 ( <code>k explain</code> )</li><li>管理 kubectl 插件 ( <code>k plugin</code> )</li><li>命令行提示 ( <code>k completion</code> )</li></ul></li></ol><p>上面是 kubectl 其中一个维度的分类，也可以按照 <code>kubectl -h</code> 进行分类 (主要差别在于各种 <code>高级命令</code> 被单独分成组了)。</p><h2 id="一些好用的操作"><a href="#一些好用的操作" class="headerlink" title="一些好用的操作"></a>一些好用的操作</h2><ul><li><code>k logs -f --tail 10</code> 做应用调试的时候，方便到没朋友</li><li><code>k run xxname --image xxxx --command=true --privilege=true -- tail -f /dev/null</code> 在测试状态应用时把 k8s 当 docker 用</li><li><code>k create svc clusterip longtest --tcp=8080:8080 -o=yaml --dry-run &gt; longtest.svc.yaml</code> 用 –dry-run 的方式拿到基本的资源 yaml，可以简化从其他地方 copy 资源基本清单的流程</li><li><code>watch kubectl get pod -l app=xxx</code> 可以监听状态变化，在部署之后检查部署状态挺好用。 (原生的 <code>-w</code> 也有类似功能，但变化方式不是很习惯)</li><li><a href="https://github.com/ahmetb/kubectx">kubectx 命令</a>，用于快速切换 context 和 namespace (kubens)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kubectl 只是一些简单的 k8s 操作，提升对 kubectl 使用的熟练度有助于日常业务运维中的效率，只要能熟练使用 kubectl 了，也就意味着具备了基本的 k8s 资源管理能力。</p><p>进一步的 k8s 熟练度，需要通过 提升对各项资源字段含义的熟练度<br>来增加，这是一个从 <code>浪漫期</code> 到 <code>精确期</code> 的过程。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 做命令的练习及验收方案</li><li>做 helm 的进一步使用 / kustomize 的进一步使用 <ul><li><input checked="" disabled="" type="checkbox"> <a href="/longblog/posts/22_11_03_15_06_simple_usage_of_helm.html" name="helm的一些简单使用" >helm的一些简单使用</a> ✅ 2022-11-03</li></ul></li><li><input checked="" disabled="" type="checkbox"> 做 k9s 和 kubeboard/k8s dashboard 的搭建和使用的简单教程 ✅ 2023-02-16<ul><li>没啥需要写的，都很简洁明了</li></ul></li></ul><p>其他和 k8s 相关的一些信息，可以参考:</p><ul><li><a href="/longblog/posts/21_12_26_a_record_of_k3s_run_up.html" name="记一次k3s环境搭建记录" >记一次k3s环境搭建记录</a></li><li><a href="/longblog/posts/22_07_21_12_45_install_k3s_in_air_gap_air.html" name="网络受限环境k3s安装记录" >网络受限环境k3s安装记录</a></li><li><a href="/longblog/posts/22_10_18_21_40_super_operations_practice.html" name="超-企业级运维实践" >超-企业级运维实践</a></li></ul><hr><blockquote><p>Edison failed 10,000 times before he made the electric light. Do not be discouraged if you fail a few times.<br>— <cite>Napoleon Hill</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>云原生</tag>
      
      <tag>operations</tag>
      
      <tag>k8s</tag>
      
      <tag>运维</tag>
      
      <tag>kubectl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决终端录制问题</title>
    <link href="/longblog/posts/22_10_21_11_33_resolve_terminal_screen_record.html"/>
    <url>/longblog/posts/22_10_21_11_33_resolve_terminal_screen_record.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>经常有一些命令行的操作希望保留操作流程，但没什么思路，也没有过多去思考这件事。</p><p>最近，命令行的操作突然增多了，这件事的重要性就提升了，记录下解决的方法。</p><h2 id="基本思考"><a href="#基本思考" class="headerlink" title="基本思考"></a>基本思考</h2><p>之前看到过两种终端的记录方式，一种是 视频版的，一种是 文字版的，都有其应用场景，因此，我需要跑通这两种方式的流程。</p><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><ol><li><a href="https://asciinema.org/docs/installation">https://asciinema.org/docs/installation</a></li><li><a href="https://github.com/faressoft/terminalizer">https://github.com/faressoft/terminalizer</a> (能导出成 gif)</li><li><a href="https://www.jianshu.com/p/1ef50996f0e7">https://www.jianshu.com/p/1ef50996f0e7</a> (导出为 svg)</li><li><a href="https://www.jianshu.com/p/f57259399b01">https://www.jianshu.com/p/f57259399b01</a> (linux系统自带的script命令)</li><li><a href="https://carbon.now.sh/">https://carbon.now.sh/</a> (代码生成图片)</li><li><a href="https://www.jianshu.com/p/5ffb598923f0">https://www.jianshu.com/p/5ffb598923f0</a> (一些命令行，包含生成 svg 的那个)</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>安装 asciinema</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install asciinema<br><br><span class="hljs-comment"># 参考 https://asciinema.org/docs/installation</span><br></code></pre></td></tr></table></figure><p>重命名为 recordterm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /usr/bin/asciinema /usr/<span class="hljs-built_in">local</span>/bin/recordterm<br></code></pre></td></tr></table></figure><p>命令帮助</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@long ~]<span class="hljs-comment"># recordterm -h</span><br>usage: recordterm [-h] [--version] &#123;rec,play,upload,auth&#125; ...<br><br>Record and share your terminal sessions, the right way.<br><br>positional arguments:<br>  &#123;rec,play,upload,auth&#125;<br>    rec                 Record terminal session<br>    play                Replay terminal session<br>    upload              Upload locally saved terminal session to asciinema.org<br>    auth                Manage recordings on asciinema.org account<br><br>optional arguments:<br>  -h, --<span class="hljs-built_in">help</span>            show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span><br>  --version             show program<span class="hljs-string">&#x27;s version number and exit</span><br><span class="hljs-string"></span><br><span class="hljs-string">example usage:</span><br><span class="hljs-string">  Record terminal and upload it to asciinema.org:</span><br><span class="hljs-string">    asciinema rec</span><br><span class="hljs-string">  Record terminal to local file:</span><br><span class="hljs-string">    asciinema rec demo.json</span><br><span class="hljs-string">  Record terminal and upload it to asciinema.org, specifying title:</span><br><span class="hljs-string">    asciinema rec -t &quot;My git tutorial&quot;</span><br><span class="hljs-string">  Record terminal to local file, &quot;trimming&quot; longer pauses to max 2.5 sec:</span><br><span class="hljs-string">    asciinema rec -w 2.5 demo.json</span><br><span class="hljs-string">  Replay terminal recording from local file:</span><br><span class="hljs-string">    asciinema play demo.json</span><br><span class="hljs-string">  Replay terminal recording hosted on asciinema.org:</span><br><span class="hljs-string">    asciinema play https://asciinema.org/a/difqlgx86ym6emrmd8u62yqu8</span><br><span class="hljs-string"></span><br><span class="hljs-string">For help on a specific command run:</span><br><span class="hljs-string">  asciinema &lt;command&gt; -h</span><br></code></pre></td></tr></table></figure><h2 id="一些认识"><a href="#一些认识" class="headerlink" title="一些认识"></a>一些认识</h2><ul><li>这个工具是通过 劫持终端 的方式实现的</li></ul><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这个工具不错，对于用类似于视频的方式很不错，可以用起来了。<br>但也有几个要解决的问题：</p><ul><li>解决一键生成文档的需求</li><li>解决一键生成 gif 的需求</li><li>和 blog 结合的能力 (hexo、ob)</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际使用时，还是 terminalizer 这个好用些，对于录制的东西，常用的场景还是作为 gif 图放到文档里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g terminalizer<br><br>terminalizer record demo<br><br>terminalizer play demo<br><br>terminalizer render demo<br></code></pre></td></tr></table></figure><hr><blockquote><p>Happiness is found in doing, not merely possessing.<br>— <cite>Napoleon Hill</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
      <tag>terminal</tag>
      
      <tag>screen</tag>
      
      <tag>终端</tag>
      
      <tag>屏幕录制</tag>
      
      <tag>课程</tag>
      
      <tag>课程制作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次nfs实操记录</title>
    <link href="/longblog/posts/22_10_20_16_40_operation_record_of_nfs_server_and_client.html"/>
    <url>/longblog/posts/22_10_20_16_40_operation_record_of_nfs_server_and_client.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做压力测试时，遇到了一台压力机资源不够的情况，因此需要两台或多台机器。但是会出现修改配置、修改压测脚本等均需要多地修改，比较麻烦，因此决定采用 nfs 进行存储共享，做个记录。</p><p>在很多需要共享文件的场景下，nfs 都可以作为一个方案，因为简单轻量。另外，也可以采用 samba。</p><h2 id="实践记录"><a href="#实践记录" class="headerlink" title="实践记录"></a>实践记录</h2><h3 id="server-端"><a href="#server-端" class="headerlink" title="server 端"></a>server 端</h3><ul><li><p>安装 nfs 服务端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install nfs* -y<br></code></pre></td></tr></table></figure></li><li><p>配置 nfs 暴露地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/exports<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 根据自己的文件路径暴露需要，配置下面的</span><br>/root/api 172.17.0.0/16(rw,sync,no_root_squash)<br><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>重启 exportfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exportfs -r<br></code></pre></td></tr></table></figure></li><li><p>设置自动启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable rpcbind<br>systemctl enable nfs-server<br></code></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start rpcbind<br>systemctl start nfs<br></code></pre></td></tr></table></figure></li><li><p>检查一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">showmount -e<br><br><span class="hljs-comment"># Export list for prichaos002:</span><br><span class="hljs-comment"># /root/api 172.17.0.0/16</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="连接端"><a href="#连接端" class="headerlink" title="连接端"></a>连接端</h3><ul><li><p>安装 nfs 客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install rpcbind nfs-utils<br></code></pre></td></tr></table></figure></li><li><p>开启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start rpcbind<br></code></pre></td></tr></table></figure></li><li><p>挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -t nfs -o nolock,nfsvers=3,vers=3 -o proto=tcp 192.168.2.16:/mnt/share <br>/mnt/share<br></code></pre></td></tr></table></figure></li><li><p>开机自动挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/fstab<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 根据自己的情况设置</span><br> 172.17.0.2:/mnt/share /mnt/share nfs defaults 0 0<br></code></pre></td></tr></table></figure></li></ul><p>以上，完成了一个 nfs server 和 client 的搭建。</p><hr><blockquote><p>All the great performers I have worked with are fueled by a personal dream.<br>— <cite>John Eliot</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>operation</tag>
      
      <tag>nfs</tag>
      
      <tag>存储</tag>
      
      <tag>共享存储</tag>
      
      <tag>运维实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgresql实验环境搭建</title>
    <link href="/longblog/posts/22_10_20_12_10_experiment_env_of_postgresql.html"/>
    <url>/longblog/posts/22_10_20_12_10_experiment_env_of_postgresql.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>pg 是一个非常通用的关系型数据库，在后端开发过程中经常被用到。为了能够更好地掌握 pg，我们需要一套快速可使用的环境，用于开发、测试等。</p><h2 id="基本形态"><a href="#基本形态" class="headerlink" title="基本形态"></a>基本形态</h2><ul><li>docker</li><li>k8s</li></ul><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p>通过在 <a href="https://hub.docker.com/search?q=postgresql">dockerhub</a> 上搜索 postgresql，发现有大量的镜像提供者。看到 postgres 官方的镜像 和 bitnami 提供的镜像 使用量最大，考虑到 bitnami 生态更加完善，因此选择 <a href="https://hub.docker.com/r/bitnami/postgresql">bitnami/postgresql</a> 作为镜像。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="拉镜像"><a href="#拉镜像" class="headerlink" title="拉镜像"></a>拉镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull bitnami/postgresql:12.12.0<br></code></pre></td></tr></table></figure><h4 id="直接通过-docker-运行"><a href="#直接通过-docker-运行" class="headerlink" title="直接通过 docker 运行"></a>直接通过 docker 运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建网桥</span><br>docker network create pgnet --driver bridge<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    -e ALLOW_EMPTY_PASSWORD=yes \<br>    -e POSTGRESQL_REPLICATION_MODE=master \<br>    -e POSTGRESQL_USERNAME=dbadmin \<br>    -e POSTGRESQL_PASSWORD=password123 \<br>    -e POSTGRESQL_DATABASE=testpg \<br>    -e POSTGRESQL_REPLICATION_USER=repl_user \<br>    -e POSTGRESQL_REPLICATION_PASSWORD=repl_password123 \<br>    -e POSTGRESQL_TIMEZONE=Asia/Shanghai \<br>    -v /data/pgtest:/bitnami/postgresql \<br>    -v /data/pgtest/init:/docker-entrypoint-initdb.d \<br>    --name pgmaster \<br>    --network pgnet \<br>    -p 5432:5432 \<br>    bitnami/postgresql:12.12.0<br></code></pre></td></tr></table></figure><h4 id="配置-docker-compose-yaml-文件"><a href="#配置-docker-compose-yaml-文件" class="headerlink" title="配置 docker-compose.yaml 文件"></a>配置 docker-compose.yaml 文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.3&#x27;</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">pgnet:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">postgresql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/bitnami/postgresql:12.12.0</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;5432:5432&#x27;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/data/pgtest:/bitnami/postgresql&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/data/pgtest/init:/docker-entrypoint-initdb.d&#x27;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;ALLOW_EMPTY_PASSWORD=yes&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;POSTGRESQL_REPLICATION_MODE=master&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;POSTGRESQL_USERNAME=dbadmin&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;POSTGRESQL_PASSWORD=password123&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;POSTGRESQL_DATABASE=testpg&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;POSTGRESQL_REPLICATION_USER=repl_user&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;POSTGRESQL_REPLICATION_PASSWORD=repl_password123&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;POSTGRESQL_TIMEZONE=Asia/Shanghai&#x27;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">pgnet</span><br><br></code></pre></td></tr></table></figure><p>[notice: 这里可以添加 docker-compose 教程] 可以参考 <a href="https://www.runoob.com/docker/docker-compose.html">菜鸟教程docker-compose</a></p><ul><li><input disabled="" type="checkbox"> 做从库搭建的实验</li><li><input disabled="" type="checkbox"> 做索引错误恢复的实验</li><li><input disabled="" type="checkbox"> 考虑混沌测试的内容 (用于做恢复)</li></ul><h4 id="尝试添加基础-sql"><a href="#尝试添加基础-sql" class="headerlink" title="尝试添加基础 sql"></a>尝试添加基础 sql</h4><p>手动执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">psql -Uxxxx -d postgres -f xxx.sql<br></code></pre></td></tr></table></figure><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p>charts 同样选择 <a href="https://github.com/bitnami/charts/tree/main/bitnami/postgresql">bitnami</a> 的库。</p><h4 id="下载-helm"><a href="#下载-helm" class="headerlink" title="下载 helm"></a>下载 helm</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://get.helm.sh/helm-v3.10.1-linux-amd64.tar.gz &amp;&amp; \<br>tar -zxf helm-v3.10.1-linux-amd64.tar.gz &amp;&amp; \<br>mv linux-amd64/heml /usr/<span class="hljs-built_in">local</span>/bin/ &amp;&amp; \<br>rm -rf linux-amd64<br></code></pre></td></tr></table></figure><h4 id="添加-bitnami-的库"><a href="#添加-bitnami-的库" class="headerlink" title="添加 bitnami 的库"></a>添加 bitnami 的库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add bitnami https://charts.bitnami.com/bitnami<br></code></pre></td></tr></table></figure><h4 id="查看-charts"><a href="#查看-charts" class="headerlink" title="查看 charts"></a>查看 charts</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm fetch bitnami/postgresql --untar<br><span class="hljs-comment"># 看情况修改需要的参数</span><br></code></pre></td></tr></table></figure><h4 id="修改pg密码等基本信息"><a href="#修改pg密码等基本信息" class="headerlink" title="修改pg密码等基本信息"></a>修改pg密码等基本信息</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># vim values.yaml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">postgresql:</span><br>    <span class="hljs-attr">auth:</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;dbadmin&quot;</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;123456&quot;</span><br>      <span class="hljs-attr">database:</span> <span class="hljs-string">&quot;testpg&quot;</span><br></code></pre></td></tr></table></figure><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm install --namespace pgtest --create-namespace pg ./postgresql<br></code></pre></td></tr></table></figure><h3 id="修改-service"><a href="#修改-service" class="headerlink" title="修改 service"></a>修改 service</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit svc xxxx -n pgtest<br><br><span class="hljs-comment"># 修改 Cluster 为 LoadBalancer/NodePort </span><br></code></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">psql -h localhost -p 5432 -d testpg -Udbadmin -W<br></code></pre></td></tr></table></figure><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>二进制也可以安装，可以在网上查下资料，姑且不做操作了。下面安装 pg 是为了使用 client。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y postgresql14<br></code></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul><li>增加 pg 的维护教程</li><li>增加 pg 的原理教程</li><li>增加 数据库 的相关教程</li><li>增加 pg 监控的添加</li></ul><hr><blockquote><p>In wisdom gathered over time I have found that every experience is a form of exploration.<br>— <cite>Ansel Adams</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>operation</tag>
      
      <tag>database</tag>
      
      <tag>实验环境</tag>
      
      <tag>pg</tag>
      
      <tag>postgresql</tag>
      
      <tag>postgres</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维工作的知识要点</title>
    <link href="/longblog/posts/22_10_19_15_34_some_important_knowledge_of_operations.html"/>
    <url>/longblog/posts/22_10_19_15_34_some_important_knowledge_of_operations.html</url>
    
    <content type="html"><![CDATA[<p>应用运维主要的知识方面可以用以下模块大致概括，课程需要做的，就是如何让大家掌握这些知识。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>linux 基础操作命令 (ls、cp、mv、rm、cd、pwd、cat、echo、vi等)</li><li>文本处理工具 (vim、awk、grep、find、sed)</li><li>监控工具 (dstats、top、xxx)</li><li>磁盘管理 (raid、lvm、nfs、fdisk、fstab、df、du)</li><li>文件系统管理 (mkfffs、mount、umount、swap)</li><li>内存管理</li><li>文件管理 (link、find、tar、zip)</li><li>用户管理 (组、权限)</li><li>备份与恢复 (dump、restore、rsync)</li><li>进程管理 (systemd、cron、proc、dmesg)</li><li>进程通信 (socket、channel、signal、shared mem)</li><li>包管理器 (rpm、yum)</li><li>启动管理 (init、inittab、grub、rc)</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>网络模型</li><li>网络设备</li><li>路由表</li><li>网络协议栈</li><li>lvs</li><li>keepalived</li></ul><h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><ul><li>搭建、备份</li><li>权限管理</li><li>数据表设计</li><li>索引优化</li><li>数据存储结构原理</li></ul><h2 id="常用开源组件"><a href="#常用开源组件" class="headerlink" title="常用开源组件"></a>常用开源组件</h2><ul><li>消息队列</li><li>键值数据库</li><li>对象存储</li><li>文档存储</li><li>倒排索引</li><li>OLAP数据库</li><li>时间序列数据库</li><li>nginx / openresty</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>加密方法</li><li>防火墙</li><li>代理</li><li>统一认证授权方案</li><li>巡检与审计</li><li>数据库安全</li><li>web安全</li></ul><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><ul><li>ELK / EFK</li><li>promethues + grafana</li></ul><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><ul><li>shell</li><li>语言 (python、golang)</li><li>ansible / puppter</li></ul><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><ul><li>namespace</li><li>cgroup</li><li>overlay</li><li>网络配置</li><li>k8s</li></ul><h2 id="devops-体系"><a href="#devops-体系" class="headerlink" title="devops 体系"></a>devops 体系</h2><ul><li>CICD 流程</li><li>CD 工具链</li><li>灰度体系</li><li>测试体系</li><li>混沌测试</li><li>敏捷流程</li></ul><hr><blockquote><p>No man was ever wise by chance.<br>— <cite>Seneca the Younger</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>operations</tag>
      
      <tag>运维</tag>
      
      <tag>运维知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超-企业级应用开发实践</title>
    <link href="/longblog/posts/22_10_18_23_09_super_application_practice.html"/>
    <url>/longblog/posts/22_10_18_23_09_super_application_practice.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做后端也马上到 2 年了，做了 1 年业务开发，做了 1 年基础架构，连带做了 1 年应用运维，不过近半年多以来基本是处于吃老本的状态，很多事情属于 ”做也可以“ ”不做也可以“，没有可以带来突破性变化的方向。</p><p>我逐渐开始思考一个持续性的问题： 你为什么学技术？</p><p>这让我再一次回忆自己的初心。</p><h2 id="曾经的选择"><a href="#曾经的选择" class="headerlink" title="曾经的选择"></a>曾经的选择</h2><p>从 19 年 7月开始，我就会周期性地回到对这个问题的思考上来，那是我第一次决定学技术。那个时候对技术属于一无所知，无知到仅了解 html 的十几个标签，甚至一度以为只要学会用 html + css + jquery 就能做前端工作了(当然，6年以前可能真还可以)。 </p><p>现在看起来似乎觉得 ”学点基本的前端技术而已嘛，有必要那么纠结吗？“，然而深处在对技术世界一无所知的对未知的恐惧中时，可不会这么轻松。</p><p>想学技术的想法跟一段经历有关。以前做书店项目的时候，由于店面费用很高，就想把书店搬到线上去，不过当时常规的选择只有 <code>孔夫子</code> 和 <code>有路网</code> 比较合适，其他的例如 <code>有赞</code>、<code>淘宝</code> 等，对书店都不是很友好，尤其是当你想在 公众号、小程序 这类载体上呈现时，就非常难搞了。 后来，遇到另外一波也是做书店的哥们儿，他们有两个学软件的同学，一个搞前端，一个搞后端，3个月时间，就把一个包括 小程序 和 管理后台 的项目弄了出来，直接就解决了卡主我们很长时间的问题。</p><p>我当时就被技术的魅力吸引了，后面做仓库管理的时候，也尝试摸索怎么用 扫码枪 和 excel 解决入库和盘点的问题，虽然搞得都是最基础的表格设计和 excel 宏录制等等，但也算是稍微触碰了技术的窗户。</p><p>一颗种子从那之后就埋下了： 我希望自己能够做出很多很多实用的应用，去解决现实生活与生产中的种种问题，提高效率，不论是何种技术，只要是能解决问题，那么去学就行了。</p><h2 id="3年的历程"><a href="#3年的历程" class="headerlink" title="3年的历程"></a>3年的历程</h2><p>是的，我的目标是  用技术解决现实问题，这是我学技术的初心。</p><ul><li>2019 年7月，初次学习前端，主要是 html、css、javascript、jquery、vue</li><li>同年 10 月，入职一家互联网公司做前端开发，主要技术栈是 vue、iview、js，入职后接触了 git、nodejs</li><li>2020 年 5 月，受好友邀请离职做自媒体，工作之余用 nodejs 和 python 写一些小脚本提升效率</li><li>2020 年 9 月，自媒体不能养活自己，开始考虑回到职场继续工作，一番分析后选择了 golang 后端，开始学习后端知识</li><li>2020 年 10 月，入职一家互联网公司做后端开发，主要技术栈式 golang、gin、goframe、postgresql、kafka、redis、mongodb 等等</li><li>2021 年 6 月，重新分组到基础架构小组。这之前主要做 业务功能开发、接口测试框架、消息服务从nodejs重构为golang。</li><li>2022 年 5 月，分组之后主要做了 系统全链路压测及性能调优、维护自研web框架、建设服务可视化(metrics和tracing)、私有部署体系搭建、做运维 backup……</li><li>2022 年 10 月，也就是到现在，这几个月发生了很多事，比如公司裁员 25%，比如原来想做的有前景的项目被分出去…… 等等，自己经常被卷入业务 bug 排查中、被卷入无意义的压测中、被卷入奇奇怪怪的环境问题解决中…… 总而言之，这几个月过得比较被动……</li></ul><p>从经历上可以看到，目前为止，我存在一定的技术基础，在基础的互联网应用开发领域，有潜力打通 前端、后端、运维 的体系。这样就能做到类似于 <code>开发一套书籍销售和管理系统</code> 的目标了。</p><h2 id="之后的道路"><a href="#之后的道路" class="headerlink" title="之后的道路"></a>之后的道路</h2><p>不过，这条链路中还是有很多环节没有串联起来，我的下一步目标，就是串联整个链路，真正实现 <code>能开发出互联网软件来解决现实问题</code> 的目标，这算是迈出了第一步吧。</p><p>当然了，要真正做到 <code>用技术解决现实问题</code> ，还有很长的路要走，之后至少会遇到这些可预见的问题：</p><ul><li>项目管理</li><li>产品设计</li><li>市场运营</li><li>嵌入式开发</li><li>机械建模设计</li><li>工程化</li></ul><p>路始终要一步步地走，当下，还是先做好  <code>独立开发一款互联网应用</code> 。</p><p>这将是一款 <code>课程平台</code> 的打造，我希望我将来能在 <code>技术教育</code> 这个领域持续做一些输出，这些输出按照不同主题将会集结成一个个技术课程，平台的形式也会根据我对课程形式的需要做出改变。</p><p>更多的细节将会在后续文章中描述。</p><hr><blockquote><p>Most people are about as happy as they make up their minds to be<br>— <cite>Abraham Lincoln</cite>—</p></blockquote><hr>]]></content>
    
    
    
    <tags>
      
      <tag>技术教育</tag>
      
      <tag>实战</tag>
      
      <tag>企业级应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超-企业级运维实践</title>
    <link href="/longblog/posts/22_10_18_21_40_super_operations_practice.html"/>
    <url>/longblog/posts/22_10_18_21_40_super_operations_practice.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在公司里 backup 运维工作有大约一年了，虽然零零散散还是做了不少事情，但一直没有进行过系统性的企业级运维体系搭建的过程，为了能更好地掌握运维的技能，现计划搭建起一套企业级的运维体系。</p><p>本则文档仅是对后续要做的运维实践的罗列，实际的实践文档会单独发布，并会附到该则文档中。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="基础设施建设"><a href="#基础设施建设" class="headerlink" title="基础设施建设"></a>基础设施建设</h3><ul><li>k8s 搭建</li><li>mysql 搭建</li><li>postgresql 搭建</li><li>redis 搭建</li><li>redis-cluster 搭建</li><li>mongodb 搭建</li><li>mongodb 集群搭建</li><li>kafka 搭建</li><li>rocketMQ 搭建</li><li>nacos 搭建</li><li>yapi 搭建</li><li>单点登录系统搭建</li><li>vpn 搭建</li><li>代理服务器搭建</li><li>jmeter 集群搭建</li><li>k6 集群搭建</li><li>jaeger 搭建</li><li>sentry 搭建</li><li>harbor 搭建</li><li>minio 搭建</li><li>es 集群搭建</li></ul><h3 id="开发辅助设施建设"><a href="#开发辅助设施建设" class="headerlink" title="开发辅助设施建设"></a>开发辅助设施建设</h3><ul><li>代码仓库搭建</li><li>CI 体系搭建</li><li>CD 体系搭建</li><li>日志体系搭建</li><li>监控体系搭建</li><li>灰度发布体系</li></ul><h3 id="基础知识实践"><a href="#基础知识实践" class="headerlink" title="基础知识实践"></a>基础知识实践</h3><ul><li>计算机网络实践</li><li>k8s 的网络探究</li></ul><p>由于运维是为开发服务的，因此，我会开发一套应用，让这些运维工作都为这套应用服务。<br>服务的开发可以关注 <a href="/longblog/posts/22_10_18_23_09_super_application_practice.html" name="超-企业级应用开发实践" >超-企业级应用开发实践</a> 的栏目。</p><hr><blockquote><p>Experts on romance say for a happy marriage there has to be more than a passionate love. For a lasting union, they insist, there must be a genuine liking for each other. Which, in my book, is a good definition for friendship.<br>— <cite>Marilyn Monroe</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
      <tag>运维</tag>
      
      <tag>实战</tag>
      
      <tag>企业级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维的工作初识</title>
    <link href="/longblog/posts/22_10_18_21_19_the_first_sight_of_Operations.html"/>
    <url>/longblog/posts/22_10_18_21_19_the_first_sight_of_Operations.html</url>
    
    <content type="html"><![CDATA[<h3 id="运维的主要工作职能是什么？"><a href="#运维的主要工作职能是什么？" class="headerlink" title="运维的主要工作职能是什么？"></a>运维的主要工作职能是什么？</h3><p>主要的职能有： ① 支持业务开发的环节，帮助提升开发效率  ② 做机器资源的管理，满足业务需要  ③ 做服务和资源的监控，保证业务正常稳定运行<br>当然，这只是运维通用的职能，根据具体业务的不同，具体的职能也不相同。</p><h3 id="如果让你来划分一下运维的工作，你会怎么划分？"><a href="#如果让你来划分一下运维的工作，你会怎么划分？" class="headerlink" title="如果让你来划分一下运维的工作，你会怎么划分？"></a>如果让你来划分一下运维的工作，你会怎么划分？</h3><ul><li>资产管理<ul><li>设备管理</li><li>服务器资源管理</li><li>CMDB建设</li></ul></li><li>基础设施建设<ul><li>开发流工具链建设<ul><li>代码仓库</li><li>CICD</li><li>日志系统</li><li>各运行环境</li><li>镜像仓库</li><li>vpn</li><li>服务可视化</li><li>接口管理工具</li><li>测试平台</li><li>jira 等项目管理工具</li></ul></li><li>中间件建设<ul><li>数据库类</li><li>存储类</li><li>消息系统类</li></ul></li><li>上线基础设施建设<ul><li>监控、告警</li><li>灰度发布</li></ul></li><li>其他业务所需基础设施建设<ul><li>业务看板</li><li>学习平台</li><li>性能测试</li><li>AI 系统</li><li>……</li></ul></li></ul></li><li>安全体系建设<ul><li>漏洞扫描</li><li>安全对抗</li></ul></li><li>可视化建设<ul><li>监控看板可视化</li><li>服务可视化</li><li>业务指标可视化</li></ul></li><li>流程建设<ul><li>oncall 流程</li><li>ci 流程</li><li>上线流程</li></ul></li><li>团队建设<ul><li>面试</li><li>学习</li><li>会议</li></ul></li></ul><h3 id="做运维的前景怎么样？"><a href="#做运维的前景怎么样？" class="headerlink" title="做运维的前景怎么样？"></a>做运维的前景怎么样？</h3><p>运维要跟着转型，近几年是运维的持续变化期，新的技术在替代老的技术，且趋势非常明显。跟着转型后，就能持续保证生命力，守着老本不转型的，就会慢慢失去竞争力。<br>运维长期以来是一个稳定的岗位，涉及到很多琐碎的细节，而这些细节又对 可用性、稳定性、性能 等等有比较大的影响，功能可以不再开发，但运维还是需要持续进行的，所以一家公司就算在怎么撑不住了，运维也会是最后离职的那波人。<br>不过这个岗位的服务能力很强，一个成熟期的项目，一个运维服务50人的研发团队是完全没有问题的。 因此岗位数量比较固定，不会突然出现大量的岗位需求。</p><h3 id="做运维的难度怎么样？"><a href="#做运维的难度怎么样？" class="headerlink" title="做运维的难度怎么样？"></a>做运维的难度怎么样？</h3><p>运维属于： 入门较简单，深入比较难 的工种。</p><h3 id="运维的工资怎么样？"><a href="#运维的工资怎么样？" class="headerlink" title="运维的工资怎么样？"></a>运维的工资怎么样？</h3><p>根据工作职责的不同，工资也不一样，目前 运维开发 的工资比较高，和开发工程师的工资齐平甚至略高，所做的工作实际和开发差不多，只是开发的东西是运维平台之类的。<br>普通桌面运维(IT管理员) &lt; 传统业务运维 &lt; 云原生运维 &lt;<del>= 特殊运维(大数据、AI、IDC) &lt;</del>= 运维开发<br>不管怎么说，运维也属于 IT 领域的一个岗位，工资待遇和业务开发相差不大。</p><h3 id="做运维的感受是什么样的？"><a href="#做运维的感受是什么样的？" class="headerlink" title="做运维的感受是什么样的？"></a>做运维的感受是什么样的？</h3><ol><li>琐碎事比较多</li><li>各个领域的细节知识都很重要</li><li>写文档的习惯非常重要</li><li>执行力非常重要</li><li>建立流程制度非常重要</li><li>写各种自动化小工具非常重要</li></ol><h3 id="一个运维的一天："><a href="#一个运维的一天：" class="headerlink" title="一个运维的一天："></a>一个运维的一天：</h3><p>xxx</p><h4 id="一个初创公司的运维工作："><a href="#一个初创公司的运维工作：" class="headerlink" title="一个初创公司的运维工作："></a>一个初创公司的运维工作：</h4><p>负责几乎所有运维的工作，精力一半会放在各类系统的搭建和完善上，另一半放在协助研发同学处理各类环境问题和上线问题。</p><h4 id="一个成熟公司的运维工作："><a href="#一个成熟公司的运维工作：" class="headerlink" title="一个成熟公司的运维工作："></a>一个成熟公司的运维工作：</h4><p>不同人负责不同的模块，可能单独拆出某块业务的运维、某个领域的运维 (例如 CDN运维、网络运维、数据库运维、大数据运维、运维实施……)。</p><h3 id="运维这几年的主要变化："><a href="#运维这几年的主要变化：" class="headerlink" title="运维这几年的主要变化："></a>运维这几年的主要变化：</h3><ol><li>从机房转移到云 (可能共有云、可能私有云)</li><li>从传统部署方式向云原生方式转变</li><li>从运维工作向运维开发转变</li></ol><h3 id="运维要掌握的语言："><a href="#运维要掌握的语言：" class="headerlink" title="运维要掌握的语言："></a>运维要掌握的语言：</h3><ol><li>shell</li><li>python</li><li>golang</li></ol><h3 id="运维要掌握的技能："><a href="#运维要掌握的技能：" class="headerlink" title="运维要掌握的技能："></a>运维要掌握的技能：</h3><p>这个要看是否分具体的专职运维，一般来说，需要：</p><ol><li>计算机知识 (桌面运维、IDC运维等)</li><li>网络知识 (桌面运维、IDC运维、网络运维等)</li><li>操作系统 (所有运维)</li><li>领域知识 * n<ul><li>云原生</li><li>业务中间件</li><li>数据库</li><li>项目管理</li><li>发布体系</li><li>编程语言</li><li>安全知识</li></ul></li></ol><h3 id="运维是否要学算法："><a href="#运维是否要学算法：" class="headerlink" title="运维是否要学算法："></a>运维是否要学算法：</h3><p>如果你能有证明自己编程能力的方式就不用。<br>如果你编程能力较差，也不用学算法，实践写点小项目练手。<br>如果你有一定编程能力，但还想提升编程能力，就需要。<br>对运维来说，理性看待算法。<br>但不论怎么说，基础的数据结构和算法还是最好熟练。</p><h3 id="重要的运维软技能："><a href="#重要的运维软技能：" class="headerlink" title="重要的运维软技能："></a>重要的运维软技能：</h3><ol><li>自主解决问题</li><li>DRY (自动化)</li><li>写文档</li><li>有计划</li><li>主动沟通</li><li>责任心</li><li>安全第一</li><li>实验大于理论</li><li>持续学习</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我一直认为，任何一个工种都有其有意思的地方，也都有其不好的地方，喜欢或者不喜欢，很大程度上是受到历史思维习惯和行为习惯的影响，反过来，喜欢或者不喜欢，也会对将来的思维习惯和行为习惯有很大影响。 所以，选择任何一种岗位，只要不是那种很长一段时间内都让你手足无措的工作，不是那种你觉得你将来一定会后悔的工作，那么你都可以去尝试，去持续积累，你会发现  工作嘛，不过如此……</p><hr><blockquote><p>Grief can be the garden of compassion. If you keep your heart open through everything, your pain can become your greatest ally in your life’s search for love and wisdom.<br>— <cite>Rumi</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>运维</tag>
      
      <tag>运维开发</tag>
      
      <tag>运维工程师</tag>
      
      <tag>SRE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单好用的加解密工具</title>
    <link href="/longblog/posts/22_10_18_21_19_useful_tools_of_encryption.html"/>
    <url>/longblog/posts/22_10_18_21_19_useful_tools_of_encryption.html</url>
    
    <content type="html"><![CDATA[<p>有时候，我们希望传输一个文件给他人，但这个文件涉及到一些隐私，不希望泄漏出去。但由于平常传输的工具都是各类大众 IM 工具，例如 钉钉、飞书、企业微信 等，这些工具都会将消息长期存储，加大了隐私泄漏的风险。 因此，我们希望对文件进行加密，传输完成后由对端同学进行解密打开。</p><p>几乎在所有的电脑上，都存在 openssl 这个工具，因此，我们可以简单地使用 <code>openssl</code> 进行加解密。 对于文件夹，可以直接使用 <code>zip</code> ，也可以使用 <code>tar</code> 。</p><h3 id="对文件进行加密"><a href="#对文件进行加密" class="headerlink" title="对文件进行加密"></a>对文件进行加密</h3><p><code>openssl enc -e -aes256 -in xxx1 -out xxx2</code></p><h3 id="对文件进行解密"><a href="#对文件进行解密" class="headerlink" title="对文件进行解密"></a>对文件进行解密</h3><p><code>openssl enc -d -aes256 -in xxx2 -out xxx1</code></p><h3 id="对文件夹进行加密-zip"><a href="#对文件夹进行加密-zip" class="headerlink" title="对文件夹进行加密(zip)"></a>对文件夹进行加密(zip)</h3><p><code>zip -re xxx.zip xxx</code><br><code>zip -rP password xxx.zip xxx</code></p><blockquote><p>注意，zip 的参数后跟的先是  目标文件名，再试带压缩文件名</p></blockquote><h3 id="对文件夹进行解密-zip"><a href="#对文件夹进行解密-zip" class="headerlink" title="对文件夹进行解密 (zip)"></a>对文件夹进行解密 (zip)</h3><p><code>unzip -P password xxx.zip</code><br><code>unzip xxx.zip</code></p><h3 id="对文件夹进行加密-tar"><a href="#对文件夹进行加密-tar" class="headerlink" title="对文件夹进行加密 (tar)"></a>对文件夹进行加密 (tar)</h3><p><code>tar -zcf - tt |openssl enc -e -k password &gt; xx.tar.gz</code></p><h3 id="对文件夹进行解密-tar"><a href="#对文件夹进行解密-tar" class="headerlink" title="对文件夹进行解密 (tar)"></a>对文件夹进行解密 (tar)</h3><p><code>dd if=xx.tar.gz |openssl enc -d -k password|tar -zxf -</code></p><p>如果把这几条命令进行简单封装，就是一个简单易用的加解密工具了</p><p>密码的问题在于双方是一样的，因此有些场景可以用公私钥进行加解密。</p><h3 id="创建一个私钥"><a href="#创建一个私钥" class="headerlink" title="创建一个私钥"></a>创建一个私钥</h3><p><code>openssl genrsa -out rsa.key 2048</code></p><h3 id="从私钥提取公钥"><a href="#从私钥提取公钥" class="headerlink" title="从私钥提取公钥"></a>从私钥提取公钥</h3><p><code>openssl rsa -in rsa.key -pubout -out pub.key</code></p><h3 id="用公钥加密"><a href="#用公钥加密" class="headerlink" title="用公钥加密"></a>用公钥加密</h3><p><code>openssl rsautl -encrypt -inkey pub.key -pubin -in xxx1 -out xxx2</code></p><h3 id="用私钥解密"><a href="#用私钥解密" class="headerlink" title="用私钥解密"></a>用私钥解密</h3><p><code>openssl rsautl -decrypt -inkey rsa.key -in xxx2 -out xxx3</code></p><h3 id="其他好玩的"><a href="#其他好玩的" class="headerlink" title="其他好玩的"></a>其他好玩的</h3><p>可以看一下这个项目 <a href="https://github.com/fbngrm/Matroschka">https://github.com/fbngrm/Matroschka</a><br>这是一个把一张图片藏在另一张图片中的工具，当然，不仅藏图片，你可以用这种方式藏任何东西。</p><hr><blockquote><p>Never tell people how to do things. Tell them what to do and they will surprise you with their ingenuity.<br>— <cite>George S. Patton</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>openssl</tag>
      
      <tag>tar</tag>
      
      <tag>加解密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个视角下服务的3种模式</title>
    <link href="/longblog/posts/three_model_of_services_in_one_view.html"/>
    <url>/longblog/posts/three_model_of_services_in_one_view.html</url>
    
    <content type="html"><![CDATA[<p>当下的各业务系统，通常会有这样的几种特征：</p><ol><li>完全化的存储计算分离</li><li>部分分离，部分未分离</li><li>完全不分离</li></ol><p>对于大多数业务公司，都喜欢用第一种模式，这是一种典型的业务应用 “无状态” 模式，所有的状态管理完全交给数据库，典型的例子是： 关系数据存mysql、缓存放 redis、灵活的数据放 mongodb，服务前面加一个 nginx 做负载均衡。</p><p>这种模式的最大优点是  开发简单，绝大多数时候仅需要关心业务逻辑即可。 弊端在于 数据库压力较大，如果数据量增加迅速，或者有高频操作的场景，性能和体量就会受到限制。</p><p>当然，这个限制不一定很低，通过钞能力能让这个限制保持在一个很高的位置，高到大多数企业够不到(例如，在阿里云购买很牛逼性能的中间件，或者使用 polarx、mongodb-cluster、redis-cluster 等分布式中间件)。</p><p>第二种模式，适用于一些 “操作很重” 的应用中，最好能大量命中缓存，就会采用 部分分离(eg: 数据库操作)、部分未分离(eg: 游戏中的实时数据) 的模式。</p><p>当出现数据存储与内存中时，就需要考虑 “数据丢失” 和 “数据不一致” 的问题了，其中 数据不一致 的问题，在分布式系统中比较常见。源于现在大家已经习惯性地写无状态应用了，协议用的是 http 这类无状态协议，负载均衡用的是 轮询 反状态策略，因此，容易出现 “请求节点漂移” 的问题。这部分问题和第三种模式相同，详见第三种模式。</p><p>第三种模式，适用于操作频率高，数据关联性十分密切的场景，大多数中间件都属于这类。</p><p>这种模式的特点就是 “性能非常高”，他们能够自行管理数据、缓存等等，因此绝大多数操作都在内存中完成。</p><p>缺点主要有两方面，其一，需要保证非常强的可用性、可恢复性；其二，分布式场景下的处理比较复杂。</p><p>在第二种模式中，说到过 数据一致性 的问题，其中一种方案就是 负载均衡，让对的请求达到对的节点，即可得到对的数据。</p><p>解决这个问题，可以有两个方案： 1. Client 需要关心连接的问题 (例如 指定ip、指定路由、重连等等)  2. Client 不关心，由内部模块自行转发。</p><p>这两种方案十分常见，例如，nginx 的 xxx hash 的负载均衡策略，就是方案 1，redis client 连接 redis-cluster 时也是方案 1，而 mongodb client 连接 mongodb-cluster 时，则是由 mongos 做转发处理，可以认为是 方案 2。</p><p>从 redis 的方案 和 mongodb 的方案中，在负载均衡的方法中，很常用的一种就是 hash slot 方案，对不同节点进行 hash slot 的分配。</p><p>另一种方案是 节点注册，这种模式适用于需要精确控制负载的场景。</p><p>在分布式场景中，上面这种处理数据一致性的方案是主库模式，数据一致性的问题还存在于 主从同步、元数据变更 等场景中。主从同步，一般采用版本控制的方式和 check sum 的方式。元数据变更，一般采用共识算法保证，例如 poxos 或者 raft ，也有 gossip 这类弱一致性算法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个golang三方库的常规内容</title>
    <link href="/longblog/posts/2302161036.html"/>
    <url>/longblog/posts/2302161036.html</url>
    
    <content type="html"><![CDATA[<p>当我们多写一些项目之后，会发现一些通用的方法或工具，于是希望把这些工具提取出来，成为一个独立的库。 例如 redis、kafka 等中间件，或者 ID 生成器、goroutine 等工具。</p><p>一个好的三方库有一些通用的特点，例如：</p><ol><li>用户友好，最好开箱即用</li><li>扩展性强，可自定义</li><li>文档清晰、齐全</li><li>有使用例子</li><li>单测齐全</li><li>接口稳定</li><li>支持调试</li></ol><p>在 golang 中，有一些通用的方式来保证上述的特点。</p><ol><li>提供构造方法，完成初始化</li><li>Options 模式，提供自定义修改，提供默认参数</li><li>提供 readme 文档，用于 github 等平台查看</li><li>提供 doc.go、代码注释，用于 golang 接口文档查看</li><li>部分组件可插拔，基于 接口 + 实现 的方式，提供扩展性</li><li>提供充足的单测</li><li>核心组件基于接口开发，保证接口稳定性</li><li>提供 example 目录</li><li>项目内文件结构清晰，职责分明</li><li>提供 plugin 或者 hook 模式，增强扩展性</li></ol><p>常见的扩展点包括：</p><ol><li>Options 扩展，使用 Options 模式，提供常见的一些 Options 操作</li><li>Logger 使用接口 + 实例化的方式</li><li>提供 Metrics plugin</li><li>提供 Tracing plugin</li><li>提供 多个 Backend (存储类)</li></ol><p>以下，分析几个项目的实践方式：</p><table><thead><tr><th>项目</th><th>初始化</th><th>扩展性</th><th>可调试</th><th>测试齐全</th><th>文档充足</th><th>例子</th><th>扩展点</th><th>项目结构清晰</th><th>接口稳定</th></tr></thead><tbody><tr><td>gorm</td><td>Config</td><td>hook</td><td>log 级别</td><td>√</td><td>doc.go + 代码注释</td><td>无</td><td>options + hook</td><td>√</td><td>×</td></tr><tr><td>go-redis</td><td>Config/Options</td><td>hook</td><td>×</td><td>√</td><td>代码注释</td><td>example_test.go</td><td>options + hook</td><td>√</td><td>√ (universal.Client)</td></tr><tr><td>go-kratos</td><td>Config</td><td>middleware / 接口化</td><td>-</td><td>√</td><td>docs + 代码注释</td><td>无</td><td>Config + middleware + 接口化</td><td>√</td><td>√</td></tr><tr><td>groupcache</td><td>组合</td><td>hook / 接口化</td><td>×</td><td>√</td><td>代码注释</td><td>无</td><td>-</td><td>√</td><td>√</td></tr><tr><td>grpc-go</td><td>Options</td><td>middleware / 接口化</td><td>log、metrics、管理后台</td><td>√</td><td>docs + 代码注释 + proposal</td><td>examples</td><td>Options + middleware + 接口化 + 外接组件</td><td>√</td><td>√</td></tr><tr><td>go-zero</td><td>Config</td><td>middleware</td><td>-</td><td>√</td><td>代码注释</td><td>无</td><td>Config + middleware</td><td>√</td><td>×</td></tr><tr><td>sarama</td><td>Config</td><td>hook</td><td>log 级别 / metrics</td><td>√</td><td>代码注释</td><td>examples</td><td>Config + hook</td><td>×</td><td>√</td></tr></tbody></table><hr><blockquote><p>Do not wait for leaders; do it alone, person to person.<br>— <cite>Mother Teresa</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>readingcodes</tag>
      
      <tag>library</tag>
      
      <tag>三方库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何做好持续的自我教育</title>
    <link href="/longblog/posts/22_08_10_10_52_how_to_educate_ourselves_consistently.html"/>
    <url>/longblog/posts/22_08_10_10_52_how_to_educate_ourselves_consistently.html</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>人之所以会有差别，一方面我们无法忽视出身环境带来的差异，另一方面，我们也无法忽视后天学习带来的改变。 站在个人的角度，我们无法决定我们的出身，就像打牌时我们无法决定手中的牌一样，在人生这场游戏中，开局就是这样。</p><p>每个人都希望有一个好的游戏结局，难道只有好的开局才能迎来好的结局吗？</p><p>玩过一些竞技游戏的同学都知道一个词，叫做 “逆风局”，指的就是如何有效利用各种资源，在开局不顺时，采取苟着求发展，待积累足够，再对外输出。</p><h2 id="如何玩好人生这场游戏"><a href="#如何玩好人生这场游戏" class="headerlink" title="如何玩好人生这场游戏"></a>如何玩好人生这场游戏</h2><p>人生也一样，持续发展 才是硬道理。</p><p>人生发展和一些游戏里的发展有些不同，游戏的发展大多就是 经验、资金、物资、装备 之类的，往往比较清晰而固定，而人生的发展，却需要自己去判断 去提升什么、去积累什么、去组合什么。</p><p>终身学习的过程，实际上就是持续 <code>自我教育</code> 的过程，<code>教育</code> 也就需要 <code>教育的目的和方向</code>，作为一名教师，教书育人的前提，是他知道 <code>什么是对的</code>、<code>什么是好的</code>、<code>什么是被受教育者需要的</code>。 那么，自我教育，也就需要知道  <code>有哪些领域的知识？``哪些领域的知识是重要的？``哪些领域的知识是被我所需要的？</code></p><p>要能很好地回答上面的问题，就要求这个人具备比较宽广的 视野，要具备多领域的基本认知，要有思考力去思考这些领域知识对于人的价值，要善于持续接触新知识。</p><p>既然，这已经是人生这场游戏中的关键操作，那么，就值得我们花费更多的时间和精力在这个课题上，去扩展我们的视野，去提升我们自我教育的能力，去找到我们该学习什么、该积累什么，去玩好这场名为 “人生” 的游戏。</p><h2 id="如何行动"><a href="#如何行动" class="headerlink" title="如何行动"></a>如何行动</h2><p>落实到目标，我们需要做这些事:</p><ul><li>去扩展知识领域认知，找到那些我们认为重要的知识领域</li><li>积累知识领域内容来源，持续阅读、思考、实践</li><li>思考 我们的人生竞争优势是什么？我们如何打造人生竞争优势？</li></ul><p>落实到具体行动，我们可以做这些事：</p><ul><li><input disabled="" type="checkbox"> 先通过自主思考，整理出我们认为的知识领域需要哪些？或者说要解决哪些问题？</li><li><input disabled="" type="checkbox"> 查阅教育学相关理论，认为教育需要提升哪些领域知识？</li><li><input disabled="" type="checkbox"> 查阅网络资料，收集各类认知提升的相关领域知识。</li></ul><p>为了保证行动的落地效率，需要有项目管理机制：</p><ol><li>将该主题列入到 生活 OKR 中</li><li>具体行动要做好 deadline 管理</li><li>每个具体的行动，都需要产出留档资料</li></ol><p>可以参考：<br><a href="/longblog/posts/23_01_01_16_23_use_okr_in_daily_life.html" name="把okr应用在生活中" >把okr应用在生活中</a><br><a href="/longblog/posts/23_01_03_10_25_how_to_use_project_management_tools_in_daily_life.html" name="项目管理工具在生活中的应用" >项目管理工具在生活中的应用</a><br><a href="/notpublish/index.html" name="骨架计划总论" >骨架计划总论</a></p><hr><blockquote><p>In wartime, truth is so precious that she should always be attended by a bodyguard of lies.<br>— <cite>Winston Churchill</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>人生选择</tag>
      
      <tag>教育</tag>
      
      <tag>持续学习</tag>
      
      <tag>持续成长</tag>
      
      <tag>自我教育</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>习惯的养成方法论</title>
    <link href="/longblog/posts/23_01_31_13_25_the_way_to_build_habit.html"/>
    <url>/longblog/posts/23_01_31_13_25_the_way_to_build_habit.html</url>
    
    <content type="html"><![CDATA[<p>一个习惯在没有完全养成之前，有两大杀手：<code>遗忘</code> 、<code>间歇性无意义论</code> 。</p><p>从小就听着一句话: <code>习惯决定人生</code> 。既然习惯这么重要，那么我们是否应当花大量的时间和精力去优化我们的习惯？</p><p>习惯本身就是一项能力，而且这项能力是可以培养的后天能力。</p><p>习惯养成的几个关键点：</p><ol><li>启动模式</li><li>即时反馈</li><li>持续反馈</li></ol><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><ul><li>外部触发器</li><li>思维触发器</li><li>行为触发器 (动作练习)</li></ul><p>一些常见的方法：</p><ol><li>多人一起</li><li>周期回顾</li><li>有冲击力的报表</li></ol><p>习惯养成的误区：</p><ol><li>完美主义患者</li><li>苦行僧思想</li></ol><p>习惯养成要注意 心力管理，具体可以参考:</p><ul><li><a href="/longblog/posts/23_01_31_11_36_ways_to_keep_heart_strength.html" name="WIP-心力保持方法" >WIP-心力保持方法</a></li><li><a href="/longblog/posts/22_08_08_16_20_thoughts_of_heart_strength.html" name="聊聊心力" >聊聊心力</a></li></ul><p>其他参考：</p><ul><li><a href="/notpublish/index.html" name="习惯养成列表" >习惯养成列表</a></li><li><a href="/notpublish/index.html" name="习惯养成的另一个隐藏破坏者" >习惯养成的另一个隐藏破坏者</a></li></ul><hr><blockquote><p>Friendship is but another name for an alliance with the follies and the misfortunes of others. Our own share of miseries is sufficient: why enter then as volunteers into those of another?<br>— <cite>Thomas Jefferson</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>习惯</tag>
      
      <tag>习惯养成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于教育的一些想法</title>
    <link href="/longblog/posts/2301061422.html"/>
    <url>/longblog/posts/2301061422.html</url>
    
    <content type="html"><![CDATA[<p>这几天，经常在思考 <code>教育</code> 的话题，有一些想法记录一下</p><ul><li><p>教育理念上，鼓励式教育优于压力式教育</p></li><li><p>我们要对教育进行更深的探讨，从理论到实践经验总结，直到形成自成体系的教育观念和方法，然后持续实践</p></li><li><p>要想教育好他人，首先要能更好地教育自己</p></li><li><p>持续学习 就是 持续自我教育 的过程</p></li><li><p>想让受教育的人养成哪些好习惯，首先得自己也具备这些习惯，为人师表，以身作则</p></li><li><p>做教育，需要十分有心机，要站在第三方视角去观察大家的行为，去理解这些行为背后的动机。要思考自己的每一个行动都是为了达到什么目的，你要让受教育的人朝着自己期待的方向发展，你就得把他们拿捏的死死的。要去习惯这种感觉。</p></li><li><p>你是一个教练，你无时无刻不在做教练，你要无意识地去训练身边的人，让他们在无意识的过程中，理解一些好的理念，养成一些好的习惯。</p></li><li><p>教育是一个孤独的过程，你要有孤勇者的决心与毅力，不要在意你能得到什么，不要期待别人感谢你，甚至会有一些人无法理解你。你要学会跟自己相处，要修德正心，要构建自己的内在世界。</p></li><li><p>教育小孩的过程，有些人习惯用 <code>发火</code> 的方式，这是一种方式，但不能成为主要的方式，发火 可以用来做极端场景控制。不能让 <code>压力式</code> 成为 <code>情绪发泄</code> 的借口。</p></li></ul><hr><blockquote><p>Through meditation and by giving full attention to one thing at a time, we can learn to direct attention where we choose.<br>— <cite>Eknath Easwaran</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>教育</tag>
      
      <tag>教育理念</tag>
      
      <tag>持续学习</tag>
      
      <tag>持续成长</tag>
      
      <tag>终身学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美好生活记录管理</title>
    <link href="/longblog/posts/23_01_31_13_02_beautiful_life_record_management.html"/>
    <url>/longblog/posts/23_01_31_13_02_beautiful_life_record_management.html</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>从长远来看，我们 工作、学习、思考、做事、阅读、休息…… 等等，其终极目标，还是追求 美好生活 。</p><p>每个人，或者每个共同体，对美好生活的理解都是不同的，追求的程度也是不同的。对于我和我的伴侣而言，美好生活意味着 我们可以住在自己的家里，可以做自己感兴趣的事情，可以去尝试不同的领域，可以不用到某一个固定的地方上班，可以不那么忧虑经济问题导致的家人身体健康得不到保证。</p><p>有时候想想，生活其实也挺简单。</p><p>如果我们是自由职业，我们可以在任何地方，甚至可以回到乡下，过着清新舒适的生活，做着自己认为有价值的事情……</p><p>我们像这样梦着…… </p><h3 id="你能过好你的生活吗"><a href="#你能过好你的生活吗" class="headerlink" title="你能过好你的生活吗?"></a>你能过好你的生活吗?</h3><p>忽然，一个炸醒，我的神经跟着一颤……</p><p>脑海里出现这样一个问题: 如果真的有这样的机会，你能过好这样的生活吗？ </p><p>我们现在是双休，可以认为，周末的时候，我们甚至比 自由职业者 还自由，那么，你认为你的周末是你理想中的 <code>美好生活</code> 吗？ 如果不是，那么你为什么认为你回到家里就能过上你的美好生活？ </p><p>经过了一番思考，我有了这样的想法： 想要过上 美好生活，实际上需要一系列的好习惯做引擎，这些习惯，能让你拥有良性的循环，能让你保持好的心情和状态，能让你有好的精力保持高效地去做自己想做的事。</p><p>这时候想起了一句话: 世上没有绝对的自由，建立在约束之上的自由才是真正的自由。</p><h3 id="“美好生活”-意味着什么？"><a href="#“美好生活”-意味着什么？" class="headerlink" title="“美好生活” 意味着什么？"></a>“美好生活” 意味着什么？</h3><p>我们想过的美好生活，不是 <code>散漫</code>、<code>懒惰</code>、<code>无所事事</code>、<code>不工作</code>、<code>不学习</code>，而是 <code>健康地</code>、<code>积极地</code>、<code>高效地</code>、<code>心情愉悦的</code> 进行 <code>学习</code>、<code>思考</code>、<code>探索</code> 、<code>试验</code> 、<code>增进感情</code> 、<code>休闲</code> 、<code>解决各种问题</code> 等等</p><p>想达到这些目的，需要从两个方面入手：</p><ol><li>有健康的身心</li><li>有自己所追求的东西 (信仰?)</li></ol><p>我们可以认为，健康的身心 是 美好生活 的前提和基础保障。只有在保持健康的身心状态下，不断去追求自己所热爱的东西，才是真正的 美好生活。</p><p>健康身心，实际上是 多项习惯 的聚合，主要包括  <code>运动习惯</code>、<code>健康的饮食习惯</code>、<code>健康的作息习惯</code> 三个部分。可以认为 <code>美好生活 = (运动习惯 + 健康的饮食习惯 + 健康的作息习惯 + 自己感兴趣的事) * (时间 * 效率)</code> 。</p><p>因此，我们需要养成这几个好习惯。</p><p>之前在 <a href="/longblog/posts/23_01_31_13_25_the_way_to_build_habit.html" name="习惯的养成方法论" >习惯的养成方法论</a> 中有提到，<code>习惯养成</code> 本身就是一项能力，而且是可以培养的能力。</p><p>重点有 3 个：</p><ol><li>做好 <code>模式启动</code></li><li>做好 <code>即时反馈</code></li><li>做好 <code>持久反馈</code> </li></ol><p>那么，上面的这三个习惯，该如何做到上面的 3 点呢？</p><h3 id="运动习惯养成"><a href="#运动习惯养成" class="headerlink" title="运动习惯养成"></a>运动习惯养成</h3><p>#运动习惯 #健康 #习惯养成 </p><h4 id="模式启动"><a href="#模式启动" class="headerlink" title="模式启动"></a>模式启动</h4><ul><li>早上 7:30 闹钟提醒</li><li>和老婆一起，相互提醒</li><li>收拾书包，拿上需要的东西</li><li>确定的练习项目<ul><li>做一遍热身运动</li><li>跑步 30 分钟</li><li>拉伸 5 分钟</li><li>做几组力量训练</li></ul></li></ul><h4 id="即时反馈"><a href="#即时反馈" class="headerlink" title="即时反馈"></a>即时反馈</h4><ul><li>小米运动手环，隔一段时间看运动统计 (心率等)</li><li>和老婆分享今天做运动的收获</li><li>鼓励老婆，被老婆鼓励</li><li>心里告诉自己，我今天又做了运动，好的开始！</li></ul><h4 id="持续反馈"><a href="#持续反馈" class="headerlink" title="持续反馈"></a>持续反馈</h4><ul><li>记录运动情况，每天看下运动情况</li><li>每周的 OKR review 时，总结运动情况</li><li>生成好看的报告 (待探索)</li><li>定期称重、拍身体照片，定期回顾变化</li></ul><h3 id="健康饮食习惯"><a href="#健康饮食习惯" class="headerlink" title="健康饮食习惯"></a>健康饮食习惯</h3><p>#饮食习惯 #健康 #习惯养成 </p><h4 id="模式启动-1"><a href="#模式启动-1" class="headerlink" title="模式启动"></a>模式启动</h4><ul><li><p>运动前早上吃 1 个鸡蛋 (使用电饭煲的定时预约功能)</p></li><li><p>上班前，固定行程，去早餐店买两个鸡蛋 (动作练习)</p></li><li><p>到公司，固定行动，泡茶 (动作练习)</p></li><li><p>公司午餐，找健康餐，点进去。 （动作练习）</p></li><li><p>下午如果饿了，拿出一包鸡胸肉吃 (鸡胸肉放在特定位置)</p></li><li><p>晚餐尽量点健康食物。和老婆共吃一份。不够就吃鸡胸肉。</p></li><li><p>不拿零食，看到零食，想一下: 我又不饿，饿了也有鸡胸肉，减肥呢，走过去</p></li><li><p>他人给我零食，说: 谢谢，你留着吃吧，我不饿，减肥呢，这次我是认真的 ~</p></li><li><p>点餐时，告诉自己: 从食量来讲，实际上我吃两个鸡胸肉就能饱的，一个人 一个菜是极限了。</p></li><li><p>在餐厅吃饭时，告诉自己: 我保持 8 分饱是最好的，吃不完就算了，以后记得少点一些，这次你吃了的话，还得花很多时间锻炼才能减下去，划不来。</p></li><li><p>看到家里的零食，想吃的时候： 你一定是状态不好了，去闭目休息一会儿吧，或者收拾一下，出去散散步吧。</p></li><li><p>看到老婆在吃零食时，告诉自己: 她吃她的零食，我这么胖有什么资格吃零食？瘦到 135 斤，你就可以经常做大餐锻炼厨艺了，那个时候再说吧。</p></li><li><p>端起水杯，喝一口。</p></li><li><p>当点到 2 个菜时，说一句 : 嗯，够了。 (动作练习)</p></li><li><p>当吃到差不多时，如果桌上还有菜，把自己的筷子扔地上 (动作练习)</p></li><li><p>当吃东西的时候，每2秒嚼一口。 (动作练习)</p></li><li><p>吃饭之前，倒一杯水，一口喝下去。 (动作练习)</p></li></ul><h4 id="即时反馈-1"><a href="#即时反馈-1" class="headerlink" title="即时反馈"></a>即时反馈</h4><ul><li>每做了一个健康饮食的决策时，告诉自己: 你又战胜了初级欲望一次，很棒啊，继续加油💪🏻。</li><li>中午吃健康餐之前，拍照给老婆炫耀一番，我又继续吃了健康餐 (＾－＾)V</li><li>买鸡蛋之后，告诉自己: 嗯，鸡蛋确实好，蛋白含量高，还很饱腹，不错。</li></ul><h4 id="持续反馈-1"><a href="#持续反馈-1" class="headerlink" title="持续反馈"></a>持续反馈</h4><ul><li>统计每天吃的什么，健康维度评分如何，每天总结一次</li><li>每周的 OKR review 时，总结饮食情况</li><li>定期称重、拍身体照片，定期回顾变化</li></ul><h3 id="健康的作息习惯"><a href="#健康的作息习惯" class="headerlink" title="健康的作息习惯"></a>健康的作息习惯</h3><p>#习惯养成 #作息习惯 #健康</p><h4 id="模式启动-2"><a href="#模式启动-2" class="headerlink" title="模式启动"></a>模式启动</h4><ul><li><p>晚上的规划中，只做到 10:30，告诉自己，10:30 后要睡觉了</p></li><li><p>10:30 闹钟一响，需要在 5 min 内结束一切事情</p></li><li><p>紧接着 洗漱、洗澡，换睡衣，清爽入睡 (动作练习)</p></li><li><p>闭上眼，用冥想的方式助眠</p></li><li><p>早上 6点 闹钟响，猛睁开眼睛 (动作练习)</p></li><li><p>翻下床，去卫生间，洗一把脸、洗漱 (动作练习)</p></li><li><p>当在看手机时，直接锁屏，扔出去 (动作练习)</p></li></ul><h4 id="即时反馈-2"><a href="#即时反馈-2" class="headerlink" title="即时反馈"></a>即时反馈</h4><ul><li>每次做到上面的这些事项时，告诉自己: 我又一次战胜了懒惰，很棒啊，继续这样，你的美好生活在前方等着的。</li><li>和老婆一起分享我们又距离健康作息进了一步。</li></ul><h4 id="持续反馈-2"><a href="#持续反馈-2" class="headerlink" title="持续反馈"></a>持续反馈</h4><ul><li>统计作息情况。</li><li>每周的 OKR review 时，总结休息情况</li><li>写日志，发布到某些地方</li></ul><hr><blockquote><p>I don’t want to achieve immortality through my work… I want to achieve it through not dying.<br>— <cite>Woody Allen</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>习惯</tag>
      
      <tag>习惯养成</tag>
      
      <tag>生活</tag>
      
      <tag>健康</tag>
      
      <tag>健身</tag>
      
      <tag>健康饮食</tag>
      
      <tag>运动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIP-kafka的高吞吐原因</title>
    <link href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html"/>
    <url>/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html</url>
    
    <content type="html"><![CDATA[<p>kafka 是一个 高吞吐 的消息队列。 那么，kafka 是如何做到高吞吐的呢？</p><ol><li>页缓存</li><li>顺序写</li><li>零拷贝</li><li>批量发</li></ol><p>要弄清楚： 具体是怎么做的？</p><p>比如，页缓存，是如何存的？怎么使用？什么时候更新？会不会有丢失？如何监控命中率？</p><p>比如，批量发，批量是如何打包的、如何存储的？</p><ul><li>页缓存，当程序挂了，数据不会丢，当 OS 挂了，数据就丢了。</li><li>kafka 的大多数应用场景都是 读写 1:1 的。</li><li>kafka 用的是操作系统的 <a href="/notpublish/index.html" name="读写缓存，但有个弊端，就是 写缓存 的可靠性不好保证。大家日常的缓存使用方式，是 [[只读缓存]]" >读写缓存，但有个弊端，就是 写缓存 的可靠性不好保证。大家日常的缓存使用方式，是 [[只读缓存]]</a> 。</li><li>批量发送，除了在 发送的时候会进行打包，实际在存储的时候，也是直接存打包好的，消费的时候，同样是返回打包好的。 一切交给客户端处理，有时也是一种不错策略。</li></ul><h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><p>一些压测工具的调研：</p><ol><li><a href="https://github.com/jamiealquiza/sangrenel">https://github.com/jamiealquiza/sangrenel</a> (sarama)</li><li>kafka 自带 kafka-producer-perf-test.sh</li><li><a href="https://openmessaging.cloud/docs/benchmarks/">https://openmessaging.cloud/docs/benchmarks/</a></li><li><a href="https://github.com/kmgowda/SBK">https://github.com/kmgowda/SBK</a></li><li><a href="https://github.com/brianfrankcooper/YCSB">https://github.com/brianfrankcooper/YCSB</a> (not only kafka)</li><li><a href="https://github.com/six-ddc/plow">https://github.com/six-ddc/plow</a> (http)</li><li><a href="https://github.com/akopytov/sysbench">https://github.com/akopytov/sysbench</a> (mysql、pg、操作系统)</li><li><a href="https://github.com/bojand/ghz">https://github.com/bojand/ghz</a> (grpc)</li><li><a href="https://github.com/GoogleCloudPlatform/PerfKitBenchmarker">https://github.com/GoogleCloudPlatform/PerfKitBenchmarker</a> (云服务)</li></ol><p>看板一般用 grafana 做看板，也可以参考 <a href="https://github.com/metricsgraphics/metrics-graphics">这个项目</a> 。</p><h2 id="应用中的经验"><a href="#应用中的经验" class="headerlink" title="应用中的经验"></a>应用中的经验</h2><p>golang 下使用 sarama ：</p><p>发现 sarama 有 metrics 记录，因此调研了一系列将 sarama 的 metrics 存到 promethues 的方法，由于 sarama 使用的是 <a href="https://github.com/rcrowley/go-metrics">https://github.com/rcrowley/go-metrics</a> ，因此直接使用相关的包 <a href="https://github.com/deathowl/go-metrics-prometheus">https://github.com/deathowl/go-metrics-prometheus</a> ，但由于记录的 metrics 直接通过 metrics 名做区分，而不是 label，在制作看板时不太灵活，之后可以使用 <a href="https://github.com/iamlongalong/saramaprom">https://github.com/iamlongalong/saramaprom</a> 作为exporter。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// config 为 sarama 的 config 实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exportMetrics</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    ctx := context.Background()<br>    err := saramaprom.ExportMetrics(ctx, config.MetricRegistry, saramaprom.Options&#123;<br>        Namespace:     <span class="hljs-string">&quot;mastergo&quot;</span>,<br>        Subsystem:     <span class="hljs-string">&quot;sarama&quot;</span>,<br>        FlushInterval: time.Second * <span class="hljs-number">5</span>,<br>        Labels: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<br>            <span class="hljs-string">&quot;appname&quot;</span>: conf.DeepGet(<span class="hljs-string">&quot;app_name&quot;</span>).String(<span class="hljs-string">&quot;merger-index&quot;</span>),<br>        &#125;,<br>    &#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> 找到一个好用的 磁盘 benchmark 工具，能给出比较完整的 磁盘性能报告 <a href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html" name="关于磁盘和网络的性能的问题" >关于磁盘和网络的性能的问题</a> ✅ 2023-02-16</li><li><input checked="" disabled="" type="checkbox"> 找到一个好用的 内存 benchmark 工具，能给出比较完整的 内存性能报告 <a href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html" name="关于磁盘和网络的性能的问题" >关于磁盘和网络的性能的问题</a> ✅ 2023-02-16</li><li><input disabled="" type="checkbox"> 找到如何监控页缓存命中率等指标的方法</li></ul><h2 id="不错的学习资料"><a href="#不错的学习资料" class="headerlink" title="不错的学习资料"></a>不错的学习资料</h2><ul><li><a href="https://time.geekbang.org/column/article/126493">极客时间消息队列高手课</a></li></ul><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><ul><li><a href="/notpublish/index.html" name="消息系统的架构思考" >消息系统的架构思考</a></li><li><a href="/notpublish/index.html" name="kafka_in_go和redis_in_go源码走读" >kafka_in_go和redis_in_go源码走读</a></li></ul><hr><blockquote><p>Gratitude is not only the greatest of virtues, but the parent of all the others.<br>— <cite>Cicero</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
      <tag>sarama</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kratos源码走读记录</title>
    <link href="/longblog/posts/22_07_29_11_19_codes_reading_of_go_kratos.html"/>
    <url>/longblog/posts/22_07_29_11_19_codes_reading_of_go_kratos.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/go-kratos/kratos">go-kratos</a> 是 B 站开源的微服务框架，是 golang 体系下几大微服务框架之一，有阅读源码的必要。</p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>?? metadata server</p><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>命令行工具，三个部分：</p><ul><li>创建 proto、api 等的基础工具</li><li>基于 protoc 的 http server 代码生成 ( grpc 框架的 http 方案，可以对比一下其他方案 )</li><li>基于 protoc 的 errors 代码生成 ( 这个很有特色，详见 errors 包 )</li></ul><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>配置管理<br>几个特点：</p><ul><li>全部基于接口设计</li><li>option 模式，可以修改  source、decoder、resolver 的具体实现</li><li>支持多个 source 及合并</li><li>resolver 支持模板处理</li><li>watch 机制，支持向上的变更监听</li><li>observe 机制，支持向下的变更通知</li></ul><p>一个想法： 基于接口的开发，很流畅</p><ul><li><input disabled="" type="checkbox"> 对比一下和 viper 、go-zero、goframe、go-kit 的配置方案</li></ul><h3 id="contrib"><a href="#contrib" class="headerlink" title="contrib"></a>contrib</h3><p>三方项目的支持<br>config:  apollo、consul、etcd、configmap、nacos、polaris<br>原来使用 volume 挂载的方式使用 configmap，需要 deployment  去申明这些东西，比较麻烦，实际上，直接在 k8s 中用 sdk 读 configmap 确实挺方便。</p><p>encoding: <a href="https://msgpack.org/index.html">msgpack</a> #序列化</p><p>metrics: datadog、promethues  (看看 metrics 还有其他什么方案吗)</p><p>opensergo: 一个ali、字节、bilibili 一起搞的服务治理框架，<a href="https://developer.aliyun.com/article/889635?utm_content=m_1000337652">参考文档</a></p><p>registry:  consul、 discovery、etcd、eureka、k8s、nacos、polaris、zk</p><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>用于序列化和反序列化。<br>提供了 json、xml、yaml、proto、form 的方式。<br>json 和 proto 都用的 pb 的 marshal 和 unmarshal。<br>xml 用的标准库。<br>yaml 用的 <code>gopkg.in/yaml.v3</code><br>form 用的 <code>gggo-playground/form/v4</code> ，并且为 proto.Message 做了专门的适配。</p><h3 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h3><p>errors 的设计挺有意思，可以再参考下。<br>使用 proto 文件管理，自动生成代码。<br>有很多 error 体系都是自己的 封装，可以参考下 goframe 的 errors 、gopkg/errors 的设计。</p><h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h3><p>一些内部工具。</p><p>group 包下的 example_test.go 的使用比较有意思，可以参考 这种 test 的方式。</p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>log 的接口有两层，一层是 <code>log(level, kv...)</code> ，另一层是 <code>helper</code> ，日常使用 helper。<br>contrib 中实现了对 ali、fluent、zap、logrus 的对接。主要还是做输出的管理。</p><h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>简单的 metadata 封装，其实就是一个 <code>map[string]string</code></p><h3 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h3><p>简单的 metrics 接口定义。 具体实现在 contrib 包中。</p><h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>一些常用的 server 中间件。</p><h3 id="registry"><a href="#registry" class="headerlink" title="registry"></a>registry</h3><p>简单的注册中心接口定义，具体的实现在 contrib 中。<br>?? 不知道现在是 全量同步，还是增量同步。</p><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>一些 balancer 的方法，例如 随机、轮询。</p><h3 id="third-party"><a href="#third-party" class="headerlink" title="third_party"></a>third_party</h3><p>一些三方的 proto 定义。</p><h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p>http 框架封装 和 grpc 框架封装。 预期 ws 框架封装也可以进来。</p><p>http 路由使用的 mux 。</p><h2 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h2><p>kratos 的代码非常清晰简洁，没有太多复杂的设计。<br>代码风格一致性很好，外层定义接口，内层多个实现。常用 option 模式。</p><p>之后要再实际用 kratos 写几个小 demo 。<br>要看看 kratos 的返回值定义，以及 api 文档方面的解决方案。</p><ul><li><input disabled="" type="checkbox"> 使用 go-kratos 写几个小 demo</li></ul><hr><blockquote><p>Life’s most persistent and urgent question is, ‘What are you doing for others?’<br>— <cite>Martin Luther King Jr.</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>readingcodes</tag>
      
      <tag>微服务</tag>
      
      <tag>框架</tag>
      
      <tag>kratos</tag>
      
      <tag>go-kratos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个基于disk的队列型存储引擎</title>
    <link href="/longblog/posts/22_07_28_00_40_a_queue_storage_based_on_disk.html"/>
    <url>/longblog/posts/22_07_28_00_40_a_queue_storage_based_on_disk.html</url>
    
    <content type="html"><![CDATA[<p>我们有一种场景，将用户在画布上的操作保存下来。<br><code>操作</code> 的模型已经使用特定的序列化方法变成二进制。<br>操作有特定的顺序。<br>对每个操作，都需要去校验操作的合法性。<br>合法操作才会被确认，不合法的，会被忽略(一种策略，也可以是删除)。<br>获取时，需要按 ① 特定字段  ② offset ③ ID ④ 时间 获取，且有范围获取。<br>数据大小，大多为 100B ，但存在 50MB 的可能。</p><p>这和 writeahead log 类似。<br>其他客户端，类似于订阅 binlog。</p><p>从技术上看这个问题，有以下思路：</p><ol><li>这整体是一个队列</li><li>同时兼容 kv 的索引</li><li>需要持久化</li></ol><p>队列的问题域：</p><ol><li>队列大小<ol><li>轮转</li><li>压缩</li></ol></li></ol><p>存储的问题域：</p><ol><li>存储介质<ol><li>磁盘存储</li><li>数据库存储</li></ol></li><li>序列化问题</li><li>缓存问题<ol><li>内存缓存</li><li>本地缓存</li></ol></li></ol><p>索引的问题域：</p><ol><li>索引建立</li><li>索引更新</li><li>索引重构</li><li>全量索引与稀疏索引</li><li>索引的存储形态</li></ol><p>其他问题域：</p><ol><li>锁问题</li><li>迁移问题</li><li>schema 变更问题</li><li>事务支持</li></ol><p>业务的时序图应当为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>面向接口编程，识别 entity ，识别关系。</p><hr><blockquote><p>It is no use saying, ‘We are doing our best.’ You have got to succeed in doing what is necessary.<br>— <cite>Winston Churchill</cite></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>grpc在k8s中的负载均衡问题</title>
    <link href="/longblog/posts/22_07_25_11_25_the_problem_of_grpc_lb_in_k8s_using_service.html"/>
    <url>/longblog/posts/22_07_25_11_25_the_problem_of_grpc_lb_in_k8s_using_service.html</url>
    
    <content type="html"><![CDATA[<p>因为 grpc 是基于 http2 的通信，而 http2 对单个 endpoint 默认仅建立一条 TCP 连接，这就导致在 k8s 中，一个 service 默认仅会有一条 grpc 连接，并且，对于该 grpc 的请求，也都会集中到其中一个 pod 上。</p><p>尽管 k8s 的 service 本身有着 round robin 的负载均衡方式，但那都是建立在 “多次建立连接” 的基础上，对于已经建立连接后，基于 四层网络通信 的 TCP，是无法做到负载均衡的。</p><p>这个问题在我们当前的服务中也存在，两个服务间通过 service name 进行调用时，则会出现负载不均问题。</p><p>之前一直没有太重视这个问题，主要原因在于 每个服务都会有多个 pod ，那么多个 pod 调用 多个 pod 时，一定程度上进行了负载均衡。但是这种负载均衡很不稳定，比较容易出现连接集中到其中几个 pod 上的情况，因此，需要用其他方式解决。</p><p>经过阅读 grpc 代码，发现 grpc 本身有提供一定的机制解决负载均衡的问题，只是默认的方式在 k8s 中没有那么友好。</p><p>这其中涉及到 两个主要概念： resolver、balancer(picker)</p><p>resolver的作用，是解析一个服务地址对应多少 ip 地址，默认的方式是 passthrough，意味着透传服务地址，交由更底层的 transport 去处理。</p><p>还有一些其他的 resolver： ① DNS resolver ② Manual resolver ③ unix resolver</p><p>其中，DNS resolver 可以解析 DNS 中所挂载的 backend ips，这对于传统的基于 DNS 做负载均衡的方案比较好用，k8s 中的 statefulset 也可以大致基于这种模式。</p><p>Manual resolver 则是手动设置 backend ips，如果有自己的服务注册与服务发现机制，则用这种方式就比较方便。</p><p>Balancer 的作用，是从 resolver 解析的对应的 ip 地址池 选择特定的连接，其中核心的职能由 picker 承担，grpc 提供了大量的负载均衡策略，并且支持自定义策略，默认是 pick_first，还有一些例如：轮询、加权轮询、grpc远程lb、优先、rls(自适应？)。 甚至，grpc 提供了一些集群负载均衡的策略，例如一致性hash、CDS LB？等。</p><p>从上面分析来看，我们至少有这么三类解决方案：</p><ol><li> 通过使用 grpc 本身提供的 resolver 机制 和 balancer 机制，实现基于 k8s 的服务发现机制(通过client-go 进行封装)，则能比较优雅地解决这个问题。</li><li> 通过在 client 端实现 conn-pool 的方式，类似于通过多次 dial 的方式创建多个连接，然后自行实现一些 负载均衡的策略，例如 round-robin 或者随机，或者 sticky 的机制等。这个方案实现起来，从当前的技术复杂度上来看是最低的。但有三个问题： ① service 本身一定要更加“随机”，如果是 sticky 类机制，则此方式失效(k8s service默认是轮询机制)。 ② 每个遇到 grpc 负载均衡问题的 client ，都要改动其 client 包，以支持获取 conn 的方式(或者进行多一层封装，github.com/shimingyah/pool 就是采用这种方式)。③ 连接是在初始化过程建立的，初始化之后通过扩容形成的新pod很难被加入到连接池中。</li><li>通过 service mesh ，指定 service 类型为 grpc。</li></ol><p>从目前来看，我认为第一种方式更优雅，对业务的侵入也更小，仅需要修改 grpc 的 dial options，以及导入一个包即可。 这个包的设计，最好将 服务发现 独立出来，专门用于 k8s 中的服务发现与动态监听。</p><p>有些同学会认为，负载均衡这种事，应该交给网关，所以上 service mesh ，业务不要关心。关于这个问题，我的看法是 :  降低业务同学的心智负担，从总体上看是对的，但还是得根据公司实际情况是否值得。相关观点可以查看 <a href="/longblog/posts/22_07_19_21_44_some_discuss_about_microservice.html" name="服务化演进的一些问题探讨" >服务化演进的一些问题探讨</a> 。</p><p>后面通过看一些框架的代码，发现 go-zero 有方案 1 的实现，可以参考:  <a href="https://github.com/zeromicro/go-zero/tree/master/zrpc/resolver">zrpc/resolver</a></p><p>可以参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/258326212">Kubernetes中gRPC Load Balancing分析和解决</a></li><li><a href="https://segmentfault.com/a/1190000004492447">负载均衡算法及手段</a></li></ul><hr><blockquote><p>Whenever you find yourself on the side of the majority, it is time to pause and reflect.<br>— <cite>Mark Twain</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
      <tag>loadbalance</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grpc的设计分析</title>
    <link href="/longblog/posts/22_07_25_11_21_learning_the_design_of_grpc.html"/>
    <url>/longblog/posts/22_07_25_11_21_learning_the_design_of_grpc.html</url>
    
    <content type="html"><![CDATA[<ol><li> Grpc 的场景是什么？为什么有价值？</li><li> stream 的应用场景是什么？和 unary 有啥区别？</li><li> grpc 使用多通道的价值有多大？</li><li>为什么有些语言下会有 异步/同步 之分？<ol><li> 网络的异步本质</li></ol></li><li> grpc 在使用 http2 传输时，究竟传输了些什么？</li><li> 如何使用其他序列化方式？例如 json？</li><li> 和客户端的交互中使用 grpc 的方式 以及 价值？</li><li> 在 grpc 中，什么粒度被称为一个 service ？</li><li> grpc 设计上的可借鉴点？</li><li> Pb 的价值有多大？</li><li> 一个 rpc 框架，要考虑些什么问题？    1.  服务治理的多层次关系</li></ol><p>gRPC 值得分析的点：</p><ol><li>基于 proto 文件，生成基础代码</li><li>提供多语言插件，使生态增长</li><li>序列化方式，支持 pb 和 json</li><li>grpc-gateway 和 grpc-web</li></ol><p>grpc 的源码走读，可以参考 <a href="/longblog/posts/22_07_26_17_34_reading_grpc_codes.html" name="grpc的源码走读" >grpc的源码走读</a></p><p>关于 grpc 的负载均衡，可以参考 <a href="/notpublish/index.html" name="grpc的负载均衡" >grpc的负载均衡</a></p><p>可以参考的文档:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/411315625">知乎 gRPC 简介</a></li><li> <a href="https://zhuanlan.zhihu.com/p/389328756">gRPC 基础概念详解</a></li><li> <a href="https://toutiao.io/posts/9bek5r/preview">了解 gRPC 一篇就够了 - 开发者头条</a></li><li> <a href="https://zhuanlan.zhihu.com/p/344914169">gRPC系列(四) 框架如何赋能分布式系统</a></li><li> <a href="https://zhuanlan.zhihu.com/p/332863487">基于 gRPC 的服务注册与发现和负载均衡的原理与实战</a></li></ul><hr><blockquote><p>Opportunity does not knock, it presents itself when you beat down the door.<br>— <cite>Kyle Chandler</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
      <tag>rpc</tag>
      
      <tag>grpc</tag>
      
      <tag>http2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决k3s的存储问题</title>
    <link href="/longblog/posts/22_07_24_14_09_how_to_handle_storage_in_k3s.html"/>
    <url>/longblog/posts/22_07_24_14_09_how_to_handle_storage_in_k3s.html</url>
    
    <content type="html"><![CDATA[<ul><li><p><a href="/longblog/posts/22_11_11_20_48_k8s_nfs_storage_class.html" name="nfs、localpath作为k8s-storage-class" >nfs、localpath作为k8s-storage-class</a></p></li><li><p><input disabled="" type="checkbox">  rook</p></li><li><p><input disabled="" type="checkbox">  longhorn</p></li></ul><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><p><a href="/longblog/posts/21_12_26_a_record_of_k3s_run_up.html" name="记一次k3s环境搭建记录" >记一次k3s环境搭建记录</a><br><a href="/longblog/posts/22_07_21_12_45_install_k3s_in_air_gap_air.html" name="网络受限环境k3s安装记录" >网络受限环境k3s安装记录</a><br><a href="/longblog/posts/22_07_21_what_kind_of_k8s_installer_that_I_need.html" name="我需要什么样的集群搭建工具" >我需要什么样的集群搭建工具</a><br><a href="/notpublish/index.html" name="我为什么需要一套全面的软件环境" >我为什么需要一套全面的软件环境</a></p><hr><blockquote><p>The road of excess leads to the palace of wisdom.<br>— <cite>William Blake</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>enviroment</tag>
      
      <tag>k3s</tag>
      
      <tag>nfs</tag>
      
      <tag>storage</tag>
      
      <tag>longhorn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公司内网网络及管理工具</title>
    <link href="/longblog/posts/22_07_21_17_01_vpn_connector_and_manager_tool_for_company.html"/>
    <url>/longblog/posts/22_07_21_17_01_vpn_connector_and_manager_tool_for_company.html</url>
    
    <content type="html"><![CDATA[<h2 id="openvpn"><a href="#openvpn" class="headerlink" title="openvpn"></a>openvpn</h2><p>最简单的可以使用 openvpn , 也可以接 ldap </p><p>[TODO] 补一些 ov 的操作 (因为 ov 很常用，使用也很简单)</p><h2 id="ocserv"><a href="#ocserv" class="headerlink" title="ocserv"></a>ocserv</h2><p>也可以使用 ocserv , 客户端使用 anyconnect , 可以通过 yum 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install epel-release -y<br><br>yum install ocserv -y<br><br><span class="hljs-comment"># 验证版本</span><br>ocserv -v<br><br></code></pre></td></tr></table></figure><p>开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chkconfig ocserv on<br></code></pre></td></tr></table></figure><p>一些常规操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建用户</span><br>ocpasswd -c /etc/ocserv/ocpasswd user<br><br><span class="hljs-comment"># 删除用户</span><br>ocpasswd -c /etc/ocserv/ocpasswd -d user<br></code></pre></td></tr></table></figure><h2 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h2><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><p>可以参考 <a href="https://github.com/openldap/openldap">https://github.com/openldap/openldap</a></p><h3 id="RADIUS"><a href="#RADIUS" class="headerlink" title="RADIUS"></a>RADIUS</h3><p>可以参考 <a href="https://freeradius.org/">https://freeradius.org/</a></p><p>登录认证 与 访问控制，是几乎所有 saas 服务都需要具备的基础能力，这类需求如此突出，因此一定会有企业做这方面工作，提供给其他应用使用，于是扒了一圈，发现了这些项目：</p><ol><li> <a href="https://www.okta.com/">https://www.okta.com/</a></li><li> <a href="https://auth0.com/">https://auth0.com/</a></li><li> <a href="https://www.onelogin.com/">https://www.onelogin.com/</a></li><li> <a href="https://www.keycloak.org/">https://www.keycloak.org/</a></li><li> <a href="https://www.authing.cn/">https://www.authing.cn/</a></li><li> <a href="https://github.com/casdoor/casdoor">https://github.com/casdoor/casdoor</a></li><li> <a href="https://github.com/marmotedu/iam">https://github.com/marmotedu/iam</a></li><li> <a href="https://github.com/oauth2-proxy/oauth2-proxy">https://github.com/oauth2-proxy/oauth2-proxy</a></li><li> <a href="https://github.com/ory/hydra">https://github.com/ory/hydra</a></li><li> <a href="https://github.com/dexidp/dex">https://github.com/dexidp/dex</a></li><li> <a href="https://github.com/golang/oauth2">https://github.com/golang/oauth2</a></li></ol><p>对于身份管理，一般有这些需求：</p><ul><li>用户注册 (自定义 profile)</li><li>用户信息管理</li><li>用户认证<ul><li>账号密码</li><li>邮箱认证</li><li>手机号认证</li><li>外部认证 (社交账号、信息同步)</li></ul></li><li>session 管理</li><li>权限管理</li></ul><p>额外的需求还有：</p><ul><li>管理后台</li><li>接口文档</li><li>事件监听</li><li>sdk</li><li>demo</li><li>前端页面 (注册、登录)</li><li>安全体系 (登录限制等)</li></ul><p>根据使用的场景不同，使用的关注点也会有不同</p><p>目前来看，这几个值得关注：</p><ul><li>ory 体系下的 kratos 做的是 identity、hydra 做的是 provider connector (kratos也能做)、keto 做的是权限控制，整体体系比较齐全。 语言生态是 golang。</li><li>apache 开源的 keycloak 能力，轻量。 语言生态是 java。</li><li>casdoor 体系也比较齐全。语言生态是 golang。</li></ul><p>如果想有商业支持，可以看看 authing，价格的话，ToC平均 1元/用户/年 ，说实话挺贵的……</p><p>目前，上面3个开源方案我没有特别的偏好，可能要结合具体的场景。如果是我自己写的应用的话，我可能会倾向选择 casdoor，主要基于 语言生态 和 轻量 和 文档 三个方面考虑。</p><h2 id="casdoor-搭建试用"><a href="#casdoor-搭建试用" class="headerlink" title="casdoor 搭建试用"></a>casdoor 搭建试用</h2><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 要写的 <a href="/longblog/posts/22_10_18_23_09_super_application_practice.html" name="超-企业级应用开发实践" >超-企业级应用开发实践</a> ，使用 casdoor 作为账户中心。</li><li><input disabled="" type="checkbox"> 企业内的 gitlab 等使用 casdoor 作为登录管理器。</li><li><input disabled="" type="checkbox"> 找一个不错的登录界面，<a href="https://github.com/LoginRadius/awesome-login-pages">参考项目</a></li></ul><hr><blockquote><p>Give me a lever long enough and a fulcrum on which to place it, and I shall move the world.<br>— <cite>Archimedes</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>openvpn</tag>
      
      <tag>auth</tag>
      
      <tag>ldap</tag>
      
      <tag>oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络受限环境k3s安装记录</title>
    <link href="/longblog/posts/22_07_21_12_45_install_k3s_in_air_gap_air.html"/>
    <url>/longblog/posts/22_07_21_12_45_install_k3s_in_air_gap_air.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 <a href="/longblog/posts/22_07_21_what_kind_of_k8s_installer_that_I_need.html" name="我需要什么样的集群搭建工具" >我需要什么样的集群搭建工具</a> 中解释过，我有时候需要在 网络受限 的环境搭建 k8s 环境。由于 k3s 官方对 air gap 环境的支持比较好，因此记录一下如何做的安装。</p><h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><h3 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h3><p>资源地址: <a href="https://github.com/k3s-io/k3s/releases">https://github.com/k3s-io/k3s/releases</a></p><ul><li><p>建立资源文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir k3s &amp;&amp; <span class="hljs-built_in">cd</span> k3s<br></code></pre></td></tr></table></figure></li><li><p>下载 k3s 二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/k3s-io/k3s/releases/download/v1.21.12-rc3%2Bk3s1/k3s<br></code></pre></td></tr></table></figure></li><li><p>下载依赖镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/k3s-io/k3s/releases/download/v1.21.12-rc3%2Bk3s1/k3s-airgap-images-amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>下载部署脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O install.sh https://get.k3s.io/<br></code></pre></td></tr></table></figure></li><li><p> 设置执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod +x k3s install.sh<br></code></pre></td></tr></table></figure></li><li><p>将整个文件夹打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ..<br>tar -czf k3s.tar.gz k3s<br></code></pre></td></tr></table></figure></li></ul><h3 id="集群节点操作"><a href="#集群节点操作" class="headerlink" title="集群节点操作"></a>集群节点操作</h3><ul><li><p>将资源上传到机器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp k3s.tar.gz xxxx:~/<br></code></pre></td></tr></table></figure></li><li><p>登录机器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh xxxx<br></code></pre></td></tr></table></figure></li><li><p>解压资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf k3s.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>进入资源文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> k3s<br></code></pre></td></tr></table></figure></li><li><p>创建 k3s 默认镜像目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p /var/lib/rancher/k3s/agent/images/<br></code></pre></td></tr></table></figure></li><li><p>将 k3s 放入 bin 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp k3s /usr/<span class="hljs-built_in">local</span>/bin/<br></code></pre></td></tr></table></figure></li><li><p>解压默认镜像包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zmxf k3s-airgap-images-amd64.tar.gz  -C /var/lib/rancher/k3s/agent/images/<br></code></pre></td></tr></table></figure></li><li><p>安装 master 节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">INSTALL_K3S_SKIP_DOWNLOAD=<span class="hljs-literal">true</span> INSTALL_K3S_EXEC=<span class="hljs-string">&quot;server --disable traefik --token testdemo&quot;</span> ./install.sh<br></code></pre></td></tr></table></figure></li></ul><h3 id="安装常用工具"><a href="#安装常用工具" class="headerlink" title="安装常用工具"></a>安装常用工具</h3><h4 id="安装-helm"><a href="#安装-helm" class="headerlink" title="安装 helm"></a>安装 helm</h4><ul><li><p>下载 helm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://get.helm.sh/helm-v3.7.1-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xzvf helm-v3.7.1-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>移动到 bin 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv linux-amd64/helm /usr/<span class="hljs-built_in">local</span>/bin/helm<br></code></pre></td></tr></table></figure></li><li><p>清理残余</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -rf helm-v3.7.1-linux-amd64.tar.gz linux-amd64<br></code></pre></td></tr></table></figure></li><li><p>合一块儿操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://get.helm.sh/helm-v3.7.1-linux-amd64.tar.gz &amp;&amp; \<br>tar -xzvf helm-v3.7.1-linux-amd64.tar.gz &amp;&amp; \<br>mv linux-amd64/helm /usr/<span class="hljs-built_in">local</span>/bin/helm &amp;&amp; \<br>rm -rf helm-v3.7.1-linux-amd64.tar.gz linux-amd64 &amp;&amp; \<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;&lt;&lt;&lt; 🎉🎉🎉 FINISH INSTALL HELM 🎉🎉🎉 &gt;&gt;&gt;&gt;&#x27;</span> &amp;&amp; \<br>helm  version<br></code></pre></td></tr></table></figure></li></ul><h4 id="安装-dashboard"><a href="#安装-dashboard" class="headerlink" title="安装 dashboard"></a>安装 dashboard</h4><ul><li><p>获取基础 dashboard 清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O dashboard.yaml https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.0/aio/deploy/recommended.yaml<br></code></pre></td></tr></table></figure></li><li><p>修改镜像拉取策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">imagePullPolicy: IfNotPresent<br></code></pre></td></tr></table></figure></li><li><p>修改 token 过期时间 (option)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 deploy 启动参数中加入</span><br>--token-ttl=86400<br></code></pre></td></tr></table></figure></li><li><p>手动获取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull kubernetesui/dashboard:v2.6.0<br><br>docker save -o dashboard.tar kubernetesui/dashboard:v2.6.0<br><br>docker pull kubernetesui/metrics-scraper:v1.0.8<br><br>docker save -o metrics-scraper.tar kubernetesui/metrics-scraper:v1.0.8<br></code></pre></td></tr></table></figure></li><li><p>压缩镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zcf dashboard.tar.gz dashboard.tar <br>tar -zcf metrics-scraper.tar.gz metrics-scraper.tar<br></code></pre></td></tr></table></figure></li><li><p>传递到服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp dashboard.tar.gz xxxx:~/k3s<br>scp metrics-scraper.tar.gz xxxx:~/k3s<br></code></pre></td></tr></table></figure></li><li><p>将镜像放入 k3s 默认路径中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf dashboard.tar.gz -C /var/lib/rancher/k3s/agent/images/<br>tar -zxf metrics-scraper.tar.gz -C /var/lib/rancher/k3s/agent/images/<br></code></pre></td></tr></table></figure></li><li><p>手动导入到 ctr 中 ( 不想重启 k3s )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ctr i import /var/lib/rancher/k3s/agent/images/dashboard.tar <br>ctr i import /var/lib/rancher/k3s/agent/images/metrics-scraper.tar<br></code></pre></td></tr></table></figure></li><li><p>设置访问账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat &lt;&lt;<span class="hljs-string">eof &gt; dashboard.role.yaml</span><br><span class="hljs-string">apiVersion: v1</span><br><span class="hljs-string">kind: ServiceAccount</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">    name: admin-user</span><br><span class="hljs-string">    namespace: kubernetes-dashboard</span><br><span class="hljs-string">---</span><br><span class="hljs-string"></span><br><span class="hljs-string">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="hljs-string">kind: ClusterRoleBinding</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">    name: admin-user</span><br><span class="hljs-string">roleRef:</span><br><span class="hljs-string">    apiGroup: rbac.authorization.k8s.io</span><br><span class="hljs-string">    kind: ClusterRole</span><br><span class="hljs-string">    name: cluster-admin</span><br><span class="hljs-string">subjects:</span><br><span class="hljs-string">    - kind: ServiceAccount</span><br><span class="hljs-string">      name: admin-user</span><br><span class="hljs-string">      namespace: kubernetes-dashboard</span><br><span class="hljs-string"></span><br><span class="hljs-string">eof</span><br></code></pre></td></tr></table></figure></li><li><p>部署 dashboard</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f dashboard.yaml -f dashboard.role.yaml<br></code></pre></td></tr></table></figure></li><li><p>设置 dashboard 端口访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard<br><br><span class="hljs-comment"># 将 port 改为 8082 (或自定义)</span><br><span class="hljs-comment"># 将 type 改为 LoadBalancer</span><br></code></pre></td></tr></table></figure></li><li><p>访问地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://xxxx:8082/<br></code></pre></td></tr></table></figure></li><li><p>跳过证书验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在浏览器页面按下</span><br>thisisunsafe<br></code></pre></td></tr></table></figure></li><li><p>获取 token</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl -n kubernetes-dashboard describe secret admin-user-token | grep <span class="hljs-string">&#x27;^token&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>修改 metrics scriber 的保存时长</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit deploy -n kubernetes-dashboard dashboard-metrics-scraper<br><br><span class="hljs-comment"># 添加 args</span><br>args:<br>  - --metric-duration<br>  - 360h<br></code></pre></td></tr></table></figure></li><li><p>持久化 metrics， 创建 pvc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat &lt;&lt;<span class="hljs-string">eof &gt; metrics.pvc.yaml</span><br><span class="hljs-string">apiVersion: v1</span><br><span class="hljs-string">kind: PersistentVolumeClaim</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">    name: metrics-pvc</span><br><span class="hljs-string">    namespace: kubernetes-dashboard</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">    accessModes:</span><br><span class="hljs-string">      - ReadWriteOnce</span><br><span class="hljs-string">    # storageClassName: local-path</span><br><span class="hljs-string">    resources:</span><br><span class="hljs-string">      requests: </span><br><span class="hljs-string">        storage: 2Gi</span><br><span class="hljs-string">eof</span><br></code></pre></td></tr></table></figure></li><li><p>创建 pvc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f metrics.pvc.yaml<br></code></pre></td></tr></table></figure></li><li><p>修改 metrics deploy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit deploy -n kubernetes-dashboard dashboard-metrics-scraper<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 修改 volume 申明</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-volume</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>  <span class="hljs-attr">claimName:</span> <span class="hljs-string">metrics-pvc</span><br><br><span class="hljs-comment"># 修改 挂载申明</span><br><span class="hljs-attr">volumeMounts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-volume</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br></code></pre></td></tr></table></figure><h4 id="安装-nginx-ingress"><a href="#安装-nginx-ingress" class="headerlink" title="安装 nginx-ingress"></a>安装 nginx-ingress</h4><p>ingress 作为集群的统一入口，几乎是必不可少的。nginx 是最被大家熟悉的了，因此平常就使用 nginx 作为 ingress。</p><ul><li><p>获取 nginx-ingress-controller 清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O ingress-nginx.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/release-v1.3/deploy/static/provider/kind/1.22/deploy.yaml<br></code></pre></td></tr></table></figure></li><li><p>获取 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull registry.k8s.io/ingress-nginx/controller:v1.3.0<br>docker pull docker.io/jettech/kube-webhook-certgen:v1.2.1<br><br>docker save -o kube-webhook-certgen.tar docker.io/jettech/kube-webhook-certgen:v1.2.1<br><br>docker save -o ingress-nginx.tar registry.k8s.io/ingress-nginx/controller:v1.3.0<br><br>tar -zcf ingress-nginx.tar.gz ingress-nginx.tar<br>tar -zcf kube-webhook-certgen.tar.gz kube-webhook-certgen.tar<br></code></pre></td></tr></table></figure></li><li><p>上传镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp ingress-nginx.tar.gz xxxx:~/k3s<br>scp kube-webhook-certgen.tar.gz xxxx:~/k3s<br></code></pre></td></tr></table></figure></li><li><p>导入镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf ingress-nginx.tar.gz -C /var/lib/rancher/k3s/agent/images/<br>tar -zxf kube-webhook-certgen.tar.gz -C /var/lib/rancher/k3s/agent/images/<br><br>ctr i import /var/lib/rancher/k3s/agent/images/ingress-nginx.tar<br>ctr i import /var/lib/rancher/k3s/agent/images/kube-webhook-certgen.tar<br></code></pre></td></tr></table></figure></li><li><p>修改yaml镜像</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># nginx deployment</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">registry.k8s.io/ingress-nginx/controller:v1.3.0</span><br><br><span class="hljs-comment"># job</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/jettech/kube-webhook-certgen:v1.2.1</span><br></code></pre></td></tr></table></figure></li><li><p>去掉 node-selector </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#删除 ingress-ready: &quot;true&quot;</span><br>kubectl edit deploy ingress-nginx-controller -n ingress-nginx<br></code></pre></td></tr></table></figure></li><li><p>部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f ingress-nginx.yaml<br></code></pre></td></tr></table></figure></li><li><p>修改 svc 类型为 LoadBalancer (似乎不用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit svc ingress-nginx-controller -n ingress-nginx<br></code></pre></td></tr></table></figure></li><li><p>测试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl xxxx<br></code></pre></td></tr></table></figure></li></ul><h4 id="对-dashboard-增加-ingress"><a href="#对-dashboard-增加-ingress" class="headerlink" title="对 dashboard 增加 ingress"></a>对 dashboard 增加 ingress</h4><p>证书的来源，可以是自签，也可以是申请真正的证书，具体可以参考 <a href="/notpublish/index.html" name="如何解决证书问题" >如何解决证书问题</a></p><ul><li>创建 secret <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">k create secret tls mg-tls --key _wildcard.mg.com-key.pem --cert _wildcard.mg.com.pem<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>修改 dashboard 为 http 访问<br>仅需要把 <code>--auto-generate-certificates</code> 给注释掉，然后开放 <code>9090</code> 端口即可，另外，把 readness 探活端口也改成 9090</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit deploy kubernetes-dashboard -n kubernetes-dashboard<br></code></pre></td></tr></table></figure></li><li><p>把 service 指向 9090</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard<br></code></pre></td></tr></table></figure></li><li><p>创建 ingress yaml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat &lt;&lt;<span class="hljs-string">eof &gt; dashboard.ing.yaml</span><br><span class="hljs-string">apiVersion: networking.k8s.io/v1</span><br><span class="hljs-string">kind: Ingress</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  labels:</span><br><span class="hljs-string">    app: kubernetes-dashboard</span><br><span class="hljs-string">  name: kubernetes-dashboard</span><br><span class="hljs-string">  namespace: kubernetes-dashboard</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  rules:</span><br><span class="hljs-string">  - host: dashboard.mg.com</span><br><span class="hljs-string">    http:</span><br><span class="hljs-string">      paths:</span><br><span class="hljs-string">      - backend:</span><br><span class="hljs-string">          service:</span><br><span class="hljs-string">            name: kubernetes-dashboard</span><br><span class="hljs-string">            port: </span><br><span class="hljs-string">              number: 80</span><br><span class="hljs-string">        path: /</span><br><span class="hljs-string">        pathType: ImplementationSpecific</span><br><span class="hljs-string">  tls:</span><br><span class="hljs-string">  - hosts:</span><br><span class="hljs-string">      - dashboard.mg.com</span><br><span class="hljs-string">    secretName: mg-tls</span><br><span class="hljs-string">eof</span><br></code></pre></td></tr></table></figure></li><li><p>创建 ingress</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f dashboard.ing.yaml<br></code></pre></td></tr></table></figure></li></ul><ul><li>(可选) 实际也可以用 nginx 直接代理 https<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 直接在注解中添加</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/backend-protocol:</span> <span class="hljs-string">HTTPS</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class="hljs-string">&quot;true&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="安装-bash-completion"><a href="#安装-bash-completion" class="headerlink" title="安装 bash-completion"></a>安装 bash-completion</h4><ul><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bash-completion<br></code></pre></td></tr></table></figure></li><li><p>配置 helm 到 bash-completion 配置文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm completion bash &gt; /etc/bash_completion.d/helm<br></code></pre></td></tr></table></figure></li><li><p>生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /usr/share/bash-completion/bash_completion<br></code></pre></td></tr></table></figure></li></ul><h3 id="踩了一个大坑"><a href="#踩了一个大坑" class="headerlink" title="踩了一个大坑"></a>踩了一个大坑</h3><ul><li>阿里云会墙掉未备案的域名，如果想走公网ip，就不能随便自签一个证书<br>对通信过程的抓包<br><img src="https://static.longalong.cn/img/20220723023426.png"><br>对 tls 握手的抓包<br><img src="https://static.longalong.cn/img/20220723023648.png"></li></ul><ul><li>查看 tls 握手过程 #network #ssl<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl s_client -connect baidu.com:443 -msg<br></code></pre></td></tr></table></figure></li></ul><p>国内非 air gap 也可以使用如下加速安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -<br></code></pre></td></tr></table></figure><h3 id="后续要继续做的"><a href="#后续要继续做的" class="headerlink" title="后续要继续做的"></a>后续要继续做的</h3><ul><li><input disabled="" type="checkbox"> 调研存储的实现方案 (nfs、longhorn)</li><li><input disabled="" type="checkbox"> 调研 cert manager 的作用</li><li><input disabled="" type="checkbox"> 完成对基础环境的封包</li><li><input disabled="" type="checkbox"> 解决调试的问题( init container )</li><li><input disabled="" type="checkbox"> 考虑是否解决证书轮转问题</li><li><input disabled="" type="checkbox"> 考虑解决 registry 问题</li><li><input checked="" disabled="" type="checkbox"> 解决日志采集问题 (采或不采是个问题，方案就用 fluentd) <a href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html" name="简单的集群日志采集方案" >简单的集群日志采集方案</a> ✅ 2023-02-16</li><li><input checked="" disabled="" type="checkbox"> 解决集群监控问题 及 告警问题 <a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html" name="简单的集群监控方案" >简单的集群监控方案</a> ✅ 2023-02-16</li><li><input disabled="" type="checkbox"> 解决非常基础的一些组件问题 (redis、mysql、kafka)</li><li><input disabled="" type="checkbox"> 解决多集群管理问题 (rancher)</li><li><input disabled="" type="checkbox"> 解决多集群发布问题 </li></ul><hr><blockquote><p>As you walk in God’s divine wisdom, you will surely begin to see a greater measure of victory and good success in your life.<br>— <cite>Joseph Prince</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>云原生</tag>
      
      <tag>k8s</tag>
      
      <tag>运维</tag>
      
      <tag>k3s</tag>
      
      <tag>ingress</tag>
      
      <tag>air gap</tag>
      
      <tag>k8s集群安装</tag>
      
      <tag>dashboard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我需要什么样的集群搭建工具</title>
    <link href="/longblog/posts/22_07_21_what_kind_of_k8s_installer_that_I_need.html"/>
    <url>/longblog/posts/22_07_21_what_kind_of_k8s_installer_that_I_need.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>k3s 是一个精简的 k8s 发行版，之前在 <a href="/longblog/posts/21_12_26_a_record_of_k3s_run_up.html" name="记一次k3s环境搭建记录" >记一次k3s环境搭建记录</a> 中有过描述。</p><p>相比于 k3s_install.sh 而言， k3sup 最大的价值在于 可以通过 ssh 远程安装，而不是登录到某台机器上再执行安装。另外，通了很简洁的命令行参数。</p><p>无疑，k3sup 作为一个轻量级的集群安装工具，还是很不错的。</p><p>但逐渐我也发现了一些问题：</p><ol><li>k3sup 写死了获取 k3s_install.sh 的脚本地址，这对于国内网络环境来说，不是很友好</li><li>k3sup 只能采用有网环境部署，对于 k3s 的 air gap 状况没有支持</li><li>k3s_install.sh 中的众多环境变量，无法排上用场</li></ol><p>调研过社区中很多的集群部署工具，各工具都有自己的一些特色。</p><ul><li>有些十分轻量简单，例如 k3sup 以及一些简单封装的 ansible ； </li><li>有些有图形界面，例如 autok3s ；</li><li>有些非常庞大，把集群部署、集群管理、应用管理等融于一体的，例如 kubeoperator 之类；</li><li>还有一些发行版自带支持的工具，例如 microk8s、minikube ，包含基础的集群部署 以及 常用的一些插件(ingress、dashboard等) ；</li><li>也有一些工具和云厂商适配得比较好，例如 kops 。</li></ul><p>可以看出来，现在社区中大多数工具，都是基于 <code>网络良好</code> 的条件的。但受制于一些特殊的条件，有些时候，我们希望在一个地方把所有依赖都解决好，然后去到局域网环境下进行部署。</p><p>我比较多使用 k3sup 进行远程搭建集群，但是大多数情况下，网络环境都不是很好，因此用 k3sup 不是很友好。</p><p>我希望的 k3s 集群安装工具，最好有这些特性：</p><ol><li>支持远程安装</li><li>比较好地支持 airgap 场景</li><li>可以做版本管理 (不可变基础设施)</li><li>可以有一些自定义的基础服务</li><li>工具依赖少</li></ol><p>我决定启动一个项目，解决网络受限环境下的集群搭建问题。<br>这个项目是以解决问题为主，不求追求大而全，也不求追求何等的优雅和极致，毕竟我还有很多的事等着做。当真的觉得某些点不好用，或者某些能力无法支持时，再去考虑解决方案，整体采用渐进式的开发方式，毕竟，我也不是专门搞这个的，无法很充分地考虑到各种问题，这很正常。</p><h2 id="项目的考虑"><a href="#项目的考虑" class="headerlink" title="项目的考虑"></a>项目的考虑</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>有两种使用方式：</p><ol><li>命令行</li><li>配置式</li></ol><p>我倾向配置式的，这样方便重复使用，而命令行则容易无法记录。但命令行也有一个好处，可以很方便地进行修改。</p><h3 id="能力支持"><a href="#能力支持" class="headerlink" title="能力支持"></a>能力支持</h3><ol><li>k8s master 、k8s worker 安装启动</li><li>支持 单master 节点以及 多master 节点</li><li>支持基础的 storage 方案 (longhorn、nfs)</li><li>支持基础的网络插件 (flannel)</li><li>支持 nginx-ingress、lb</li><li>支持 air gap 的场景</li><li>可选择性包含 dashboard </li><li>将来可选择性包含其他插件 (包括业务系统插件)</li></ol><h3 id="生态选择"><a href="#生态选择" class="headerlink" title="生态选择"></a>生态选择</h3><p>就目前来看，k3s 是一个很好的能解决问题的方案，官方做了很多将 k3s 放到资源受限环境的事。<br><a href="https://microk8s.io/docs">microk8s</a> 也很不错，两者有些差异，但对我的场景来看，差异不大。从 air gap 的场景来看，microk8s 的支持没有 k3s 好。</p><p>以 k3s 作为底层实现，对当下而言，是一个不错的选择。</p><p>具体资料可以参考:</p><ul><li><a href="https://docs.rancher.cn/docs/k3s/_index">k3s 中文文档</a> </li><li><a href="https://rancher.com/docs/k3s/latest/en/">k3s 英文文档</a></li></ul><h3 id="最直接的方式"><a href="#最直接的方式" class="headerlink" title="最直接的方式"></a>最直接的方式</h3><p><a href="/longblog/posts/22_07_21_12_45_install_k3s_in_air_gap_air.html" name="网络受限环境k3s安装记录" >网络受限环境k3s安装记录</a></p><p>2020-07-21:  先完善上面的记录，把相关工具打包，看看够不够用，不够再往下一步 (todo: 采用配置文件安装)</p><p>重新看了下 <a href="https://github.com/sealerio/sealer">sealer</a> 这个项目，从理念上来看，还是很不错的，借由 docker 把 操作系统的依赖打包到一个镜像中 的理念，sealer 把所有基础设施层和业务层全部打包到一个镜像中，恢复的是一个基于 k8s 的所有应用集群。<br>把这个作为一个主要交付物，还是很简洁的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>云原生</tag>
      
      <tag>k8s</tag>
      
      <tag>运维</tag>
      
      <tag>k3s</tag>
      
      <tag>开发环境</tag>
      
      <tag>集群搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于价值输入的一些想法</title>
    <link href="/longblog/posts/22_07_19_10_30_some_reflection_of_values_input.html"/>
    <url>/longblog/posts/22_07_19_10_30_some_reflection_of_values_input.html</url>
    
    <content type="html"><![CDATA[<p>今天跟一个同学聊 “初衷” 的问题，他拿出了 want can must 的理论，并且说: must 就是你的用户的声音，是公司的价值。 我心中一震，觉得此事不对，便问这套东西是谁跟你讲的？他答xxx。是我们的团队 leader 。</p><p>对于一个团队 leader 而言，一项重要的职责，就是 保持团队稳定、提升团队效能。其中，要提升 团队稳定 性，核心就是保证 团队成员有继续留下去的理由，这可以有很多方面，例如 做感兴趣的事、有更高维度的成长、有竞争力的薪资、团队氛围、被认可，以及一个很重要的点：自己在做自己认可的事。</p><p>因此，除了外在的那些方法，从 价值输入 为基础的方法就是一个非常非常高效的方法。<br>常见的方式有：特殊小组，经常开会，讨论一些团队、企业价值、公司战略、个人目标 等等。在团体中去表达出自己的”当下的”想法。</p><p>有几个值得参考的点：</p><ol><li>一些公司喜欢招年轻人</li><li>很多公司的中层以上喜欢经常开会</li><li>我党有写作文的传统、有开会的传统、有表态的传统</li><li>重新看 《浪潮》</li><li>《亮剑》中赵刚在战俘营的工作</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>values</tag>
      
      <tag>团队管理</tag>
      
      <tag>团队</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcpdump</title>
    <link href="/longblog/posts/22_07_18_17_46_some_records_of_tcpdump_for_grab_net_packages.html"/>
    <url>/longblog/posts/22_07_18_17_46_some_records_of_tcpdump_for_grab_net_packages.html</url>
    
    <content type="html"><![CDATA[<h2 id="tcpdump-的基本使用"><a href="#tcpdump-的基本使用" class="headerlink" title="tcpdump 的基本使用"></a>tcpdump 的基本使用</h2><p>tcpdump 可以让我们直接观察网卡的网络流量，方便我们进行 四层 的问题排查 或 学习。</p><ul><li><p>简单使用： <code>tcpdump</code></p></li><li><p>指定网卡： <code>tcpdump -i eth0</code></p></li><li><p>指定显示详略： <code>tcpdump -v</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">11:12:36.647512 IP (tos 0x0, ttl 64, id 46064, offset 0, flags [DF], proto TCP (6), length 52)<br>    172.17.2.203.48402 &gt; iZ2ze57vwreom23zkxvl6qZ.8001: Flags [F.], cksum 0xc46f (correct), seq 2257707167, ack 2959427480, win 502, options [nop,nop,TS val 1345882009 ecr 581770398], length 0<br></code></pre></td></tr></table></figure></li><li><p>更多一点信息: <code>tcpdump -vv</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">11:16:16.311248 IP (tos 0x0, ttl 64, id 16969, offset 0, flags [DF], proto TCP (6), length 60)<br>    172.17.2.203.56348 &gt; iZ2ze57vwreom23zkxvl6qZ.8001: Flags [S], cksum 0x4023 (correct), seq 3161834876, win 64240, options [mss 1460,sackOK,TS val 1346101673 ecr 0,nop,wscale 7], length 0<br></code></pre></td></tr></table></figure></li><li><p>显示二进制:  <code>tcpdump -x</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">11:17:34.686426 IP (tos 0x0, ttl 64, id 64831, offset 0, flags [DF], proto TCP (6), length 60)<br>    172.17.2.203.57696 &gt; iZ2ze57vwreom23zkxvl6qZ.8001: Flags [S], cksum 0x5709 (correct), seq 2287840066, win 64240, options [mss 1460,sackOK,TS val 1346180048 ecr 0,nop,wscale 7], length 0<br>0x0000:  4500 003c fd3f 4000 4006 dfc5 ac11 02cb<br>0x0010:  ac11 02c9 e160 1f41 885d ab42 0000 0000<br>0x0020:  a002 faf0 5709 0000 0204 05b4 0402 080a<br>0x0030:  503d 13d0 0000 0000 0103 0307<br></code></pre></td></tr></table></figure></li><li><p>指定 udp : <code>tcpdump -u</code> 或者  <code>udp</code></p></li><li><p>过滤host 和 ip : <code>tcpdump &quot;host xx.xx.xx.xx &amp;&amp; port 8001&quot;</code></p></li><li><p>写入文件: <code>tcpdump -w xx.pcap -Z root</code> (-Z 指定写文件的 user，默认是 tcpdump，可能会导致 no permission)</p></li><li><p>从文件中查看： <code>tcpdump -r xx.pcap</code></p></li><li><p>不要将 port 转成名字: <code>tcpdump -n</code></p></li><li><p>指定抓包数量:  <code>tcpdump -c 3</code></p></li></ul><h2 id="过滤-expression"><a href="#过滤-expression" class="headerlink" title="过滤 (expression)"></a>过滤 (expression)</h2><p>expression 得到的是一个 bool 。</p><ul><li>协议过滤：<code>ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp, udp, icmp</code></li><li>且： <code>and | &amp;&amp;</code></li><li>源地址:  <code>src xxx.xxx.xxx.xx</code></li><li>目标地址:  <code>dst xxx.xxx.xxx.xx</code></li><li>网段过滤: <code>net 172.10.10.0/24</code></li><li>port 段过滤: <code>portrange 3000-3100</code></li></ul><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 地址 和 port </span><br>tcpdump host 192.168.1.10 and tcp port 22 -c 4 <br></code></pre></td></tr></table></figure><h2 id="http-过滤"><a href="#http-过滤" class="headerlink" title="http 过滤"></a>http 过滤</h2><ul><li>捕获所有进出 12345 端口的 IPv4 HTTP 报文，即只打印包含数据的报文，不打印 SYN、FIN、ACK-only 等报文<br>  命令示例： <code>tcpdump -i eth0 -vv -n &#39;tcp port 12345 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#39;</code></li><li>只抓获 GET 请求包<br>  命令示例：<code>tcpdump -i eth0 -vv -n &#39;tcp port 12345 and tcp[((tcp[12:1] &amp; 0xf0)&gt;&gt;2):4]=0x47455420&#39;</code></li><li>只抓获 POST 请求包<br>  命令示例：<code>tcpdump -i eth0 -vv -n &#39;tcp port 12345 and tcp[((tcp[12:1] &amp; 0xf0)&gt;&gt;2):4]=0x504f5354&#39;</code></li></ul><h2 id="tcpdump-和-wireshark-结合"><a href="#tcpdump-和-wireshark-结合" class="headerlink" title="tcpdump 和 wireshark 结合"></a>tcpdump 和 wireshark 结合</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -l 为不用缓冲，直接发送，可快速看到结果</span><br>ssh root@xx.xx.xx.xx &#x27;tcpdump -s 0 -l -i eth0 &quot;tcp port 52000&quot; -w -&#x27; | wireshark -k -i -<br></code></pre></td></tr></table></figure><h2 id="一些表达式内容"><a href="#一些表达式内容" class="headerlink" title="一些表达式内容"></a>一些表达式内容</h2><p><img src="https://static.longalong.cn/img/20220718122411.png"></p><p>可参考文档：</p><ol><li><a href="https://www.cnblogs.com/jiujuan/p/9017495.html">https://www.cnblogs.com/jiujuan/p/9017495.html</a></li><li><a href="https://blog.csdn.net/penriver/article/details/123951062">https://blog.csdn.net/penriver/article/details/123951062</a> 这篇文章虽然较短，但内容很精炼，参考下。</li></ol><p>一些好用的网络工具：</p><ol><li><a href="https://github.com/mehrdadrad/mylg">https://github.com/mehrdadrad/mylg</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>linux</tag>
      
      <tag>tcpdump</tag>
      
      <tag>网络</tag>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>效率工程</title>
    <link href="/longblog/posts/22_07_18_10_40_efficiency_engineering.html"/>
    <url>/longblog/posts/22_07_18_10_40_efficiency_engineering.html</url>
    
    <content type="html"><![CDATA[<p>得益于 ob ，我逐渐接触到了 <code>待办</code> 、 <code>daily notes</code> 、<code>memo</code> 等概念，开始关注 <code>目标管理</code>、<code>结果管理</code> 、<code>知识管理</code> 等。 我开始渐渐感觉到 轻松 和 充实，感受到一些标准的工作流 带给我的实际价值。我们可以把上面所关注的这些所有项，统称为 <code>效率工程</code>。</p><p>不论是工作 还是 自己做事情，想要得到更高的收益，始终要看两点： 工作时长 * 工作效率 。很多人喜欢通过 加班 的方式来提升收益，但在我看来，这是得不偿失的。我的公式是这样的：<br>生活总价值 = 工作时长 * 工作效率 + 生活时长 * 生活效率 。 并且 生活时长 = 16 - 工作时长 。</p><p>往往通过增加工作时长的，总会以一个不高的效率。这样，实际我们的生活总价值，反倒是降低了。所以我很不喜欢通过增加工作时长来产生价值。</p><p>另一个因子，是 <code>工作效率</code> ，这实际上是值得我们挖掘的巨大宝藏！ 上天在时间分配上，对任何人都是公平的。而之所以我们和很多牛逼的人有很大差别，往往就在于我们的工作效率有着巨大的差别！</p><p>明确了 需要极大提升 工作效率 这个目标，我们一起看看可以如何提升？</p><p>一些主题：</p><ol><li>我们能如何提升工作效率？<ol><li>目标管理 (找到真正有价值的事！)</li><li>待办管理 (罗列需要落地事)</li><li>时间管理 (安排时间精力的分布)<ol><li>通过番茄工作法，让一段时间专注于一件事</li></ol></li><li>知识库管理 (降低大脑负荷，把容量留给更有创造力的事)</li></ol></li><li>我们能如何帮助他人提升工作效率？<ol><li>明确流程、职责和交付物<ol><li>流程需要 review 和 check</li><li>每件事需要有唯一的责任人</li><li>交付物最好有标准模板</li></ol></li><li>建立公共知识库</li><li>建立团队共同目标<ol><li>周期性复盘会</li><li>团队成员共建待办项</li><li>通过有价值的事聚集向心力</li></ol></li></ol></li></ol><p>工作效率对我而言，可以包含两个方面的内容：</p><ol><li>开发工作效率</li><li>项目管理效率</li></ol><p>对于开发而言，我希望能够建立一整套快速开发流程，能够支持我快速做各类开发尝试！！！ <a href="/notpublish/index.html" name="快速开发" >快速开发</a><br>另外，我希望能够用项目管理的方法，在团队管理中 和 自己的项目中 使用起来。我将来一定会带团队，我需要怎么做好团队管理，让大家都力往一处使？ 我一定会独立做很多事，我该如何 get things done？</p><p>纵观之前很多次和老婆一起定的计划，几乎所有周期性的 或者 长期性的 计划，最后都不了了之，有些甚至没有开始。究其原因，一项重要原因就是 我们没有采用比较好的 项目管理方式，核心有以下几点：</p><ol><li>没有清晰明确的目标</li><li>没有很强的责任感 或 just do it 的执行力</li><li>没有清晰的任务拆解 和 时间规划图</li><li>没有形成文档 (知识管理)<br>另外，从客观原因看，平常要上班，因此要兼顾时间的分配问题，有时候很长时间都没法投入到自己的计划中，打破计划的挫败感十分严重。</li></ol><ul><li><input disabled="" type="checkbox"> 如何解决个人项目规划中的现实问题？</li></ul><p>从心态上，从流程上。流程可能更加有用。</p><ul><li><input disabled="" type="checkbox"> 收集一整套工作流需要的文档模板</li></ul><p>一些问题：</p><ol><li>如何快速发现自己在浪费时间？<blockquote><p>通过 daily notes<br>通过 时间计划表 (日历的时间流逝)</p></blockquote></li></ol><ol><li>有些什么样的时间管理方式？<blockquote><p>参考 day planner 的模式<br>番茄工作法</p></blockquote></li></ol><ol><li>3D原则<pre><code class=" mermaid">flowchart LRstuff --&gt; B&#123;是否 5 min 能完成?&#125;B --&gt; |YES| DO[do it right now : Do]B --&gt; |NO| B2&#123;是否一定需要自己做?&#125;B2 --&gt; |NO| Delegate[委托他人 : Delegate]B2 --&gt; |YES| Defer[加入待办 稍后完成 : Defer]</code></pre></li></ol><p>项目管理的 check 点：</p><ol><li>做的事是不是最被需要的事？</li></ol><p>值得参考的书：</p><ul><li>《GTD》</li></ul><h2 id="待相关完成的文档"><a href="#待相关完成的文档" class="headerlink" title="待相关完成的文档 :"></a>待相关完成的文档 :</h2><p>!<a href="/notpublish/index.html" name="任务管理的方法" >任务管理的方法</a></p><hr><p>归属: </p><ul><li><a href="/notpublish/index.html" name="GTD" >GTD</a></li></ul><hr><blockquote><p>I decided that it was not wisdom that enabled poets to write their poetry, but a kind of instinct or inspiration, such as you find in seers and prophets who deliver all their sublime messages without knowing in the least what they mean.<br>— <cite>Isocrates</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>开发效率</tag>
      
      <tag>效率工程</tag>
      
      <tag>任务管理</tag>
      
      <tag>工程管理</tag>
      
      <tag>待办管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何成为一个有产品思维的研发人员</title>
    <link href="/longblog/posts/22_07_16_20_12_how_to_be_a_developer_with_product_sense.html"/>
    <url>/longblog/posts/22_07_16_20_12_how_to_be_a_developer_with_product_sense.html</url>
    
    <content type="html"><![CDATA[<p>#问题 #产品 #思维</p><p>如何成为一个有产品思维的研发</p><ol><li> 产品的思维是什么样的？</li><li> 什么叫做用户思维？</li><li> 如何拥有同理心和洞察力？</li><li> 产品的职业技能有哪些？</li><li> 怎么把领域模型的思路用在产品思维上？</li><li> 怎么把 uml 的技能用在产品技能上？</li><li> 怎么借鉴产品经理的推动力(项目经理的推动力)？</li><li> 怎么借鉴产品经理的沟通能力？</li></ol><hr><blockquote><p>Friendship without self-interest is one of the rare and beautiful things of life.<br>— <cite>James F. Byrnes</cite></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模块设计优劣的评判维度</title>
    <link href="/longblog/posts/2207161954.html"/>
    <url>/longblog/posts/2207161954.html</url>
    
    <content type="html"><![CDATA[<p>#设计 #设计原则  #设计模式 #架构 #架构评价</p><p>一些技术观点 (模块评判优劣)</p><h3 id="如何评判一个模块的优劣？"><a href="#如何评判一个模块的优劣？" class="headerlink" title="如何评判一个模块的优劣？"></a>如何评判一个模块的优劣？</h3><ol><li> 功能维度：</li></ol><ul><li>评判标准有三个：<ul><li>  可复用</li><li>  可扩展</li><li>  可维护</li></ul></li><li>落地原则有：<ul><li>  基于抽象编程，而非基于实现编程</li><li>  良好的接口设计 (命名规范、善用模式、预留扩展口)</li><li>  完善的测试用例</li><li>  DRY、KISS、YAGNI、SOLID</li></ul></li></ul><ol start="2"><li> 技术维度</li></ol><ul><li>判断标准有四个：<ul><li>  高并发</li><li>  高性能</li><li>  高可靠</li><li>  伸缩性</li><li>  数据一致性</li></ul></li><li>落地需要考虑的问题：<ul><li>  CAP 的选择</li></ul></li></ul><h3 id="技术和业务的关系？"><a href="#技术和业务的关系？" class="headerlink" title="技术和业务的关系？"></a>技术和业务的关系？</h3><ol><li> 技术需要为业务服务，抛开业务谈技术，在有明确商业目标的企业中，没有意义。</li><li> 技术方案的选择不是 “业务决定的”，经常是权衡利弊之后，一起做出的决策。</li></ol><hr><blockquote><p>Love is composed of a single soul inhabiting two bodies.<br>— <cite>Aristotle</cite></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>groupcache 源码阅读记录</title>
    <link href="/longblog/posts/2207161947.html"/>
    <url>/longblog/posts/2207161947.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>“缓存” 是一个 非常、非常、非常 通用的模块，是提升 程序性能/系统性能 的极佳方式之一，缓存的模块有非常多的开源方案。</p><p>本地缓存可以使用 gcache、goframe中也有一个gcache，自己要实现一个简单的 LRU 的缓存也不难。</p><p>分布式缓存中，最常用的是 redis，几乎通吃，以前也有一些团队使用 memcache，现在几乎被 redis 替代。</p><p>内存中的缓存还可以看下 godis 这个项目，golang 的 redis 实现。</p><p>而 groupcache ，作为内存中的 分布式缓存，实现非常简洁，很有参考价值。值得一提的是，groupcache 的作者就是 memcache 的作者。</p><h2 id="可参考的方面"><a href="#可参考的方面" class="headerlink" title="可参考的方面"></a>可参考的方面</h2><h3 id="Pb-和-httpv2-提升性能"><a href="#Pb-和-httpv2-提升性能" class="headerlink" title="Pb 和 httpv2 提升性能"></a>Pb 和 httpv2 提升性能</h3><p>常规我们接触 pb，都是直接使用 grpc 生成代码，使用 grpc 的框架提供 rpc 服务，但是在 groupcache 中，作者直接把 pb 拿出来使用，并且结合 httpv2 的连接复用，也同样能够提供高性能，一定程度上达到了合 grpc 一样的能力。</p><h3 id="Singleflight-去除重复请求"><a href="#Singleflight-去除重复请求" class="headerlink" title="Singleflight 去除重复请求"></a>Singleflight 去除重复请求</h3><p>通用的解决重复请求的方案，常用于解决缓存穿透问题。</p><h3 id="87行代码的-lru-策略"><a href="#87行代码的-lru-策略" class="headerlink" title="87行代码的 lru 策略"></a>87行代码的 lru 策略</h3><p>一个双向链表 + 一个 hashmap，前者用来做 lru，后者用来做缓存。</p><p>这个双向链表是由 golang 提供的，初次之外，golang官方库还提供了 ring 和 heap 两种数据结构。</p><h3 id="48行代码的一致性hash"><a href="#48行代码的一致性hash" class="headerlink" title="48行代码的一致性hash"></a>48行代码的一致性hash</h3><p>有多个 hash slot，无删除 slot 操作。</p><p>使用的 []int 的方式做的 slot，这种方式在查询时的时间复杂度是 Ologn，这种方式和 redis client 的 slot 实现方式不一样，redis 用了更多的空间，但得到的是 O1 的查询复杂度。</p><h2 id="一些特点"><a href="#一些特点" class="headerlink" title="一些特点"></a>一些特点</h2><ol><li> 会做本地缓存(hot cache)，且无更新机制</li><li> 有 load 机制，本地缓存没有 且 未能从 peer 获取时，进行 load</li><li> 有 evicted 机制，可以设置回调</li></ol><p>整体来看，和 gcache 这类本地缓存差别不大，加的 peers 可以帮助减少 load 机制的使用，对于 load 操作很重的缓存比较有利。但本地的 cache 无法主动更新的特点可能导致缓存不一致问题。</p><p>生产使用的场景不太确定，可能适用于数据一致性不太重要、load过程很繁重的情况。</p><p>从开发角度来看，这个项目有一些可参考性，例如 48行代码实现一致性hash、87行代码实现 lru、singleflight解决缓存穿透、直接使用 pb 做为序列化方式提升性能、服务间的http使用 http2 提升性能。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 可以再看一下 go-redis 中的 hash slot 保持方法，以及 mongos 如何保证 路由到正确节点。</li></ul><hr><blockquote><p>They must often change, who would be constant in happiness or wisdom.<br>— <cite>Confucius</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>readingcodes</tag>
      
      <tag>缓存</tag>
      
      <tag>cache</tag>
      
      <tag>groupcache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webppt的分享模式</title>
    <link href="/longblog/posts/22_07_30_10_53_about_webppt.html"/>
    <url>/longblog/posts/22_07_30_10_53_about_webppt.html</url>
    
    <content type="html"><![CDATA[<p>ppt 可以使用 <a href="https://nodeppt.js.org/#slide=1">nodeppt</a> 做出很高大尚的 ppt， 或者在 ob 中，也可以很简单的使用 slides 做出 简约的 ppt ，对有分享需求的人来说，真的是非常棒的。</p><p>看到 <a href="https://hexo.fluid-dev.com/posts/hexo-nodeppt/">一篇 blog</a> 中说到 把 node ppt 生成的 ppt 嵌入到 blog 中，觉得十分有意思，或许可以尝试一下。</p><p>这个事儿可以发散一下，如果一篇分享中，把各种需要的资源 用 iframe 的方式嵌入进来，是不是很不错呢？ 比如，嵌入一个 web terminal ，分享的时候直接可以操作。对于前端代码，大家有 <a href="https://codepen.io/">codepen</a> 这类工具嵌入。</p><p>其实 figma 这方面已经做的挺不错了，有原型演示等功能直接用。master 可以借鉴一下。</p><h3 id="什么形式的分享，算得上是好的分享？"><a href="#什么形式的分享，算得上是好的分享？" class="headerlink" title="什么形式的分享，算得上是好的分享？"></a>什么形式的分享，算得上是好的分享？</h3><p>#疑问 #blog #教程<br>之前有看到 <a href="https://liveblocks.io/blog/how-to-animate-multiplayer-cursors">协同 api 的分享</a> 和 <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/">figma 协同分享</a> 中，作者为了把一个问题说明白，真的是 无所不用其极 。反观自己的一些分享，不过是简单的把自己想说的写了上去而已，甚至很少去考虑读者能不能很好地理解。</p><ul><li><p><input checked="" disabled="" type="checkbox">  使用 slides 制作一个分享用 ppt ✅ 2023-03-02</p></li><li><p><a href="/notpublish/index.html" name="网络协议的分享" >网络协议的分享</a></p></li><li><p><a href="/notpublish/index.html" name="play_something_interesting_with_k8s" >play_something_interesting_with_k8s</a></p></li><li><p><a href="/notpublish/index.html" name="learn_k8s_on_the_view_of_nvwa" >learn_k8s_on_the_view_of_nvwa</a></p></li></ul><p>3月2日记录:<br>用 slides 做了几次分享，整体感觉很不错，主要的价值是：</p><ul><li>简单，可用</li><li>可以让我们把注意力放到内容上</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ppt</tag>
      
      <tag>webppt</tag>
      
      <tag>nodeppt</tag>
      
      <tag>slides</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动解决文章的图片问题</title>
    <link href="/longblog/posts/22_07_how_to_reslove_random_pic.html"/>
    <url>/longblog/posts/22_07_how_to_reslove_random_pic.html</url>
    
    <content type="html"><![CDATA[<p>我有给文章添加图片的需求，主要是为了解决一些需要发布的文章 没有 头图的问题。</p><p>有几个解决方案：</p><ol><li>在创建 post 的时候，创建好图片</li><li>通过命令的方式，增加图片</li></ol><p>另外，我希望我的图片能够更加稳定地存在自己的图床上，因此有把图片放到自己图床的需求，这部分可以参考 <a href="/longblog/posts/22_07_30_09_47_image_bed_in_ob.html" name="解决ob的图床问题" >解决ob的图床问题</a></p><p>先用最简单的方式，使用 templater 插件，插件的使用可以参考 <a href="/notpublish/index.html" name="ob插件选择和使用" >ob插件选择和使用</a>。<a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/system-module.html" title="Previous chapter">templater官方博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;% tp.web.random_picture(&quot;600x200&quot;, &quot;landscape,water&quot;) %&gt;<br></code></pre></td></tr></table></figure><p>这样得到的，是一个在 文档中使用 超链接 呈现出来的图片。</p><p>我希望能在 meta 中添加一张图片，则自己写了个脚本，注入到 templater 中，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newimage</span>(<span class="hljs-params">size, query</span>) </span>&#123;<br><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> getRequest(<br><span class="hljs-string">`https://source.unsplash.com/random/<span class="hljs-subst">$&#123;size ?? <span class="hljs-string">&quot;&quot;</span>&#125;</span>?<span class="hljs-subst">$&#123;query ?? <span class="hljs-string">&quot;&quot;</span>&#125;</span>`</span>);<br><br><span class="hljs-keyword">const</span> url = response.url;<br><br><span class="hljs-comment">// 这里可以做一些其他处理，比如上传到自己的图床</span><br><br><span class="hljs-keyword">return</span> url<br><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequest</span>(<span class="hljs-params">url</span>) </span>&#123;<br><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);<br><br><span class="hljs-keyword">if</span> (!response.ok) &#123;<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Error performing GET request&quot;</span>);<br><br>&#125;<br><br><span class="hljs-keyword">return</span> response;<br><br>&#125;<br><br><br><span class="hljs-built_in">module</span>.exports = newimage;<br></code></pre></td></tr></table></figure><p>命令暂时就不加了，使用 template 的快捷键一样 ok 。</p><p>当然，按理使用 quickadd 也能实现此功能，回头再看。</p><h3 id="增加转成自己的图床"><a href="#增加转成自己的图床" class="headerlink" title="增加转成自己的图床"></a>增加转成自己的图床</h3><p>我在 上面的代码中，加上上传到 picgo ，改成了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newimage</span>(<span class="hljs-params">size, query</span>) </span>&#123;<br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> getRequest(<br><span class="hljs-string">`https://source.unsplash.com/random/<span class="hljs-subst">$&#123;size ?? <span class="hljs-string">&quot;&quot;</span>&#125;</span>?<span class="hljs-subst">$&#123;query ?? <span class="hljs-string">&quot;&quot;</span>&#125;</span>`</span>);<br><br><span class="hljs-keyword">const</span> url = response.url;<br><br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(uploadUrl, &#123;<br><span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span> &#125;,<br><span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">list</span>: [url] &#125;),<br>&#125;);<br><br><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json();<br><span class="hljs-keyword">return</span> data.result[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequest</span>(<span class="hljs-params">url</span>) </span>&#123;<br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);<br><br><span class="hljs-keyword">if</span> (!response.ok) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Error performing GET request&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> response;<br>&#125;<br><br><br><span class="hljs-built_in">module</span>.exports = newimage;<br></code></pre></td></tr></table></figure><p>意想不到的是，居然发生了 <code>CORS</code> 的问题，而这种问题，只能由 picgo 来解决了，于是download 了 picgo 的代码，一番操作，添加了 跨域允许 的 header ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 handleRequest 中添加了 OPTIONS</span><br><span class="hljs-keyword">if</span> (request.method === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>handleResponse(&#123;<br>response,<br><span class="hljs-attr">header</span>: &#123;<br><span class="hljs-string">&#x27;access-control-allow-headers&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br><span class="hljs-string">&#x27;access-control-allow-methods&#x27;</span>: <span class="hljs-string">&#x27;POST, GET, OPTIONS&#x27;</span>,<br><span class="hljs-string">&#x27;access-control-allow-origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>&#125;<br>&#125;)<br><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 在 处理 upload 的请求中，添加同样的 OPTIONS</span><br></code></pre></td></tr></table></figure><p>然后，perfect ！</p><p>最后，增加一个纯模板，配一个命令，per<del>per</del>perfect !</p><hr><p>归属: </p><ul><li><a href="/longblog/posts/22_07_09_10_26_problems_in_using_ob.html" name="ob的使用问题" >ob的使用问题</a></li><li><a href="/longblog/posts/22_07_30_09_45_how_to_handle_publish_issues_in_ob.html" name="解决ob的发布问题" >解决ob的发布问题</a></li></ul><hr><blockquote><p>A prudent question is one half of wisdom.<br>— <cite>Francis Bacon</cite></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>ob</tag>
      
      <tag>ob插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些设计原则</title>
    <link href="/longblog/posts/22_07_21_37_37_some_priciples_of_design.html"/>
    <url>/longblog/posts/22_07_21_37_37_some_priciples_of_design.html</url>
    
    <content type="html"><![CDATA[<p>小红书发布的 52 个设计原则，涉及很多用户心理 和 视觉心理 的内容，值得多看几遍，去思考各个产品设计是不是符合一些原则  <a href="https://rpdc.xiaohongshu.com/52-design-principles">52个设计原则</a></p><p>列举一些理论或效应：</p><ul><li><p>把结论放在前面  =&gt; 倒金字塔结构</p></li><li><p>一图胜千言 =&gt; 图优效应</p></li><li><p>自己参与的事情会被认为价值更高 =&gt; 宜家效应</p></li><li><p>被期望成什么样的，会慢慢真的变成什么样 =&gt; 皮格马利翁效应</p></li><li><p>经过深度分析的信息会比简单理解的信息更容易被记住 =&gt; 认知加工层次</p></li><li><p>400ms 的及时反馈会让使用者保持专注，甚至上瘾 =&gt; 多尔蒂门槛</p></li><li><p>人脑最多能同时处理 5-9 个信息 =&gt; 米勒定律</p></li></ul><p>对于这类  原则  的资料，要多收集，要多看，这都是底层知识，具有很强的 <a href="/notpublish/index.html" name="时间复利" >时间复利</a> 性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计原则</tag>
      
      <tag>设计</tag>
      
      <tag>原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>syncthing的方案及安装记录</title>
    <link href="/longblog/posts/22_07_30_10_17_syncthing_install_log_to_resolve_file_sync.html"/>
    <url>/longblog/posts/22_07_30_10_17_syncthing_install_log_to_resolve_file_sync.html</url>
    
    <content type="html"><![CDATA[<p>项目地址： <a href="https://github.com/syncthing/syncthing">syncthing</a></p><h3 id="安装-syncthing"><a href="#安装-syncthing" class="headerlink" title="安装 syncthing"></a>安装 syncthing</h3><ul><li><p>下载地址: <a href="https://github.com/syncthing/syncthing/releases">https://github.com/syncthing/syncthing/releases</a></p></li><li><p>选择和自己电脑匹配的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/syncthing/syncthing/releases/download/v1.20.3/syncthing-linux-amd64-v1.20.3.tar.gz <br></code></pre></td></tr></table></figure></li><li><p>解压目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf syncthing-linux-amd64-v1.20.3.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>移动文件到 /usr/bin 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv syncthing-linux-amd64-v1.20.3/syncthing /usr/bin/syncthing<br></code></pre></td></tr></table></figure></li><li><p>创建启动用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adduser syncthing<br></code></pre></td></tr></table></figure></li><li><p>创建 systemd 开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp syncthing-linux-amd64-v1.20.3/etc/linux-systemd/system/syncthing@.service /etc/systemd/system/syncthing@syncthing.service<br></code></pre></td></tr></table></figure></li><li><p>允许开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> syncthing@syncthing.service<br></code></pre></td></tr></table></figure></li><li><p>开启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start syncthing@syncthing.service<br></code></pre></td></tr></table></figure></li><li><p>配置代理</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_pass</span> <span class="hljs-number">127.0.0.1:8384</span>;<br></code></pre></td></tr></table></figure></li><li><p>开放防火墙<br><code>22000/tcp</code> + <code>22000/tcp</code></p></li></ul><h3 id="安装-discover"><a href="#安装-discover" class="headerlink" title="安装 discover"></a>安装 discover</h3><p>由于公共的 discover 服务在国内访问实在问题大大的，因此最好自己搭一个发现服务器 (类似于信令服务)。</p><ul><li><p>下载地址： <a href="https://github.com/syncthing/discosrv/releases">https://github.com/syncthing/discosrv/releases</a></p></li><li><p>下载和服务器匹配的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/syncthing/discosrv/releases/download/v1.18.6/stdiscosrv-linux-amd64-v1.18.6.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf stdiscosrv-linux-amd64-v1.18.6.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>将文件移动到 opt 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv stdiscosrv-linux-amd64-v1.18.6 /opt/stdiscosrv<br></code></pre></td></tr></table></figure></li><li><p>创建 daemon</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat &lt;&lt;<span class="hljs-string">eof &gt;  /etc/systemd/system/syncdiscover@syncthing.service</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=Syncthing discover for %I</span><br><span class="hljs-string">After=network.target</span><br><span class="hljs-string">StartLimitIntervalSec=60</span><br><span class="hljs-string">StartLimitBurst=4</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">WorkingDirectory=/opt/stdiscosrv</span><br><span class="hljs-string">User=%i</span><br><span class="hljs-string">ExecStart=/opt/stdiscosrv/stdiscosrv -debug -listen 0.0.0.0:8101</span><br><span class="hljs-string">Restart=on-failure</span><br><span class="hljs-string">RestartSec=1</span><br><span class="hljs-string">SuccessExitStatus=3 4</span><br><span class="hljs-string">RestartForceExitStatus=3 4</span><br><span class="hljs-string"></span><br><span class="hljs-string"># Hardening</span><br><span class="hljs-string">ProtectSystem=full</span><br><span class="hljs-string">PrivateTmp=true</span><br><span class="hljs-string">SystemCallArchitectures=native</span><br><span class="hljs-string">MemoryDenyWriteExecute=true</span><br><span class="hljs-string">NoNewPrivileges=true</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string"></span><br><span class="hljs-string">eof</span><br><br></code></pre></td></tr></table></figure></li><li><p>运行服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> syncdiscover@syncthing.service &amp;&amp;\<br>systemctl start syncdiscover@syncthing.service<br></code></pre></td></tr></table></figure></li><li><p>查看服务运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status syncdiscover@syncthing.service<br></code></pre></td></tr></table></figure></li><li><p>查看服务 id</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">journalctl -u syncdiscover@syncthing.service<br></code></pre></td></tr></table></figure></li><li><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">7月 10 20:11:26 longser2 stdiscosrv[19917]: stdiscosrv v1.18.6 &quot;Fermium Flea&quot; (go1.17.6 linux-amd64) teamcity@build.syncthing.net 2021-12-30 12:07:01 UTC [purego]<br>7月 10 20:11:26 longser2 stdiscosrv[19917]: Server device ID is xxxx-xxxx-xxxx-xxxx-xxxx-xxx<br></code></pre></td></tr></table></figure></li><li><p>在各客户端中修改 全局发现服务器地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://xxx.xxx.xxx:8101/?id=xxxx-xxxx-xxxx<br></code></pre></td></tr></table></figure></li></ul><ul><li>官方文档地址: <a href="https://docs.syncthing.net/users/stdiscosrv.html">https://docs.syncthing.net/users/stdiscosrv.html</a></li></ul><h3 id="安装-relay-server"><a href="#安装-relay-server" class="headerlink" title="安装 relay server"></a>安装 relay server</h3><p>relay 服务的使用场景是，当 p2p 失败时，可以借由 relay server 进行数据转发。</p><ul><li><p>下载地址： <a href="https://github.com/syncthing/relaysrv/releases">https://github.com/syncthing/relaysrv/releases</a></p></li><li><p>下载和服务器匹配的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/syncthing/relaysrv/releases/download/v1.18.6/strelaysrv-linux-amd64-v1.18.6.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf strelaysrv-linux-amd64-v1.18.6.tar.gz<br></code></pre></td></tr></table></figure></li></ul><p>我目前没有 relay 的需求，待有需求时，再来完善此处。</p><ul><li>官方文档地址: <a href="https://docs.syncthing.net/users/strelaysrv.html">https://docs.syncthing.net/users/strelaysrv.html</a></li></ul><hr><p>归属:</p><ul><li><a href="/notpublish/index.html" name="syncthing" >syncthing</a>  安装记录</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>syncthing</tag>
      
      <tag>文件同步</tag>
      
      <tag>操作记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决ob的图床问题</title>
    <link href="/longblog/posts/22_07_30_09_47_image_bed_in_ob.html"/>
    <url>/longblog/posts/22_07_30_09_47_image_bed_in_ob.html</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>如 <a href="/longblog/posts/22_07_30_09_45_how_to_handle_publish_issues_in_ob.html" name="解决ob的发布问题" >解决ob的发布问题</a> 中所描述的，我有很强的发布需求，在发布过程中，经常遇到这样的问题：</p><ol><li>图片数量多了后，压缩、打包、发布的速度就降下去了 [强诉求]</li><li>不同的电脑间，文件同步变成了一个比较麻烦的事 [弱诉求]</li><li>分享一篇文档时，本地图片地址无法查看 [中等诉求]</li></ol><p>于是就开始思考这个问题 :  <code>如何解决 blog 的 图片/视频 等静态资源问题?</code></p><p>方案实际是很成熟的 : 使用图床。</p><p>实际上，图床是一个非常广泛的需求，不论大家用什么写作工具，只要想发布到互联网上，都需要用到图床。</p><p>在网上，大家能搜到很多第三方的图床平台(github、gitee、bilibili 以及一些奇奇怪怪的平台)，但很多都不稳定，容易挂掉(或关闭)，对图床而言，稳定性是极其重要的，否则重新整理历史文档中的图片地址，然后再重新发布到各平台……这也太难了……<br>(想想微信图片加了防盗链、简书加了防盗链……)</p><p>自建图床 可能对有强写作习惯的人来说是一个比较好的方案。<br>图床 的搭建需要两个部分： 存储空间 + 管理工具。</p><p>在云端上，存储空间 可以直接选择 对象存储 ，也可以使用服务器挂载硬盘，各有一定优劣，但对大多数人来说，<code>对象存储</code> 是一个更合适的选择。</p><p>管理工具，可以建立在云端服务器上，也可以建立在本机。如果选择了对象存储方案，则可以把管理工具建在本机。好处是省去了服务器的维护工作。</p><p>我会选择 七牛云 作为存储空间 (因为每个月有 10Gb 免费空间和流量啊！七牛赛高！)，选择用 <a href="https://github.com/Molunerfinn/PicGo">picGo</a> 作为图床管理工具。</p><p>我在 ob 中，使用 <a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin/blob/master/readme-zh.md">自动上传图片</a> ，直接将 copy 的图片上传到了图床上。</p><p>使用了一段时间后，发现直接用图床有些问题，比如断网环境下就没法使用了…… 而且平常在本地使用时，会有明显的图片显示延迟。</p><p>其实，我需要的是这样的功能：</p><ol><li>图片平常就保存在本地，但希望存放在某个特定目录 [似乎需求不强]</li><li>图片是采用 md 格式的引用，而不是 wiki 的引用 [图片直接上传问题问题也不大]</li><li>当有发布需要时，把对应的本地图片链接转换成图床地址 [同上]</li><li>发布打包时，对照是否已经存在上传过的图片，已上传则不再上传 [同上]</li></ol><p>可以查阅 ob 的开发者文档，看看怎么拦截 cmd + v 。同时可以参考  <a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin/blob/master/readme-zh.md">自动上传图片</a> ，看看他是怎么做到的。 </p><blockquote><p>ps: 2022-07-30 按，目前使用的 picGo，使用 cmd + shift + v 和 cmd + v 两种方式选择图片存本地和上传。因为强缓存的问题，实际也没有多少请求 cdn 。目前够用，暂时不考虑其他方案。<br>之前 picGo 没设置跨域，在 ob 中写 js 脚本上传会有问题，看了下 picGo 的代码，提了 pr ，已经通过了，也解决了自己写 js 脚本上传问题。</p></blockquote><p>详细信息可以查看 <a href="/longblog/posts/22_07_how_to_reslove_random_pic.html" name="自动解决文章的图片问题" >自动解决文章的图片问题</a></p><h3 id="解决预览大小问题"><a href="#解决预览大小问题" class="headerlink" title="解决预览大小问题"></a>解决预览大小问题</h3><p>目前没有比较通用的解决方案，或许使用 image 标签是不错的方案。</p><blockquote><p>ps： 2022-07-30 按，在 ob 中，使用 image in editor 的插件，就能很好解决。在 web 端，默认是 100% 的大小，正常需求下没问题。图片组  可以参考  hexo fluid 的方案，有需求时再看。</p></blockquote><p>可以参考的工具：<br><a href="https://github.com/tiann/markdown-img-upload">md-image-upload</a><br><a href="https://github.com/aleksey-rezvov/obsidian-local-images">将图片下载到本地</a><br><a href="https://github.com/Molunerfinn/PicGo">上传图片的服务</a><br><a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin/blob/master/readme-zh.md">自动上传图片</a></p><hr><p>归属:</p><ul><li><a href="/longblog/posts/22_07_09_10_26_problems_in_using_ob.html" name="ob的使用问题" >ob的使用问题</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ob的使用问题</title>
    <link href="/longblog/posts/22_07_09_10_26_problems_in_using_ob.html"/>
    <url>/longblog/posts/22_07_09_10_26_problems_in_using_ob.html</url>
    
    <content type="html"><![CDATA[<p>这是解决 ob 的使用过程中，我遇到的问题 以及 解决的方式</p><ol><li><a href="/longblog/posts/22_07_30_09_45_how_to_handle_publish_issues_in_ob.html" name="解决ob的发布问题" >解决ob的发布问题</a></li><li><a href="/longblog/posts/22_07_30_10_22_the_way_how_i_sync_files_for_ob.html" name="ob文件同步方案" >ob文件同步方案</a></li><li><a href="/longblog/posts/22_07_30_09_47_image_bed_in_ob.html" name="解决ob的图床问题" >解决ob的图床问题</a></li><li><a href="/notpublish/index.html" name="解决ob的任务管理问题" >解决ob的任务管理问题</a></li><li><a href="/notpublish/index.html" name="解决ob的自动标签问题" >解决ob的自动标签问题</a></li><li><a href="/longblog/posts/22_07_how_to_reslove_random_pic.html" name="自动解决文章的图片问题" >自动解决文章的图片问题</a></li><li><a href="/longblog/posts/22_07_30_10_22_the_way_how_i_sync_files_for_ob.html" name="ob文件同步方案" >ob文件同步方案</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ob</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ob文件同步方案</title>
    <link href="/longblog/posts/22_07_30_10_22_the_way_how_i_sync_files_for_ob.html"/>
    <url>/longblog/posts/22_07_30_10_22_the_way_how_i_sync_files_for_ob.html</url>
    
    <content type="html"><![CDATA[<p>ob 是基于本地存储的 md 编辑器 及 知识管理软件。 由于其文件存储在本地，当我们有 2 台以上的终端设备时，就希望某一台终端上的修改能够及时同步到其他终端。此时，就有文件同步的需求了。</p><p>我有两台 mac ，一台在公司，一台在家里，我希望两台的内容能够同步，这样，在公司(jia)里没写完的内容，回到家 ( gongsi ) 还能接着写。</p><p>方案有如下几个：</p><ul><li>官方提供的 sync 服务</li><li>远程硬盘挂载</li><li>远程同步</li></ul><p>下面分别看看。</p><h3 id="买官方的-sync-服务"><a href="#买官方的-sync-服务" class="headerlink" title="买官方的 sync 服务"></a>买官方的 sync 服务</h3><p>根据<a href="https://obsidian.md/sync">官网的信息</a>， 每个月 <code>$8</code> ( 我穷！我不配！)<br>能白嫖的，就一定不能付费！！！<br>(🙏🙏🙏 抱歉了，ob 的同学们，感恩提供的软件，下次一定)</p><h3 id="远程硬盘挂载"><a href="#远程硬盘挂载" class="headerlink" title="远程硬盘挂载"></a>远程硬盘挂载</h3><p>硬盘的物理位置不一定在本地，可以在云端的某个位置，因此当我们的几台电脑都挂载同一个远程的硬盘，就能实现文件的同步了，这有一个更为大家熟知的名字:   <code>网盘</code></p><p>目前实现网盘的方案有很多，例如：<code>ftp</code> 、<code>nfs</code>、<code>smb</code> 、<code>webdav</code> 。相对应的，只要我们提供对应的 service 就可以了。</p><p>提供服务的方式有两类:</p><ul><li>由自己在一台服务器上启动对应的 server<ul><li>nfs server 、smb server、 ftp server、webdav server 等</li><li>nextcloud、 owncloud、seafile、cloudreve 等</li></ul></li><li>直接使用一些云厂商提供的服务。<ul><li>aliyun nas 、七牛云、 坚果云 等</li></ul></li></ul><p>优势：</p><ul><li>直接的远程同步，支持 ( 近 )实时修改同步</li></ul><p>劣势:</p><ul><li>需要完全的网络通路，弱网体验较差，断网情况不可使用</li><li>自行搭建有门槛，云厂商提供的价格也不低</li></ul><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><p>远程同步类似于保持多个存储库均保有一份数据，在一个地方的修改定期同步到各方。</p><p>可以有两个方案：</p><ul><li>基于 git 的版本管理和同步</li><li>基于 文件夹同步的方案</li></ul><p>如果采用 git 的方案，那么就要解决 pull 和 push 触发的问题，例如使用 crontab。或者使用手动操作的方式 <a href="obsidian://show-plugin?id=obsidian-git">ob git 插件</a></p><p>如果采用 文件夹同步的方案，例如 <code>syncthing</code> ，那么就需要看是否有 版本管理的需求。 (ps: 历史版本并不是仅能使用 git 方案，ob 本身是提供了 历史版本的机制的 )</p><p>git 可以白嫖 <code>gitee</code> 或 <code>github</code> 或 <code>coding</code> 或 <code>codeup</code> (阿里云效) ，都还 ok 。 自己搭的话，用 <code>gitea</code> 就 ok。</p><p>文件夹同步的话，自己搭的话可以用 <code>rsync</code> 或者 <code>syncthing</code> 均可。如果希望使用直接的服务，那么 坚果云、onedrive、icloud 等均可 (华为、小米 均有云空间产品，如果设备的生态比较统一的话，也比较 ok)。</p><p>这里就比较纠结了 😖</p><h3 id="我的需求"><a href="#我的需求" class="headerlink" title="我的需求"></a>我的需求</h3><p>一切的方案都应当以实际需求出发！</p><p>总结了一下，我对于 ob 存储的需求其实只有 1 个 能自动同步文件即可。</p><p>另外，<br>我有文件存储和备份的需求。<br>我有图片 gallery 的需求。<br>我有跨端的需求 (需要支持 android、mac、windows、linux)。<br>我有全下云的长远诉求。</p><p>综合来看，可以先选择在云端自建 syncthing ，各客户端也安装 <a href="/notpublish/index.html" name="syncthing" >syncthing</a>。</p><h3 id="ob的其他方面"><a href="#ob的其他方面" class="headerlink" title="ob的其他方面"></a>ob的其他方面</h3><ol><li>我有很强的 <code>publish</code> 需求 <a href="/longblog/posts/22_07_30_09_45_how_to_handle_publish_issues_in_ob.html" name="解决ob的发布问题" >解决ob的发布问题</a></li><li>我有很强的 <code>图床</code> 需求 <a href="/longblog/posts/22_07_30_09_47_image_bed_in_ob.html" name="解决ob的图床问题" >解决ob的图床问题</a></li><li>我希望能够智能进行关键词提炼 <a href="/notpublish/index.html" name="解决ob的自动标签问题" >解决ob的自动标签问题</a></li><li>可以参考这个项目 <a href="https://github.com/vrtmrz/obsidian-livesync">livesync</a></li></ol><hr><p>归属:</p><ul><li><a href="/longblog/posts/22_07_09_10_26_problems_in_using_ob.html" name="ob的使用问题" >ob的使用问题</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ob</tag>
      
      <tag>syncthing</tag>
      
      <tag>文件同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决ob的发布问题</title>
    <link href="/longblog/posts/22_07_30_09_45_how_to_handle_publish_issues_in_ob.html"/>
    <url>/longblog/posts/22_07_30_09_45_how_to_handle_publish_issues_in_ob.html</url>
    
    <content type="html"><![CDATA[<p>我的一个强需求是: 将 ob 上管理的这些文档，发布到 web 中。</p><ul><li>在发布的页面中，要解决 双向链接 的识别问题 [强需求]</li><li>在发布的页面中，要解决 悬浮阅读 的问题 [中强需求]</li><li>在发布的页面中，要解决 段落引用 的问题 [中等需求]</li><li>在发布的页面中，我需要有 知识关联图谱 存在 [弱需求]</li></ul><ul><li><input disabled="" type="checkbox"> 解决文档发布的多平台分发问题 <a href="/notpublish/index.html" name="TODOs" >TODOs</a> #tasks <ul><li><input checked="" disabled="" type="checkbox"> 解决 github 的发布问题 ✅ 2022-07-16</li><li><input checked="" disabled="" type="checkbox"> 解决 blog 站 的发布问题 ✅ 2022-07-16</li><li><input disabled="" type="checkbox"> 解决 infoq 写作平台的发布问题</li><li><input disabled="" type="checkbox"> 解决 掘金 的发布问题</li><li><input disabled="" type="checkbox"> 解决 简书 的发布问题</li><li><input disabled="" type="checkbox"> 解决 CSDN 的发布问题</li><li><input disabled="" type="checkbox"> 解决 gitee 的发布问题</li></ul></li><li><input checked="" disabled="" type="checkbox"> 修改 hexo-backlink 的代码，以适应我的需求 <a href="/longblog/posts/22_07_30_09_45_how_to_handle_publish_issues_in_ob.html#hexo 解决双链问题" name="解决ob的发布问题" >解决ob的发布问题</a> ✅ 2022-07-16</li><li><input checked="" disabled="" type="checkbox"> 发布的文章中，有图片比没图片的阅读心理压力小，增加图片 ✅ 2022-07-16 <a href="/longblog/posts/22_07_how_to_reslove_random_pic.html" name="自动解决文章的图片问题" >自动解决文章的图片问题</a></li><li><input checked="" disabled="" type="checkbox"> 解决 悬浮阅读 的发布问题 ✅ 2022-07-30</li><li><input disabled="" type="checkbox"> 通过 CICD 完成现有平台的发布</li></ul><p>由于我的 博客 渲染，采用的是 hexo 体系，因此发布问题的解决，需要结合 hexo 的生态。</p><h3 id="hexo-解决双链问题"><a href="#hexo-解决双链问题" class="headerlink" title="hexo 解决双链问题"></a>hexo 解决双链问题</h3><p>最简单的方案是: <code>npm install hexo-backlink</code>， <a href="https://github.com/Cyrusky/hexo-backlink">项目地址</a></p><p>由于 社区的 hexo-backlink 不支持子路径，因此借鉴一下自己改改。</p><p>hexo 采取的插件机制，估计是用的类似于 <a href="https://github.com/bellard/quickjs">quickjs</a> 或者 v8 的沙盒，可由开发者自行开发插件，而 hexo 只需要把所有的插件代码组织起来，运行一遍，就能实现插件对内容的处理。沙盒技术可以参考 <a href="https://www.pudn.com/news/628f83bdbf399b7f351eb05d.html">虚拟机随谈</a> #插件机制 #quickjs #js引擎</p><p>考虑到将来可能会有比较多的 hexo 的适配问题，因此希望能更全面了解 hexo 的插件能<br>力，可以阅读 <a href="https://hexo.io/zh-cn/api/filter">hexo extend</a></p><p>不得不说，hexo 的文档写得是真的烂……<br>根本不知道每个阶段有什么参数，会影响什么……<br>最后，通过 两次 <code>before_post_render</code> 解决了全局变量获取的问题，虽然不怎么优雅，但算是能解决问题。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// data 为 </span><br><span class="hljs-comment">// [ </span><br><span class="hljs-comment">// [&#123;&#125;,&#123;&#125;], posts</span><br><span class="hljs-comment">// [] about,index</span><br><span class="hljs-comment">// ]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doreplace</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> &#123; content, title &#125; = data;<br>  <span class="hljs-keyword">let</span> result = content.match(<span class="hljs-regexp">/\[\[.*?\]\]/g</span>);<br>  <span class="hljs-keyword">if</span> (result &amp;&amp; result.length &gt; <span class="hljs-number">0</span>) &#123;<br>    result.forEach(<span class="hljs-function">(<span class="hljs-params">linkName</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> [realName, showName] = (linkName + <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;[[&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;]]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .split(<span class="hljs-string">&quot;|&quot;</span>);<br>      <span class="hljs-keyword">let</span> anchor = <span class="hljs-literal">null</span>;<br>      [realName, anchor] = realName.split(<span class="hljs-string">&quot;#&quot;</span>);<br><br>      <span class="hljs-keyword">let</span> doc = hexo.locals.get(realName)<br>      <span class="hljs-comment">// console.log(&quot;path : &quot;, doc.path);</span><br>      <span class="hljs-built_in">console</span>.log(doc)<br><br>      <span class="hljs-keyword">if</span> (doc) &#123;<br>        <span class="hljs-keyword">let</span> path = getsubpath(doc.permalink)<br>        content = content.replace(<br>          linkName,<br>          <span class="hljs-string">`&lt;a href=&quot;<span class="hljs-subst">$&#123;path&#125;</span><span class="hljs-subst">$&#123;anchor ? <span class="hljs-string">&quot;#&quot;</span> + anchor : <span class="hljs-string">&quot;&quot;</span>&#125;</span>&quot; name=&quot;<span class="hljs-subst">$&#123;realName&#125;</span>&quot; &gt;<span class="hljs-subst">$&#123;showName || realName&#125;</span>&lt;/a&gt;`</span><br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        content = content.replace(<br>          linkName,<br>          <span class="hljs-string">`&lt;a href=&quot;/notpublish/index.html&quot; name=&quot;<span class="hljs-subst">$&#123;realName&#125;</span>&quot; &gt;<span class="hljs-subst">$&#123;showName || realName&#125;</span>&lt;/a&gt;`</span><br>        );<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  data.content = content;<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// 先统计</span><br>hexo.extend.filter.register(<span class="hljs-string">&quot;before_post_render&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (ignore(data)) &#123;<span class="hljs-keyword">return</span>&#125;<br><br>    hexo.locals.set(data.title, <span class="hljs-function">() =&gt;</span> data)<br>  &#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 后替换</span><br>hexo.extend.filter.register(<span class="hljs-string">&quot;before_post_render&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (ignore(data)) &#123;<span class="hljs-keyword">return</span>&#125;<br><br>    doreplace(data)<br>  &#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ignore</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> sourceFileName = data.source;<br>  <span class="hljs-keyword">var</span> ext = sourceFileName.substring(sourceFileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>)).toLowerCase();<br>  <span class="hljs-keyword">return</span> !data.publish || ext != <span class="hljs-string">&#x27;.md&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getsubpath</span>(<span class="hljs-params">p</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (p.match(<span class="hljs-regexp">/^(http|https):\/\//</span>)) &#123;<br>    <span class="hljs-keyword">let</span> u = <span class="hljs-keyword">new</span> URL(p)<br>    <span class="hljs-keyword">return</span> u.pathname<br>  &#125;<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="解决-blog-站的发布问题"><a href="#解决-blog-站的发布问题" class="headerlink" title="解决 blog 站的发布问题"></a>解决 blog 站的发布问题</h3><p>方案： 采用 七牛云 的 qshell，发布到某个 bucket 下即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qshell qupload quploadconfig.json<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">➜  blog git:(master) ✗ cat quploadconfig.json <br>&#123;<br>    &quot;src_dir&quot;            :   &quot;publish/&quot;,<br>    &quot;bucket&quot;             :   &quot;bloglong&quot;,<br>    &quot;key_prefix&quot;         :   &quot;&quot;,<br>    &quot;ignore_dir&quot;         :   false,<br>    &quot;overwrite&quot;          :   true,<br>    &quot;check_exists&quot;       :   false,<br>    &quot;check_hash&quot;         :   true,<br>    &quot;check_size&quot;         :   false,<br>    &quot;rescan_local&quot;       :   true,<br>    &quot;skip_file_prefixes&quot; :   &quot;test,demo,&quot;,<br>    &quot;skip_path_prefixes&quot; :   &quot;temp/&quot;,<br>    &quot;skip_fixed_strings&quot; :   &quot;.svn,.git,.vscode&quot;,<br>    &quot;skip_suffixes&quot;      :   &quot;.DS_Store&quot;,<br>    &quot;log_rotate&quot;         :   1,<br>    &quot;log_stdout&quot;         :   false,<br>    &quot;file_type&quot;          :   0,<br>    &quot;resumable_api_v2&quot;   :   false,<br>    &quot;resumable_api_v2_part_size&quot; : 4194304<br> &#125;<br><br></code></pre></td></tr></table></figure><h3 id="解决-github-发布问题"><a href="#解决-github-发布问题" class="headerlink" title="解决 github 发布问题"></a>解决 github 发布问题</h3><p>方案： 采用 docs 目录，作为 github pages 的入口。</p><p>目前可以先这样用着，之后觉得 <code>基于分支</code> 的发布方式更好的话，到时再调整一下就行。</p><h3 id="解决悬浮阅读的问题"><a href="#解决悬浮阅读的问题" class="headerlink" title="解决悬浮阅读的问题"></a>解决悬浮阅读的问题</h3><p>实际上，这是一个和发布本身没太多相关性的问题，甚至可以认为，这个功能通过加一个浏览器插件就能解决。</p><p>确实如此，因此通过在生成的 html 中，添加自定义的 js 引用来达到目的。代码比较粗糙，将来有更多更清晰的需求时，再进行统一改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> allowSubs = [<span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-string">&quot;/posts/&quot;</span>, <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-string">&quot;/tags/&quot;</span>]<br><span class="hljs-keyword">let</span> matchpath = <span class="hljs-built_in">window</span>.location.pathname.match(<span class="hljs-regexp">/\/.*\//</span>) || []<br><span class="hljs-keyword">let</span> firstPath = matchpath[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">let</span> shouldOpen = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 在允许的路径中</span><br><span class="hljs-keyword">if</span> (allowSubs.includes(firstPath) &amp;&amp; self == top) &#123;<br><span class="hljs-keyword">let</span> longiframeStyle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;style&quot;</span>)<br>longiframeStyle.innerText = <span class="hljs-string">`.long-frame&#123;width:500px;height:600px;border:none;position:absolute;z-index:9999;display:block;&#125;.frame-on&#123;display:block&#125;`</span><br><br><span class="hljs-keyword">let</span> longiframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;iframe&quot;</span>)<br><br>longiframe.id = <span class="hljs-string">&quot;longframe&quot;</span><br>longiframe.classList.add(<span class="hljs-string">&quot;long-frame&quot;</span>)<br><br><span class="hljs-keyword">let</span> body = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;body&quot;</span>)[<span class="hljs-number">0</span>]<br><br>body.append(longiframeStyle)<br>body.append(longiframe)<br><br>runscript()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runscript</span>(<span class="hljs-params"></span>) </span>&#123;<br><br><span class="hljs-keyword">let</span> longframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;longframe&quot;</span>); <span class="hljs-comment">// 目前只有一个 iframe</span><br><span class="hljs-built_in">this</span>.document.querySelectorAll(<span class="hljs-string">&quot;main a&quot;</span>).forEach(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> &#123;<br>a.addEventListener(<span class="hljs-string">&quot;mouseover&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> showInIframe(longframe, e))<br>&#125;);<br><br><span class="hljs-built_in">this</span>.document.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>shouldOpen = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> (longframe.src != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>longframe.style.height = <span class="hljs-number">0</span><br>longframe.style.width = <span class="hljs-number">0</span><br>longframe.style.display = <span class="hljs-string">&quot;none&quot;</span><br>&#125;<br>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showInIframe</span>(<span class="hljs-params">iframe, e</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (shouldOpen) &#123; <span class="hljs-comment">// 防止闪动</span><br><span class="hljs-keyword">return</span><br>&#125;<br>shouldOpen = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">let</span> src = e.target.href || <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> (!src) &#123; <span class="hljs-keyword">return</span> &#125;<br><br><span class="hljs-comment">// 得去掉锚点，否则 fluid 主题的 scroll 会有问题</span><br>src = src.split(<span class="hljs-string">&quot;#&quot;</span>)[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">// 外链</span><br><span class="hljs-keyword">if</span> (src.trimStart().startsWith(<span class="hljs-string">&quot;http&quot;</span>)) &#123;<br><span class="hljs-comment">// 同源</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.location.host == src.replace(<span class="hljs-regexp">/^(http|https):\/\//</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">0</span>]) &#123;<br>iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (!shouldOpen) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">let</span> posx = e.pageX; <span class="hljs-keyword">let</span> posy = e.pageY;<br><br>iframe.style.top = posy + <span class="hljs-number">30</span> + <span class="hljs-string">&quot;px&quot;</span>;<br>iframe.style.left = posx + <span class="hljs-number">50</span> + <span class="hljs-string">&quot;px&quot;</span>;<br>iframe.style.width = <span class="hljs-string">&quot;500px&quot;</span><br>iframe.style.height = <span class="hljs-string">&quot;600px&quot;</span><br>iframe.style.display = <span class="hljs-string">&quot;block&quot;</span><br>&#125;<br>iframe.src = src<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在悬浮阅读有一些不方便的地方：</p><ol><li>仅有一个预览框 (无法多个预览)</li><li>预览框的位置和大小太死板</li><li>仅适用于一级结构 (层级内是关闭的)</li><li>内嵌页面的格式不够友好 (header 部分太长)</li><li>无法自定义是否开启或关闭</li></ol><p>之后看情况解决下这些问题。【TODO】</p><h3 id="hexo-与-ob-的目录结构组织问题"><a href="#hexo-与-ob-的目录结构组织问题" class="headerlink" title="hexo 与 ob 的目录结构组织问题"></a>hexo 与 ob 的目录结构组织问题</h3><p>我目前的绝大多数文章，都是 技术相关 的文章，所以在写的时候，都是直接扔到一个统一的 <code>_posts</code> 目录下，因为这也是 hexo 直接的文章管理方式。 </p><p>随着文章范围的扩展，有一些其他类型的文章独立成体系，就不太方便统一扔到一个目录下，比如 <code>生产力建设</code> 下有一系列 ob 的文章。</p><p>从期望来看，一个目录，就对应着一个 <code>分类</code> 。<br>从 ob 和 hexo 的职责来看，ob 负责 <code>知识库管理</code> ，hexo 负责 <code>blog 渲染和发布</code>。</p><p>hexo 需要用到 ob 中的各种文档。 目前我的解决方式是，把原有的 hexo 下的 <code>source</code> 目录，软链到 ob 的根目录下。 这样的问题在于，想发布的文档，只能被拖到另一个目录下。 这是不友好的。</p><p>可以探索另一种方式，所有的文档全部放到 ob 中，把要发布的文章，统一加上一个特定的 meta 信息，要发布之前，用脚本跑一次，把相关文档 软链/复制 到对应的 hexo 目录下，然后再进行渲染和发布操作。</p><p>值得参考的文档：<br><a href="https://my-logseq-publish.vercel.app/#/page/logseq">基于 logseq 的文档</a><br><a href="https://github.com/oleeskild/obsidian-digital-garden">ob中的社区发布方案</a></p><hr><p>归属:</p><ul><li><a href="/longblog/posts/22_07_09_10_26_problems_in_using_ob.html" name="ob的使用问题" >ob的使用问题</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>grpc在k8s中的负载均衡问题</title>
    <link href="/longblog/posts/22_3_23_grpc_balancing_problem_in_k8s.html"/>
    <url>/longblog/posts/22_3_23_grpc_balancing_problem_in_k8s.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为 grpc 是基于 http2 的通信，而 http2 对单个 endpoint 默认仅建立一条 TCP 连接，这就导致在 k8s 中，一个 service 默认仅会有一条 grpc 连接，并且，对于该 grpc 的请求，也都会集中到其中一个 pod 上。</p><p>尽管 k8s 的 service 本身有着 round robin 的负载均衡方式，但那都是建立在 “多次建立连接” 的基础上，对于已经建立连接后，基于 四层网络通信 的 TCP，是无法做到负载均衡的。<br>这个问题在我们当前的服务中也存在，两个服务间通过 service name 进行调用时，则会出现负载不均问题。</p><p>之前一直没有太重视这个问题，主要原因在于 每个服务都会有多个 pod ，那么多个 pod 调用 多个 pod 时，一定程度上进行了负载均衡。但是这种负载均衡很不稳定，比较容易出现连接集中到其中几个 pod 上的情况，因此，需要用其他方式解决。</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>经过阅读 grpc 代码，发现 grpc 本身有提供一定的机制解决负载均衡的问题，只是默认的方式在 k8s 中没有那么友好。<br>这其中涉及到 两个主要概念： resolver、balancer(picker)</p><p>resolver的作用，是解析一个服务地址对应多少 ip 地址，默认的方式是 passthrough，意味着透传服务地址，交由更底层的 transport 去处理。</p><p>还有一些其他的 resolver： ① DNS resolver  ② Manual  resolver ③ unix resolver</p><p>其中，DNS resolver 可以解析 DNS 中所挂载的 backend ips，这对于传统的基于 DNS 做负载均衡的方案比较好用，k8s 中的 statefulset 也可以大致基于这种模式。</p><p>Manual resolver 则是手动设置 backend ips，如果有自己的服务注册与服务发现机制，则用这种方式就比较方便。</p><p>Balancer 的作用，是从 resolver 解析的对应的 ip 地址池 选择特定的连接，其中核心的职能由 picker 承担，grpc 提供了大量的负载均衡策略，并且支持自定义策略，默认是 pick_first，还有一些例如：轮询、加权轮询、grpc远程lb、优先、rls(自适应？)。 甚至，grpc 提供了一些集群负载均衡的策略，例如一致性hash、CDS LB？等。</p><p>从上面分析来看，我们至少有这么两类解决方案：</p><ol><li>通过使用 grpc 本身提供的 resolver 机制 和 balancer 机制，实现基于 k8s 的服务发现机制(通过client-go 进行封装)，则能比较优雅地解决这个问题。</li><li>通过在 client 端实现 conn-pool 的方式，类似于通过多次 dial 的方式创建多个连接，然后自行实现一些 负载均衡的策略，例如 round-robin 或者随机，或者 sticky 的机制等。这个方案实现起来，从当前的技术复杂度上来看是最低的。但有三个问题： ① service 本身一定要更加“随机”，如果是 sticky 类机制，则此方式失效(k8s service默认是轮询机制)。 ② 每个遇到 grpc 负载均衡问题的 client ，都要改动其 client 包，以支持获取 conn 的方式(或者进行多一层封装，github.com/shimingyah/pool 就是采用的这种方式) 。③ 连接是在初始化过程建立的，初始化之后通过扩容形成的新pod很难被加入到连接池中。</li></ol><p>另外，服务网格也有一定的方式解决这个问题，这是代理工具做的优化，例如 envoy 和 nginx 都有针对 grpc 的优化，但这个方案太重(我们目前没有使用服务网格)，暂不考虑。</p><p>从目前来看，我认为第一种方式更优雅，对业务的侵入也更小，仅需要修改 grpc 的 dial options，以及导入一个包即可。 这个包的设计，最好将 服务发现 独立出来，专门用于 k8s 中的服务发现与动态监听。</p><p>值得一提的是，在 go-zero 以及 go-krotas 中，均有解决这个问题的方案，均是通过上述添加 k8s resolver 的方式解决的。如果要自行解决，可以参考。</p><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ol><li>如果要采用 k8s 的 list endpoints 和 watch endpoints 机制，则需要添加特定的 role，绑定相关的权限，否则会 panic。</li><li>在使用 k8s 的 sdk 时，要注意版本对应，否则可能会遇到奇怪的问题，甚至会有 golang 编译版本的问题 (最新甚至要求 1.17)。</li></ol><p>另外可以参考：<br><a href="https://zhuanlan.zhihu.com/p/258326212">Kubernetes中gRPC Load Balance分析和解决</a><br><a href="https://segmentfault.com/a/1190000004492447">负载均衡算法及手段</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>grpc</tag>
      
      <tag>load balance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于基于接口定义的开发流</title>
    <link href="/longblog/posts/22_03_21_develop_flow_based_on_interface_definition.html"/>
    <url>/longblog/posts/22_03_21_develop_flow_based_on_interface_definition.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前做前端开发，需要依赖后端同学的接口文档，涉及到一些老接口的时候，经常出现接口信息疏于维护的情况，然后找这个找那个的，依然很难做到让接口信息完整，当时就在想，为什么不再要修改一个接口的时候，把接口文档顺便维护了呢？心中甚是鄙夷。</p><p>后来做后端开发，经常出现一些要求快速完成进行联调的情况，更甚至有临时改变一些功能的情况，自己可能顺手就加上了，然后上到测试环境让前端同学调一下，然后……就没有然后了，因为运行起来没什么问题，也没有谁让把接口文档补全，就这样搁置了。</p><p>再后来后端开发也要兼顾接口测试，接口测试 的用例梳理，是基于接口定义，一方面找到接口的参数边界，另一方面测试完整的场景，这时候才发现，之前的接口文档写得是多么简陋。<br>于是，就开始探索更好的后端接口开发工作流。</p><h2 id="灵感来源及畅想"><a href="#灵感来源及畅想" class="headerlink" title="灵感来源及畅想"></a>灵感来源及畅想</h2><h3 id="灵感1"><a href="#灵感1" class="headerlink" title="灵感1"></a>灵感1</h3><p>接口文档的维护大体上分为两派，① 接口文档应当跟随代码，例如 swagger  ② 接口文档管理在专门的接口平台，例如 yapi。 这两派都有其拥护者。目前看到的，市场上很多企业还是走的第 ② 条路，主要原因，可能还是对后端人员来说上手简单，有好用的 UI，写接口就点点点几下；再加上给前端同学交付比较方便(仍一个链接过去)，带有 mock 功能，可能还有一些简单的 接口测试 功能，用起来很流畅。 用这种方式的一个弊端，可能就是 <code>容易疏于维护</code>。</p><p>基于代码的方案基本就是 swagger 的方式，在定义接口时，用 <code>注释</code> 或者 <code>装饰器</code> 等方式，将接口的元信息嵌入到代码中，这样就可以做到修改代码的时候，就可以顺便修改接口信息。 但这样的弊端就是： ① 部署不方便，yapi 可以独立部署，很稳定，基于代码的则可能随意改变，对使用方而言不够稳定。 ② mock 、test 等功能较弱，有些时候需要提供 这些功能时比较容易被要求更换。</p><h3 id="灵感2"><a href="#灵感2" class="headerlink" title="灵感2"></a>灵感2</h3><p>之前系统还不是很复杂时，主要对外提供 http 接口，后来，服务越来越多，服务间的通信则主要使用 rpc 方式，我们选择的 grpc 框架，该框架在创建接口时的方式，是基于 proto3 定义的接口，使用 protoc 直接生成对应的代码，将接口定义变成真正的 <code>接口</code>，然后由开发者自行实现该接口，达到提供真正的接口功能的目的。</p><p>我在想，http 和 rpc，都是远程通信的方式，从目的上看，本就没什么区别。看起来，只是 rpc 是基于自定义的 <code>数据格式</code> 及 <code>序列化方式</code>，而 http 整体看是个<code>通用的文本协议</code>。那么，是不是可以把 grpc 中的一些优点，应用到 http 的请求中来，甚至应用到 ws 等长链接协议中？</p><p>后来，看到 go-zero 这个项目中，脚手架工具的 go-ctl 就已经包含了这项功能，基于一个自定义的接口定义文档，生成一定模板下的基本代码。觉得十分好用。</p><h3 id="更多探索"><a href="#更多探索" class="headerlink" title="更多探索"></a>更多探索</h3><p>在探索的过程中，观摩了几个 web 开发框架，可以算得上是典型了：</p><ul><li> <a href="https://goframe.org/pages/viewpage.action?pageId=1114399">goframe</a></li><li> <a href="https://go-zero.dev/cn/">go-zero</a></li><li> <a href="https://go-kratos.dev/docs/">go-kratos</a></li></ul><p>他们分别有自己的开发工具体系。</p><p><code>goframe</code> 是采用 <code>将接口信息写在代码中</code> 的方式，通过解析 request 和 response 中的 meta，以及在注册路由时添加的一些额外信息，生成 openapi 格式的 json 文档，实际上，这也是生成 swagger 所需要的信息，然后直接在框架中继承了 swagger。 对于开发者而言，仅需要关注代码即可，在代码中通过 <code>tag</code> 或者 显式描述 的方式，即可保证接口文档与接口实现一致，改动成本较小，学习成本较低。</p><p><code>go-zero</code> 是自己实现了一套 接口定义 的语法，整体类似于 golang 和 proto3 的结合体，词法语法的解析均是自己实现的，这也就意味着，go-zero 可以完全掌控 接口定义文档 到代码的生成过程，因此，其脚手架工具 <code>go-ctl</code> 提供了 api 和 rpc 两种接口代码自动生成的方式，开发者仅需要写 接口定义文档 即可生成基本代码，然后自己补充业务逻辑即可。另外，生成的基本代码是根据 模板 确定的，这也就在一定程度上支持了自定义生成代码的功能，值得更多探索。另外，生态中也有将 接口定义 和 swagger 格式对接 的工具了，可以生成 swagger 文档。</p><p><code>go-kratos</code> 采用的是 grpc 的一套方案，grpc 的 语法解析 是 C++ 实现的，然后生成一套自定义 ast 的 <code>FileDescriptor</code> 结构体，这个结构体通过编码成二进制传递给其他程序；grpc 的代码生成是由各类 plugin 实现的，例如我们常用的 golang 的代码，则是由 <code>protoc-gen-go</code> 这个插件生成的(实际上有好几个常见的实现)。那么，也就意味着，只需要再实现一个将 proto3 的接口定义 转成一套 http 的代码的 plugin，也就可以实现和 grpc 一样的代码生成能力。 这也就是 go-kratos 采用的方案，插件的名字叫 <code>protoc-gen-go-http</code> 。 和 go-zero 类似，go-kratos 也提供了生成 swagger 的<a href="https://github.com/go-kratos/swagger-api">工具</a>。</p><p>基于接口定义，我们可以做很多事情，例如： ① 基本代码自动生成(server、client) ② 接口文档自动生成 ③ 基本接口测试代码自动生成 ④ 协议转换 ⑤ mock 。有了这些自动化手段，做开发时就可以很纯粹地关心业务逻辑即可，这对于降低开发的复杂度而言，有着巨大的价值。</p><h2 id="如何行动起来"><a href="#如何行动起来" class="headerlink" title="如何行动起来"></a>如何行动起来</h2><p>探索这些的原因，在于我们当前的 ws 通信，接口层是自定义的 <code>消息码</code>，前后端都需要维护一套必须一样的枚举值，并且前后端都要对每个消息码写一套大致相同的代码，十分繁琐。于是就想到，如果采用了和 grpc 一样的自动生成 服务端 和 客户端 代码的方式，那么 接口管理复杂度、代码复杂度、代码规范、健壮性、可调试性 等各方面都将得到很大的提升。</p><p>一切想法，要想产生真实的价值，就必须得要落地，而落地的方法，可以以实践为目标进行梳理，当有一定思路时，就赶紧行动起来。</p><p>目前，我可以先： ① 阅读 protobuff 的代码生产方式(c++写的，几乎完全没读懂)  ② 阅读 go-ctl 的代码生成方式 (自实现的 ast 解析，代码比较规范，读懂大概)  ③ 阅读 goframe 的接口文档生成方式 (自定义的结构以及转换，比较易懂)</p><p>然后： ④ 分析不同类型接口的差异 ⑤ 梳理 ws 生成的代码应该有些什么部分  ⑥ 以 ws 为例，开发一版基本代码</p><p>另外，补充一些其他维度的TODO：</p><ol><li>重新学习一遍编译原理，弄清楚 词法解析 和 语法解析，以及将自定义语法变成 elf 格式的过程。</li><li>学习使用 正则 和 有限状态机 的方式进行词法、语法解析。</li><li>对 go-frame、go-zero、go-kratos、gin、go-kit 这几个框架进行更深层次的对比，从他们提供的功能 以及 功能的实现方式 等方面进行对比。</li><li>从开发效率的角度，探索各类工具对效率的提升程度，包括维护成本在内。可以先看看：<ul><li> <a href="https://github.com/flipped-aurora/gin-vue-admin">gin-vue-admin</a></li><li> <a href="https://juejin.cn/post/7034813841833721893">6 个 golang 在线工具</a></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>openapi</tag>
      
      <tag>grpc</tag>
      
      <tag>go-kratos</tag>
      
      <tag>develop</tag>
      
      <tag>go-zero</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次k3s环境搭建记录</title>
    <link href="/longblog/posts/21_12_26_a_record_of_k3s_run_up.html"/>
    <url>/longblog/posts/21_12_26_a_record_of_k3s_run_up.html</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>生产环境中，我们很早在使用 k8s 作为基础设施了，后来，企业项目要做私有化部署，就把目光转向 <code>k3s</code> 了。<br>k3s 是一个轻量级的 k8s，几乎实现了所有 k8s 的特性，除了一些边缘的场景，基本可以把 k3s 当做 k8s 去使用。</p><h3 id="一些备选方案"><a href="#一些备选方案" class="headerlink" title="一些备选方案"></a>一些备选方案</h3><p>早期部署 k8s 环境是十分繁杂的，各个组件都是二进制方式部署，如果遇到问题，排查起来需要的预备知识非常多，因此，大部分企业在使用 k8s 时，都是直接选择云服务商提供的 k8s 集群，阿里云、腾讯云、亚马逊等等都提供了非常完善的 k8s 集群。<br>那作为个人想要玩一玩 k8s ，我们可以怎么搞呢？ 其实社区已经出了非常多的用于简化 k8s 环境搭建的项目，下面列举一些：</p><ol><li>使用 ansible 等工具简化搭建，例如 <a href="https://github.com/kubernetes-sigs/kubespray">kubespray</a>、<a href="https://github.com/easzlab/kubeasz">kubeasz</a>、<a href="https://github.com/kubernetes/kops">Kops</a>、<a href="https://github.com/kubernetes/kubeadm">kubeadm</a></li><li><a href="https://github.com/kubernetes/minikube">minikube</a>、<a href="https://github.com/kubernetes-sigs/kind">kind</a>、<a href="https://github.com/ubuntu/microk8s">microk8s</a>、<a href="https://github.com/k3s-io/k3s">k3s</a> 等轻量级 k8s 实现。</li><li><a href="https://github.com/ubuntu/microk8s">rancher</a>、<a href="https://github.com/KubeOperator/KubeOperator">kubeoperator</a> 这类可视化操作方式</li><li>如果你只是想在自己电脑上玩一下，可以直接使用 docker 客户端提供的 k8s 集群，或者用 <a href="https://github.com/rancher/k3d">k3d</a> (k3s in docker) 、<a href="https://github.com/kubernetes/minikube">minikube</a>、<a href="https://github.com/kubernetes-sigs/kind">kind</a></li></ol><p>值得一提的是， k3s 和 microk8s 是为生成环境设计的 k8s 实现，是为了在资源有限的情况下使用 k8s 集群的一种方案，例如 边缘计算、iot 等场景。(可以搜索和 kubeedge 等结合的内容)</p><h3 id="搭建操作"><a href="#搭建操作" class="headerlink" title="搭建操作"></a>搭建操作</h3><p>因为更加看好 k3s 的生态，因此选用 k3s 作为基础设施。在 k3s 的搭建上，使用官方的搭建脚本已经比较简单了，不过还是有一些为了更加简化搭建过程而出现的项目，例如 <a href="https://github.com/alexellis/k3sup">k3sup</a> 、 <a href="https://github.com/cnrancher/autok3s">autok3s</a> 这两者都提供了远程安装 k3s 的能力，不过后者还有图形化界面。 从搭建难度上，这两者对我而言没啥差别，因此我直接选择了 k3sup。</p><ol><li>在本地下载 k3sup </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sLS https://get.k3sup.dev | sh<br></code></pre></td></tr></table></figure><ol start="2"><li><p>在阿里云上开两台机器，并配置公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id root@xxx.xx.xx.xx<br></code></pre></td></tr></table></figure></li><li><p>在机器 1 上部署 master 节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">k3sup install --user root --ip xx.xx.xx.xx --k3s-version v1.21.1+k3s1  --k3s-extra-args &#x27;--no-deploy traefik --docker&#x27; --tls-san &quot;xx.xx.xx.xx&quot; --context k3s --merge<br></code></pre></td></tr></table></figure></li><li><p>在机器 2 上部署 slave 节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">k3sup join --user root --ip xx.xx.xx.xx --k3s-version v1.19.7+k3s1 --server-ip xx.xx.xx.xx<br></code></pre></td></tr></table></figure></li><li><p>查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longk3s001 ~]# kubectl  get node<br>NAME         STATUS   ROLES    AGE    VERSION<br>longk3s001   Ready    master   129m   v1.19.7+k3s1<br>longk3s002   Ready    &lt;none&gt;   112m   v1.19.7+k3s1<br></code></pre></td></tr></table></figure></li></ol><p>以上，基本的 k3s 环境就搭建完成成功了</p><p>可以设置几个常用的 kubectl 别名，方便使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;eof &gt;&gt; ~/.bashrc<br>alias k=kubectl<br>alias ke=&quot;kubectl edit&quot;<br>alias ked=&quot;kubectl edit deploy&quot;<br>alias kg=&quot;kubectl get&quot;<br>alias kgp=&quot;kubectl get po&quot;<br>alias wp=&quot;watch kubectl get po&quot;<br>alias kd=&quot;kubectl delete&quot;<br>alias kdp=&quot;kubectl delete pod&quot;<br>alias klf=&quot;kubectl logs -f&quot;<br>alias krrd=&quot;kubectl rollout restart deploy &quot;<br>eof<br>bash<br><br></code></pre></td></tr></table></figure><h3 id="解决远程访问问题"><a href="#解决远程访问问题" class="headerlink" title="解决远程访问问题"></a>解决远程访问问题</h3><p>在集群外访问集群内的通用方案，基本可以分为： </p><ol><li>loadBalancer</li><li>nodePort</li><li>ingress</li><li>hostNetwork</li></ol><p>一般来说，云厂商提供的 k8s 集群，都是采用 loadBalancer 的方式，云厂商会自动提供公网 ip (当然也可以是内网 ip)。 而对于自建的 k8s 集群，则没有现成的 lb，要么使用其他方式，要么，自建 lb。</p><ol><li>自建 lb 可以采用 <a href="https://github.com/metallb/metallb">metalLB</a>， 另外，k3s 官方也提供了一个 lb 实现 <a href="https://github.com/k3s-io/klipper-lb">klipper-lb</a></li><li>使用 nodePort 是一个比较简便的方式，直接改 service 类型即可。但问题是要记各个服务的 nodePort 是多少，比较麻烦，服务多了之后，根本不记得哪个 port 对应哪个服务。</li><li>使用 ingress 是一个很不错的方式，相当于在所有服务前加了一个反向代理服务器，比如 nginx。ingress 的使用能比较好地解决端口复用问题，可以根据 二级域名、访问路径、header 等各种标识对流量进行分发，基本上可以认为，对于企业级项目，用 ingress 就对了。不过，ingress 的相关配置是一个需要学习的内容，尤其是关于 ssl 证书，之后专门出一篇文章记录一下。</li><li>使用 hostNetwork 相当于直接使用宿主机的网络，也就是说，一个服务若开了 8080 端口，则会直接在宿主机上监听 8080 端口。一般来说，hostNetwork 适用于一个集群仅服务于一个主服务的项目。但有一种很好的方式，可以解决 没有 lb 的问题，那就是 使用 ingress 作为流量分发，同时对 ingress 使用 hostNetwork，并且，对于 ingress 使用 daemonset 进行部署，这样就类似于将 ingress 作为 lb 来使用了。</li></ol><p>我直接采用 4 中的方案。相关的信息可以参考 <a href="https://github.com/kubernetes/ingress-nginx/blob/nginx-0.29.0/docs/deploy/baremetal.md">ingress-nginx</a></p><p>记录一下基本过程：</p><ol><li><p>进入到 nginx-ingress 的<a href="https://github.com/kubernetes/ingress-nginx/blob/nginx-0.29.0/docs/deploy/index.md">文档中</a></p></li><li><p>获取清单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.29.0/deploy/static/mandatory.yaml<br></code></pre></td></tr></table></figure></li><li><p>修改 deployment 资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 修改 Deployment 为 DaemonSet</span><br><span class="hljs-meta">#</span><span class="bash"> 2. 去掉 spec.replicas</span><br><span class="hljs-meta">#</span><span class="bash"> 3. spec.template.spec 增加  hostNetwork: <span class="hljs-literal">true</span></span><br></code></pre></td></tr></table></figure></li><li><p>启用配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f mandatory.yaml<br></code></pre></td></tr></table></figure></li></ol><p>这之后就按照自己的需要，部署自己的服务即可。</p><h3 id="解决存储问题"><a href="#解决存储问题" class="headerlink" title="解决存储问题"></a>解决存储问题</h3><p><a href="/longblog/posts/22_07_24_14_09_how_to_handle_storage_in_k3s.html" name="解决k3s的存储问题" >解决k3s的存储问题</a></p><ul><li>使用默认的 本地存储 (local-path)。<ul><li><a href="/longblog/posts/22_11_11_20_48_k8s_nfs_storage_class.html" name="nfs、localpath作为k8s-storage-class" >nfs、localpath作为k8s-storage-class</a></li></ul></li><li>使用 nfs 或其他远程存储方案，具体可以参见：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">nfs-provisioner</a><ul><li><a href="/longblog/posts/22_11_11_20_48_k8s_nfs_storage_class.html" name="nfs、localpath作为k8s-storage-class" >nfs、localpath作为k8s-storage-class</a></li></ul></li><li>使用类似于 Longhorn 的分布式存储方案 (k3s 推荐方式)，具体可以参见：<a href="https://rancher.com/docs/k3s/latest/en/storage/">k3s storage</a></li></ul><h3 id="解决日志问题"><a href="#解决日志问题" class="headerlink" title="解决日志问题"></a>解决日志问题</h3><p>默认的日志是分布在各个节点上的，当节点被删除时，日志也就丢了，日志可以使用 fluentd 进行采集(或者 fluent-bit)，具体可以参见： <a href="https://docs.fluentd.org/">fluentd 官方文档</a></p><p>解决日志解析和查询问题 (重量和轻量)</p><ul><li><a href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html" name="简单的集群日志采集方案" >简单的集群日志采集方案</a></li></ul><h3 id="解决证书问题"><a href="#解决证书问题" class="headerlink" title="解决证书问题"></a>解决证书问题</h3><ol><li>解决集群内证书时长问题，虽然每年重启一次 k3s 即可自动更新证书，但一个稳定的服务扔在那里，谁记得啥时候要重启啊，可以通过改代码重新编译，变成100年就ok了。</li><li>解决 ssl 证书问题，可以参考 <a href="https://cert-manager.io/docs/">cert-manager</a></li></ol><h3 id="解决面板及管理工具"><a href="#解决面板及管理工具" class="headerlink" title="解决面板及管理工具"></a>解决面板及管理工具</h3><p>k8s 生态下已经有大量的面板，最基础的是官方的 dashboard，周边的还有：</p><ul><li>kubeboard</li><li>kubepi</li><li>kubesphere</li><li>rancher</li></ul><p>面板工具来看，整体差别不大，交互上有少量差别，日常使用完全够了，如果有多集群管理需求的话，个人使用不建议 kubeboard(超过3个收费) ，毕竟穷人不配(-.-!)。 kubesphere 和 kubeboard 的周边插件功能还是不错的，可以方便地集成一些常用的组件，并且提供了控制面板。</p><p>客户端还有 lens， 命令行还有 k9s ，都是非常不错的工具。尤其是 <code>k9s</code> ，熟悉了快捷键后，十分方便。</p><h3 id="解决-CD-问题"><a href="#解决-CD-问题" class="headerlink" title="解决 CD 问题"></a>解决 CD 问题</h3><p>对于 k8s 的自动发布，最基础的方式自然是在原有的 CD 脚本中，写一些 kubectl 的命令。但这样不够优雅，主要是将来维护比较麻烦，对于不够熟练 kubectl 的同学而言，有一定学习成本。</p><p>如果要采用更加成熟的方案，可以考虑 jenkins (x) ，社区也有很多针对 k8s 的脚本。 也可以采用 argoCD ，和 k8s 的生态结合得比较紧密。 droneCI 也是一个不错的选择。</p><p>还有一些备选方案： skaffold、devspace 等，这些是可以在本地打包，然后部署到 k8s 的方式。</p><p>如果，企业级使用的话，spinnaker 是一个非常不错选择。</p><p>[TODO] 补一些 CD 相关的文档</p><h3 id="解决监控问题"><a href="#解决监控问题" class="headerlink" title="解决监控问题"></a>解决监控问题</h3><p>机器的监控，比较轻量的方式可以使用 netdata。另外可以用 datadog，生态应该也是很不错的，不过我没怎么做更多的探索。<br>grafana + promethues 是一个更加通用的方案，社区也提供了大量的面板模板，不论是 node exporter 还是 pod exporter，都有比较成熟的面板。推荐使用。 </p><h3 id="解决开发调试问题"><a href="#解决开发调试问题" class="headerlink" title="解决开发调试问题"></a>解决开发调试问题</h3><p>两个不错的方案：<br><a href="https://devspace.sh/cli/docs/introduction">devspace</a><br><a href="https://nocalhost.dev/docs/quick-start/">nocalhost</a></p><h3 id="其他可能的问题"><a href="#其他可能的问题" class="headerlink" title="其他可能的问题"></a>其他可能的问题</h3><ul><li>服务可视化 (tracing、metrics)</li><li>日志体系</li><li>告警体系</li><li>均衡问题 可以参考 <a href="https://github.com/kubernetes-sigs/descheduler">descheduler</a></li></ul><p>TODO:</p><ol><li>增加 k8s ssl相关配置操作记录</li><li>增加 k8s 日志、监控、追踪、告警 相关操作记录</li><li>增加对一个服务的相关操作</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>enviroment</tag>
      
      <tag>k3s</tag>
      
      <tag>develop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何解决linux下的代理访问</title>
    <link href="/longblog/posts/21_12_12_how_to_resolve_proxy_in_linux.html"/>
    <url>/longblog/posts/21_12_12_how_to_resolve_proxy_in_linux.html</url>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>想在 linux 上安装 helm，结果网速巨慢，于是想给服务器配个代理</p><h3 id="代理安装"><a href="#代理安装" class="headerlink" title="代理安装"></a>代理安装</h3><ol><li><p>配置pip源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /root/.pip/pip.conf &lt;&lt; eof<br>[global]<br>trusted-host =  pypi.douban.com<br>index-url = http://pypi.douban.com/simple<br>eof<br></code></pre></td></tr></table></figure></li><li><p>pip升个级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install python3 -y &amp;&amp; pip3 install --upgrade pip<br></code></pre></td></tr></table></figure></li><li><p>安装ss</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install shadowsocks<br></code></pre></td></tr></table></figure></li><li><p>创建ss-local配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/ss<br>cat &gt; /etc/ss/ss.json &lt;&lt; eof<br>&#123;<br>    &quot;server&quot;:&quot;ss 服务端 ip&quot;,<br>    &quot;server_port&quot;:&quot;ss 服务端端口&quot;,<br>    &quot;local_address&quot;: &quot;127.0.0.1&quot;,<br>    &quot;local_port&quot;:1080,<br>    &quot;password&quot;:&quot;ss 服务端密码&quot;,<br>    &quot;timeout&quot;:300,<br>    &quot;method&quot;:&quot;aes-256-cfb&quot;,<br>    &quot;fast_open&quot;: false,<br>    &quot;workers&quot;: 1<br>&#125;<br>eof<br></code></pre></td></tr></table></figure></li><li><p>创建ss service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /etc/systemd/system/ss.service &lt;&lt; eof<br>[Unit]<br>Description=ss<br>[Service]<br>TimeoutStartSec=0<br>Restart=always<br>RestartSec=30<br>ExecStart=/usr/local/bin/sslocal -c /etc/ss/ss.json start<br>ExecStop=/usr/bin/killall sslocal<br>[Install]<br>WantedBy=multi-user.target<br>eof<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 如果没有 killall ，则执行</span><br>yum install psmisc -y<br></code></pre></td></tr></table></figure></li><li><p>自启动ss service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable ss.service<br>systemctl start ss.service<br>systemctl status ss<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 到此为止，已经可以使用 ss 代理了，验证一下</span><br>curl --socks5 127.0.0.1:1080 http://httpbin.org/ip<br></code></pre></td></tr></table></figure></li><li><p>安装privoxy (为了使用 http 代理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install privoxy -y<br></code></pre></td></tr></table></figure></li><li><p>增加 privoxy 的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 增加一条转发规则</span><br>echo &#x27;forward-socks5t   /               127.0.0.1:1080 .&#x27; &gt;&gt; /etc/privoxy/config<br><span class="hljs-meta">#</span><span class="bash"> 默认配置已经打开 listen-address  127.0.0.1:8118 (http代理端口)</span><br></code></pre></td></tr></table></figure></li><li><p>启动 privoxy 代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable privoxy<br>systemctl restart privoxy<br>systemctl status privoxy<br></code></pre></td></tr></table></figure></li><li><p>安装 proxychains-ng (为了支持单个进程的代理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y git<br>export http_proxy=http://127.0.0.1:8118; export https_proxy=https://127.0.0.1:8118; # 解决 git 慢的问题<br>git clone --depth=1 https://github.com/rofl0r/proxychains-ng<br>yum install gcc -y<br>cd proxychains-ng<br>./configure --prefix=/usr --sysconfdir=/etc<br>make &amp;&amp; make install &amp;&amp; make install-config<br></code></pre></td></tr></table></figure></li><li><p>修改 proxychains 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/proxychains.conf<br><span class="hljs-meta">#</span><span class="bash"> 把最后一行的 socks4  127.0.0.1 9050 改成 socks5 127.0.0.1 1080</span><br></code></pre></td></tr></table></figure></li><li><p>起个别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/bin/proxychains4 /usr/bin/proxy<br></code></pre></td></tr></table></figure></li><li><p>测试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxy curl www.google.com<br></code></pre></td></tr></table></figure></li></ol><p>自此以后，如果没法访问一些资源，则使用：<br>proxy + 要执行的命令</p><p>如果想在整个终端中使用 http 代理，则： (这是 privoxy 带来的)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export http_proxy=127.0.0.1:8118<br>export https_proxy=127.0.0.1:8118<br></code></pre></td></tr></table></figure><p>以下，终于可以不受限制地安装helm了。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">helm安装</span><br>wget https://get.helm.sh/helm-v3.2.4-linux-amd64.tar.gz <br><br>tar -zxvf helm-v3.2.4-linux-amd64.tar.gz<br><br>mv linux-amd64/helm /usr/local/bin/helm<br></code></pre></td></tr></table></figure><p>相关的程序也可以看下： polipo</p><h3 id="其他-ss-问题"><a href="#其他-ss-问题" class="headerlink" title="其他 ss 问题"></a>其他 ss 问题</h3><ol><li><p>如果希望使用多级 ss (一台机器 作为 另一台机器的 中转 ss)</p><ul><li>能够使用 ssh， 则参照 <a href="/longblog/posts/21_12_11_reverse_proxy_compares.html" name="反穿技术哪家强" >反穿技术哪家强</a></li><li>能够使用 ss-tunnel，则 ① 中转机启动 ss-local (假设本地代理端口为 50000) ② 中转机启动 ss-server ③ 使用 <code>ss-tunnel -l 1080 -b 127.0.0.1 -L 127.0.0.1:50000</code> (监听本地 1080)。这种方案 和 ssh 的方案本质一样，都是转发本地端口到远端端口。</li><li>仅能使用 ss-local，则 ① 中转机启动 ss-local, 用于连接到上位ss  ② 中转机启动 ss-server, 用于承接 PC 上的连接  ③ 使用 proxy ssserver </li><li>如果中转机上使用的 ss-local , 那么任何能提供 <code>认证</code> 能力的 tunnel，都能满足需求，比如 <a href="https://github.com/ginuerzh/gost">gost</a>、<a href="https://github.com/ehang-io/nps">nps</a>、<a href="https://github.com/Dreamacro/clash">clash</a></li><li>最简单的方式，是直接用 iptables 转发即可，直接使用 <code>iptables -t nat -A PREROUTING -4 -p tcp --dport 50000 -j DNAT --to-destination xxx.xxx.xxx.xx:50001</code> 即可 (本地 50000 转发到 上位 ss 的 50001)<br>ps: 使用 iptables 有两个坑要注意下，① 要配置 内核参数允许转发 <code>net.ipv4.ip_forward = 1</code>  ② 要设置出网 ip 替换 <code>iptables -t nat -A POSTROUTING -4 -p tcp --dport 50001 -j MASQUERADE</code>，否则回包的地址就错了<blockquote><p>注意，server 端要配置 /etc/ssh/sshd_config 的 GatewayPorts yes，允许包的转发 </p></blockquote></li></ul></li><li><p>如果想用 ss 作为全局代理，可以使用 <code>redsocks + iptables</code> 的方案。</p></li><li><p>ssh 其实非常强大, 我们完全可以不用 ss-server 作为代理，直接使用 <code>ssh -D 1080 user@host</code>, 就能做到同样的事情。</p></li><li><p>调试网络的过程中，有几个很好用的工具</p><ul><li><code>ss</code> 查看 socket 相关信息，和 netstat 有重合的部分</li><li><code>netstat</code> 查看 socket 相关信息、路由信息</li><li><code>ip</code> 查看或修改 路由、网卡</li><li><code>ifconfig</code> 网卡信息查看及配置</li><li><code>tcpdump</code> tcp 抓包工具 <a href="/longblog/posts/22_07_18_17_46_some_records_of_tcpdump_for_grab_net_packages.html" name="tcpdump" >tcpdump</a></li><li><code>telnet</code> 远程登录</li><li><code>nc</code> socket 转发 <a href="/longblog/posts/23_01_10_14_05_some_normal_linux_cmds.html#nc" name="一些常用的linux命令记录" >一些常用的linux命令记录</a></li><li><code>iptables</code> iptables 管理工具</li><li><code>ipvsadm</code> ipvs 管理工具</li><li><code>dig</code> / <code>nslookup</code> dns 查询</li><li><code>curl</code> 支持多种应用层协议的工具</li></ul></li><li><p>希望 ss 有认证、流量计费能力，可以结合 RADIUS ，具体可以参考: <a href="http://ss5.sourceforge.net/configuration.htm">http://ss5.sourceforge.net/configuration.htm</a></p></li><li><p>  ssserver 在使用 vpn 的场景下会有一个问题 =&gt; 连接到 ssserver 的 client 无法访问 vpn 后面的服务。这预计是由于 ssserver 收到包之后，直接从网关转出去了，而没有重新走 routes (具体原因待探究)。 在测试这个问题时，发现使用 clash 在同样场景下是可以访问 vpn 后面的服务的。 clash 是一个更丰富、更强大的代理工具，可以认为是 代理 + 代理的代理，并且配备了 DNS-server，这在一些有特殊 DNS resolve 需求的场景下就非常好用了。</p></li><li><p>clash 是一个聚合型的代理客户端，可以参考 <a href="https://lancellc.gitbook.io/clash">clash 非官方wiki</a> ，桌面端可以搜索 clashx，web ui 可以查看 <a href="https://github.com/haishanh/yacd">yacd</a> ，clash 也同样可以作为 http / sock5 代理节点。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>proxy</tag>
      
      <tag>helm</tag>
      
      <tag>ssh</tag>
      
      <tag>proxychains</tag>
      
      <tag>radius</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反穿技术哪家强</title>
    <link href="/longblog/posts/21_12_11_reverse_proxy_compares.html"/>
    <url>/longblog/posts/21_12_11_reverse_proxy_compares.html</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有时候，因为种种原因，我们希望我们的机器能被其他一些原本访问不到我们的设备访问。<br>比如:</p><ol><li>做微信开发调试的时候，需要配置回调地址，也就是我们能访问微信的服务器，但微信的服务器需要访问我们时缺不行。</li><li>我们想要分享一些资料、文件、服务给不在同一个局域网的人。</li></ol><p>这些情况下，我们需要的技术方案，被称为 <code>内网穿透</code>。</p><h3 id="反穿可选方案"><a href="#反穿可选方案" class="headerlink" title="反穿可选方案"></a>反穿可选方案</h3><p>社区中，有很多这类工具。</p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>最简单的就是 ssh 的方案，只要开启了sshd，本地有ssh就能够实现，既然都在玩服务器了，又有几个没有 ssh 的呢。<br>使用起来非常简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -R 和 -L 的差别只是翻转了，本身实现的效果是一样的</span><br>ssh -R 0.0.0.0:8081:0.0.0.0:8081 root@xx.xx.xx.xx<br></code></pre></td></tr></table></figure><blockquote><p>ps: 如果你发现远端监听的是 127.0.0.1:8081 的话，是由于 sshd 的一个安全配置，vim /etc/ssh/sshd_config  , 修改 GatewayPorts: yes  然后 systemctl restart sshd</p></blockquote><p>上面这样，就把服务器的 8081 端口 代理到了本地的 8081。这个方案最大的优点就是 <code>简单</code> ，在调试时使用十分轻便。<br>问题有两个： 1. 不够稳定，容易断掉。 2. 只支持端口映射，更复杂的功能不好实现。</p><p>另外，ssh 其实是可以直接实现 socks 代理的，这样的目的在于，仅使用一个端口，就能实现对所有端口的访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -f 为后台运行 -N 为不运行任何命令 -D 为动态代理  -q 为 quiet 模式</span><br>ssh  -qfND 0.0.0.0:1080 root@xxx.xx.xx.xx<br></code></pre></td></tr></table></figure><h4 id="autossh"><a href="#autossh" class="headerlink" title="autossh"></a>autossh</h4><p>对于ssh方案而言，最难搞的问题还是 <code>不稳定</code>，于是可以用 <a href="https://linux.die.net/man/1/autossh">autossh</a> 的方案解决。使用起来和 ssh 类似，不过多了一个监听端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">autossh -M 8082 -fNR 0.0.0.0:8081:0.0.0.0:8081 root@xx.xx.xx.xx<br></code></pre></td></tr></table></figure><p>这个方案最大的优势就是 解决了 ssh 断线重连的问题。因此，在开发调试时更加好用，而且 <code>-f</code> 参数支持了后台运行，比较优雅地解决了需要维持终端持续打开的问题。</p><p>基本上，在有一些临时性的穿透需求时，这个方案已经十分够用了。对于复杂功能的需求实际上不是这个工具要解决的问题，例如 udp、http、端口复用 等等。</p><h4 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h4><p>上面说的两种方案，主要是临时使用比较方便，但在功能的丰富度上还是十分不足的，毕竟 ssh 的主业是做加密登录的，端口映射只是副业。 而 frp 是则专门做内网穿透的。<br>如果希望提供比较稳定的内网穿透服务，那么选择 frp 就是比较好的选择了。</p><p>frp 分为 服务端 和 客户端，需要两端部署。通过 <code>.ini</code> 配置文件进行管理。支持 tcp、udp、http、ssl-tcp、ssl-udp、p2p 的配置，还对 http 代理做了一些优化(类似于 nginx 的一些功能)。</p><p>关于frp，官方文档介绍的肯定比我详细，可以参考 <a href="https://gofrp.org/docs/">frp文档</a></p><h4 id="nps"><a href="#nps" class="headerlink" title="nps"></a>nps</h4><p>nps 和 frp 是同样定位的应用，两者在功能上也几乎一致，不过值得一提的是，nps自带官方的可视化管理页面，这点比frp在易用性上增加了不少(当然frp也有几个简单的社区版可视化工具)。</p><p>同样，详细可以参考 <a href="https://ehang-io.github.io/nps/">nps文档</a></p><p>实际上，类似的工具还挺多，在 github 上还扒到另一个项目： <a href="https://github.com/mmatczuk/go-http-tunnel">https://github.com/mmatczuk/go-http-tunnel</a> , 再比如和 nps 类似的 <a href="https://github.com/inconshreveable/ngrok">ngrok</a> (ps: 这个项目1.0是开源的，2.0搞成商业项目了，然后1.0就不开发了，有nps代替基本可以不用关注这个项目了)</p><p>nps 除了可以做 <code>端口映射</code>，还能做 <code>反向代理</code> 、<code>正向代理</code> 、<code>加密代理</code> </p><h3 id="一些其他的想法"><a href="#一些其他的想法" class="headerlink" title="一些其他的想法"></a>一些其他的想法</h3><p>上面说的 内网穿透，是解决网络通路的其中一种场景，除了上面这些方案，还有一些其他的方向，举些栗子：</p><h4 id="NAT映射"><a href="#NAT映射" class="headerlink" title="NAT映射"></a>NAT映射</h4><p>这种解决网络通路的方案，通常用在 <code>网关</code> 处，可以根据 网卡、ip、端口 做响应的转发。可以用 iptables 写 snat 和 dnat 规则。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理最常见的就是充当 <code>应用网关</code>，通过对 协议、域名、路径、header 等等做匹配，转发到内网中的不同服务上去。对于提供网络应用的软件来说，这种方式几乎是必然的。</p><p>传统应用中，最广泛的反向代理服务器就是 <code>nginx</code>。在云原生逐渐成长起来之后，ambassador、envoy、kong、candy 等应用网关也顺势起飞了。 </p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>对大众而言，最常接触到的解决网络通路的场景，还是 <code>代理</code>，为了和反向代理区分，我们不妨叫它 <code>正向代理</code>。</p><p>使用正向代理的场景很明确： 当我们的机器 A 无法访问机器 C，但是另一台机器 B 能访问机器 C，同时我们的机器 A 能访问机器 B，那么，机器 A 就可以让机器 B 代理 A 的请求，访问机器 C。</p><p>大众最常见的例子是，在国内，想要用手机看油管的视频，就需要安装代理软件。这个场景中，手机就是 机器A，油管的服务器就是机器 C，代理软件连接的服务端就是机器 B。</p><p>举个开发场景的例子：<br>公司开发环境的服务器A在公司内网，并且做了网络白名单，仅有特殊的网段能够访问，你的电脑不在这个特殊网段内，有一台机器B就在这个网段，你能访问这台机器 B，那么你就能通过机器 B 访问开发环境的服务器 A。通常，这个机器 B 可能是一个 <code>跳板机</code>，或者是一个 <code>vpn</code>。</p><p>我们通常认为，代理是为了解决 <code>网络不可达</code> 问题的，有些时候，代理也为了解决 <code>不那么可达</code> 的问题 ，俗称 <code>网速慢</code>。</p><p>比如在玩游戏这件事上，一些国外服的游戏，在国内玩起来就很慢，类似的还有看视频等场景。这种时候的代理，都是为了 <code>加速</code>，往往会采用 <code>udp</code> 的方案，可以参考 <a href="https://github.com/wangyu-/UDPspeeder/blob/branch_libev/doc/README.zh-cn.md">UDPspeeder</a></p><p>如果要自己建立网络代理服务，最常见的方案是 <code>ss</code> 、<code>open VPN</code> , 这相关的资料网络上十分丰富，就不多说。</p><p>在 mac/windows/iphone/android 上安装代理客户端比较简单，但是在 linux 上安装代理客户端就相对不那么常见了，之前为了安装 helm，解决过在服务器上安装客户端的问题，详情可参考 <a href="/longblog/posts/21_12_12_how_to_resolve_proxy_in_linux.html" name="如何解决linux下的代理访问" >如何解决linux下的代理访问</a> </p><h3 id="网络相关的内容"><a href="#网络相关的内容" class="headerlink" title="网络相关的内容"></a>网络相关的内容</h3><p>网络连通性还有一些其他方面的，平常可能用得比较少。</p><h4 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h4><p>是 <code>peer to peer</code> 的缩写，现在最多的应用场景是 <code>p2p内容分发网络</code>，比如大家说的 <code>种子下载</code>。另外，在区块链上，也使用了相同的技术。另一种比较大众的应用场景，就是 <code>语音电话</code>、<code>视频电话</code> 。</p><p>p2p 用在私有领域，可以用来作为 安全通信 的技术方案，例如私有部署的即时通信。除了通信，还可以作为安全文件传输的方案，相关信息可以参考 <a href="https://magic-wormhole.readthedocs.io/en/latest/welcome.html">magic-wormhole</a></p><h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><p>在网络转发这件事上，nc 无疑是一个非常精悍而强大的工具。</p><ul><li>可以用作简单的网络过滤器 (接受和拒绝host)</li><li>可使用 socks 代理</li><li>可监听 ssl</li><li>单向接受或发送</li><li>命令串联 (类似于 pipeline)</li><li>模拟延时收发</li><li>监听 udp / tcp </li></ul><p>nc 可以监听 udp 端口， <code>nc -v -lu 60001</code> ，也可以连接 udp  <code>nc -vu 46.46.46.46 60001</code><br>nc 可以转发端口 (延时 1s 收发)<br><code>nc -v -d 1s -lkp 8888 -c &quot;nc 127.0.0.1 50110&quot;</code></p><blockquote><p>可以参考文章：<a href="https://www.51cto.com/article/624612.html">linux端口转发的几种常用方法</a></p></blockquote><h4 id="k8s-开发网络代理"><a href="#k8s-开发网络代理" class="headerlink" title="k8s 开发网络代理"></a>k8s 开发网络代理</h4><p>一般我们认为，要访问 k8s 中的服务，有这样几种方案：</p><ol><li>nodeport</li><li>loadbalancer</li><li>ingress</li></ol><p>在开发调试阶段，我们有时候想直接访问 k8s 中的服务，但是这个服务在 k8s 中仅有 ClusterIP，单独为这个服务创建 LB 也划不来，这时候可以使用 <code>kubectl port-forward [podname] [local port]:[pod port]</code>，如果遇到需要 port-forward 的数量比较多的时候，这种方式就比较麻烦了，此时需要批量转发，可以参考 <a href="https://github.com/txn2/kubefwd">kubefwd</a>，也可以参考可视化的项目 <a href="https://github.com/pixel-point/kube-forwarder">kube-forwarder</a></p><p>除了想在本地直接访问集群中的服务，有时候我们也想把集群中某个服务所收到的流量，转发到我们本地端口，这样就可以实现方便地调试。</p><p>我们目前使用的方案是 devspace，具体信息可以查看 <a href="https://devspace.sh/cli/docs/introduction">devspace</a></p><p>其他可以考虑的方案可以查看</p><ul><li><a href="https://github.com/telepresenceio/telepresence">telepresence</a></li><li><a href="https://github.com/omrikiei/ktunnel">ktunnel</a></li><li><a href="https://nocalhost.dev/zh-CN/">nocalhost</a></li><li><a href="https://github.com/okteto/okteto">okteto</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>proxy</tag>
      
      <tag>network</tag>
      
      <tag>ssh</tag>
      
      <tag>frp</tag>
      
      <tag>nc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>穷人才会用的nas方案</title>
    <link href="/longblog/posts/21_12_02_a_nas_solution_used_by_poor.html"/>
    <url>/longblog/posts/21_12_02_a_nas_solution_used_by_poor.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近手机开始报存储空间快满了的问题，不知道有些什么文件占用了这么多空间，基本的解决办法是：把我将来需要的文件进行转移。例如之前的照片、视频等。自然而然想到了文件服务器。</p><h2 id="可选方案"><a href="#可选方案" class="headerlink" title="可选方案"></a>可选方案</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>采用现有的公有网盘，例如 百度网盘，阿里网盘，方便直接。<br>问题： 百度网盘太慢了，会员又太贵了，划不来。阿里网盘现在的客户端还很不完善。另外，可能还会有资料隐私问题、莫名关停服务等问题(参考360网盘)。</p><p>结论：对于一些公共资料可以采用这种方案，例如一些课程学习资料等。等阿里网盘发育一段时间再存一些公共资料。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>采用OSS，自建私有网盘，保证安全私密性。</p><p>问题：贵。oss存储费用 + 流量费，对于可能需要长期存储的文件来说，成本太高了。</p><p>结论：不行不行，穷。</p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>采用自有硬盘，搭建文件服务器，成本低，私密性高。</p><p>问题：</p><ol><li>搭建和维护相对复杂。</li><li>存储安全性需要考虑。</li><li>可访问性得不到保障，p2p 的方案在一些网络模型下不完全行得通。</li></ol><p>由于成本问题以及私密性问题，最终采用方案三 (姑且吧)。</p><h2 id="具体可选实施方案"><a href="#具体可选实施方案" class="headerlink" title="具体可选实施方案"></a>具体可选实施方案</h2><h3 id="购买成熟系统"><a href="#购买成熟系统" class="headerlink" title="购买成熟系统"></a>购买成熟系统</h3><p>现在市场上关于 家庭NAS 系统，主要有 威联通、群晖、铁威马 这些。<br>优点就是 简单、方便、功能齐全。缺点就是 价格贵！</p><p><img src="https://static.longalong.cn/img/tieweima_nas_price.png" alt="群晖、威联通价格"></p><p><img src="https://static.longalong.cn/img/xishu_nas_price.png" alt="西部数据价格"></p><p>其实直接购买的方式优势还是非常明显的，一个群晖，不仅可以作为文件服务器，还可以用作下载机、家庭影院、简单办公系统，由于其本质是一个linux系统的封装，因此也可以跑很多的服务(例如docker)，类似于买了一台家用服务器，而文件存储服务只是这个服务器的一个小服务而已。</p><h3 id="使用塔式-家用主机"><a href="#使用塔式-家用主机" class="headerlink" title="使用塔式/家用主机"></a>使用塔式/家用主机</h3><p>和直接购买群晖这类机器类似的另一种方案，就是直接使用家用主机。<br>家用主机的好处就是，大部分家庭中都有现有的设备，也就不需要单独花钱了，多配一块硬盘就可以了。</p><h3 id="使用树莓派"><a href="#使用树莓派" class="headerlink" title="使用树莓派"></a>使用树莓派</h3><p>使用主机作为文件服务器有一个弊端，就是能耗太高了，一个家用主机至少也是80W以上，常年开机的话，也不是一个环保的方式(主要可能还是成本太高)。<br>如果使用树莓派的话，则更加轻量，树莓派的运行功耗仅 5W ，放在某个小角落，一年下来问题也不大。<br>另外，树莓派可以提供的服务也可以非常非常多，甚至可以用来做智能家居控制器。</p><h3 id="使用路由器"><a href="#使用路由器" class="headerlink" title="使用路由器"></a>使用路由器</h3><p>在考虑树莓派的网络拓扑时，想到了为何不直接使用路由器作为文件服务器？</p><p>由于路由器的内核也是类unix系统，因此也是可以直接作为文件服务器的。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>考虑到成本，最终选择使用 路由器 作为文件服务器的处理器。</p><h2 id="具体操作方案"><a href="#具体操作方案" class="headerlink" title="具体操作方案"></a>具体操作方案</h2><h3 id="购买硬盘架、硬盘"><a href="#购买硬盘架、硬盘" class="headerlink" title="购买硬盘架、硬盘"></a>购买硬盘架、硬盘</h3><p>要将路由器作为文件服务器，首先就要挂载硬盘。同时，考虑到文件安全的问题，需要采用冗余存储的方式，因此，需要至少2块硬盘。<br>要达到目标，有两种方案：</p><ul><li>使用usb hub + usb 转接口 + 串口硬盘</li><li>使用usb hub + usb接口磁盘</li></ul><p>由于usb接口的磁盘价格都比较高(例如u盘、ssd等)，因此选择第一种方案。</p><p>去淘宝搜了一下，一个usb hub大约16元，一个usb转接口大约27元 * 2，一个硬盘大约60元(500g) * 2，成本为190元。</p><p>但这样有一个问题，用usb转接口的话，线太多了，得有两个12v的供电线以及2个sata转usb数据线，而且硬盘还是散乱的。</p><p>最终一狠心，花了150块大洋买了个双盘位硬盘架，这样就省去了usb hub和usb转接口的钱，最终算下来花了 270元。</p><h3 id="安装同步软件"><a href="#安装同步软件" class="headerlink" title="安装同步软件"></a>安装同步软件</h3><p>软件方面，有syncthing，非常合适，拥有多个操作系统的客户端。<br>参考官网： Syncthing</p><h3 id="连接同步"><a href="#连接同步" class="headerlink" title="连接同步"></a>连接同步</h3><p>路由器上和手机上都安装了syncthing后，进行两端绑定并共享文件夹。<br>然后设置同步策略为每小时扫描一次。</p><h3 id="啥也不用管了"><a href="#啥也不用管了" class="headerlink" title="啥也不用管了"></a>啥也不用管了</h3><p>然后就去睡觉吧，保证syncthing后台进程，你就几个月都不用管他，如果哪天手机空间不足了，就去看看是否最新同步的，如果是，就把手机上的文件都清空吧。</p><ul><li><input disabled="" type="checkbox"> 补一些搭建过程</li></ul><h2 id="PS-回头补一些图片"><a href="#PS-回头补一些图片" class="headerlink" title="PS: 回头补一些图片"></a>PS: 回头补一些图片</h2><ol><li>硬盘照</li><li>硬盘架照</li><li>路由器照</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>nas</tag>
      
      <tag>syncthing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用lvm实现raid能力</title>
    <link href="/longblog/posts/21_12_02_operation_of_raid_with_lvm.html"/>
    <url>/longblog/posts/21_12_02_operation_of_raid_with_lvm.html</url>
    
    <content type="html"><![CDATA[<h3 id="lvm是什么？"><a href="#lvm是什么？" class="headerlink" title="lvm是什么？"></a>lvm是什么？</h3><p>LVM 是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制，它由Heinz Mauelshagen在Linux 2.4内核上实现，最新版本为：稳定版1.0.5，开发版 1.1.0-rc2，以及LVM2开发版。Linux用户安装Linux操作系统时遇到的一个常见的难以决定的问题就是如何正确地评估各分区大小，以分配合适的硬盘空间。普通的磁盘分区管理方式在逻辑分区划分好之后就无法改变其大小，当一个逻辑分区存放不下某个文件时，这个文件因为受上层文件系统的限制，也不能跨越多个分区来存放，所以也不能同时放到别的磁盘上。而遇到出现某个分区空间耗尽时，解决的方法通常是使用符号链接，或者使用调整分区大小的工具，但这只是暂时解决办法，没有从根本上解决问题。随着Linux的逻辑卷管理功能的出现，这些问题都迎刃而解，用户在无需停机的情况下可以方便地调整各个分区大小。</p><h3 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h3><p>创建设备<br><img src="./../static/img/ali_ecs_lvm.png" alt="阿里云ecs"></p><h4 id="查看磁盘状态"><a href="#查看磁盘状态" class="headerlink" title="查看磁盘状态"></a>查看磁盘状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# fdisk -l<br><br>磁盘 /dev/vda：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br>磁盘标签类型：dos<br>磁盘标识符：0x000bb9c1<br><br>   设备 Boot      Start         End      Blocks   Id  System<br>/dev/vda1   *        2048    41943039    20970496   83  Linux<br><br>磁盘 /dev/vdb：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br><br><br>磁盘 /dev/vdc：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br><br><br>磁盘 /dev/vdd：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br></code></pre></td></tr></table></figure><h4 id="升级yum"><a href="#升级yum" class="headerlink" title="升级yum"></a>升级yum</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# yum update -y<br></code></pre></td></tr></table></figure><h4 id="安装lvm2"><a href="#安装lvm2" class="headerlink" title="安装lvm2"></a>安装lvm2</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# yum install lvm2 -y<br></code></pre></td></tr></table></figure><h4 id="创建物理卷"><a href="#创建物理卷" class="headerlink" title="创建物理卷"></a>创建物理卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# pvcreate /dev/vdb /dev/vdc<br>  Physical volume &quot;/dev/vdb&quot; successfully created.<br>  Physical volume &quot;/dev/vdc&quot; successfully created.<br></code></pre></td></tr></table></figure><h4 id="查看物理卷"><a href="#查看物理卷" class="headerlink" title="查看物理卷"></a>查看物理卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# pvdisplay<br>  &quot;/dev/vdc&quot; is a new physical volume of &quot;20.00 GiB&quot;<br>  --- NEW Physical volume ---<br>  PV Name               /dev/vdc<br>  VG Name<br>  PV Size               20.00 GiB<br>  Allocatable           NO<br>  PE Size               0<br>  Total PE              0<br>  Free PE               0<br>  Allocated PE          0<br>  PV UUID               avPba4-Z0J5-bhWC-4poS-x5oG-qt4P-4xUJnn<br><br>  &quot;/dev/vdb&quot; is a new physical volume of &quot;20.00 GiB&quot;<br>  --- NEW Physical volume ---<br>  PV Name               /dev/vdb<br>  VG Name<br>  PV Size               20.00 GiB<br>  Allocatable           NO<br>  PE Size               0<br>  Total PE              0<br>  Free PE               0<br>  Allocated PE          0<br>  PV UUID               exRn9W-AQKP-7rTc-EwAf-YtsK-MW0O-HHJ0sk<br></code></pre></td></tr></table></figure><h4 id="查看物理卷简要信息"><a href="#查看物理卷简要信息" class="headerlink" title="查看物理卷简要信息"></a>查看物理卷简要信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# pvs<br>  PV         VG Fmt  Attr PSize  PFree<br>  /dev/vdb      lvm2 ---  20.00g 20.00g<br>  /dev/vdc      lvm2 ---  20.00g 20.00g<br></code></pre></td></tr></table></figure><h4 id="查看物理卷简要信息-1"><a href="#查看物理卷简要信息-1" class="headerlink" title="查看物理卷简要信息"></a>查看物理卷简要信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# pvscan<br>  PV /dev/vdc                      lvm2 [20.00 GiB]<br>  PV /dev/vdb                      lvm2 [20.00 GiB]<br>  Total: 2 [40.00 GiB] / in use: 0 [0   ] / in no VG: 2 [40.00 GiB]<br></code></pre></td></tr></table></figure><h4 id="创建逻辑卷组"><a href="#创建逻辑卷组" class="headerlink" title="创建逻辑卷组"></a>创建逻辑卷组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# vgcreate vglong /dev/vdc /dev/vdb<br>  Volume group &quot;vglong&quot; successfully created<br></code></pre></td></tr></table></figure><p>查看逻辑卷组信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# vgdisplay<br>  --- Volume group ---<br>  VG Name               vglong<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        2<br>  Metadata Sequence No  1<br>  VG Access             read/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                0<br>  Open LV               0<br>  Max PV                0<br>  Cur PV                2<br>  Act PV                2<br>  VG Size               39.99 GiB<br>  PE Size               4.00 MiB<br>  Total PE              10238<br>  Alloc PE / Size       0 / 0<br>  Free  PE / Size       10238 / 39.99 GiB<br>  VG UUID               4flIRX-1oVR-MBy5-I2YT-gY2R-Eqaf-PmFq7b<br></code></pre></td></tr></table></figure><h4 id="查看逻辑卷组简要信息"><a href="#查看逻辑卷组简要信息" class="headerlink" title="查看逻辑卷组简要信息"></a>查看逻辑卷组简要信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# vgs<br>  VG     #PV #LV #SN Attr   VSize  VFree<br>  vglong   2   0   0 wz--n- 39.99g 39.99g<br></code></pre></td></tr></table></figure><h4 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# lvcreate -L 30G -n lvlong vglong<br>  Logical volume &quot;lvlong&quot; created.<br></code></pre></td></tr></table></figure><h4 id="查看逻辑卷"><a href="#查看逻辑卷" class="headerlink" title="查看逻辑卷"></a>查看逻辑卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# lvdisplay<br>  --- Logical volume ---<br>  LV Path                /dev/vglong/lvlong<br>  LV Name                lvlong<br>  VG Name                vglong<br>  LV UUID                x7iFjg-QSem-vzfu-jAkV-V0lI-50P3-tHD3Hz<br>  LV Write Access        read/write<br>  LV Creation host, time longtestlvm, 2021-10-12 14:00:09 +0800<br>  LV Status              available<br><span class="hljs-meta">  #</span><span class="bash"> open                 0</span><br>  LV Size                30.00 GiB<br>  Current LE             7680<br>  Segments               2<br>  Allocation             inherit<br>  Read ahead sectors     auto<br>  - currently set to     8192<br>  Block device           252:0<br></code></pre></td></tr></table></figure><h4 id="查看逻辑卷简要信息"><a href="#查看逻辑卷简要信息" class="headerlink" title="查看逻辑卷简要信息"></a>查看逻辑卷简要信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# lvs<br>  LV     VG     Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert<br>  lvlong vglong -wi-a----- 30.00g<br></code></pre></td></tr></table></figure><h4 id="查看磁盘"><a href="#查看磁盘" class="headerlink" title="查看磁盘"></a>查看磁盘</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# fdisk -l<br><br>磁盘 /dev/vda：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br>磁盘标签类型：dos<br>磁盘标识符：0x000bb9c1<br><br>   设备 Boot      Start         End      Blocks   Id  System<br>/dev/vda1   *        2048    41943039    20970496   83  Linux<br><br>磁盘 /dev/vdb：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br><br><br>磁盘 /dev/vdc：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br><br><br>磁盘 /dev/vdd：21.5 GB, 21474836480 字节，41943040 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br><br><br>磁盘 /dev/mapper/vglong-lvlong：32.2 GB, 32212254720 字节，62914560 个扇区<br>Units = 扇区 of 1 * 512 = 512 bytes<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br></code></pre></td></tr></table></figure><h4 id="格式化虚拟磁盘"><a href="#格式化虚拟磁盘" class="headerlink" title="格式化虚拟磁盘"></a>格式化虚拟磁盘</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# mkfs.ext4 /dev/vglong/lvlong<br>mke2fs 1.42.9 (28-Dec-2013)<br>文件系统标签=<br>OS type: Linux<br>块大小=4096 (log=2)<br>分块大小=4096 (log=2)<br>Stride=0 blocks, Stripe width=0 blocks<br>1966080 inodes, 7864320 blocks<br>393216 blocks (5.00%) reserved for the super user<br>第一个数据块=0<br>Maximum filesystem blocks=2155872256<br>240 block groups<br>32768 blocks per group, 32768 fragments per group<br>8192 inodes per group<br>Superblock backups stored on blocks:<br>        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,<br>        4096000<br><br>Allocating group tables: 完成<br>正在写入inode表: 完成<br>Creating journal (32768 blocks): 完成<br>Writing superblocks and filesystem accounting information: 完成<br></code></pre></td></tr></table></figure><h4 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm mnt]# mkdir longtestlvm<br><br>[root@longtestlvm mnt]# mount /dev/mapper/vglong-lvlong /mnt/longtestlvm/<br></code></pre></td></tr></table></figure><h4 id="创建一个文件试试"><a href="#创建一个文件试试" class="headerlink" title="创建一个文件试试"></a>创建一个文件试试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm longtestlvm]# mkdir -p /mnt/longtestlvm/longtest<br><br>[root@longtestlvm longtestlvm]# echo &#x27;hello world \n nihao a&#x27; &gt; /mnt/longtestlvm/longtest/a.txt<br></code></pre></td></tr></table></figure><h4 id="查看磁盘挂载"><a href="#查看磁盘挂载" class="headerlink" title="查看磁盘挂载"></a>查看磁盘挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm mnt]# df -h<br>文件系统                   容量  已用  可用 已用% 挂载点<br>devtmpfs                   3.9G     0  3.9G    0% /dev<br>tmpfs                      3.9G     0  3.9G    0% /dev/shm<br>tmpfs                      3.9G  572K  3.9G    1% /run<br>tmpfs                      3.9G     0  3.9G    0% /sys/fs/cgroup<br>/dev/vda1                   20G  2.4G   17G   13% /<br>tmpfs                      783M     0  783M    0% /run/user/0<br>/dev/mapper/vglong-lvlong   30G   45M   28G    1% /mnt/longtestlvm<br></code></pre></td></tr></table></figure><h4 id="查看文件大小"><a href="#查看文件大小" class="headerlink" title="查看文件大小"></a>查看文件大小</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm mnt]# du -ah<br>4.0K        ./longtestlvm/longtest/a.txt<br>8.0K        ./longtestlvm/longtest<br>16K        ./longtestlvm/lost+found<br>28K        ./longtestlvm<br>32K        .<br></code></pre></td></tr></table></figure><h4 id="扩展逻辑卷容量"><a href="#扩展逻辑卷容量" class="headerlink" title="扩展逻辑卷容量"></a>扩展逻辑卷容量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# lvextend -L +4G /dev/vglong/lvlong<br>  Size of logical volume vglong/lvlong changed from 30.00 GiB (7680 extents) to 34.00 GiB (8704 extents).<br>  Logical volume vglong/lvlong successfully resized.<br></code></pre></td></tr></table></figure><h4 id="resize逻辑卷"><a href="#resize逻辑卷" class="headerlink" title="resize逻辑卷"></a>resize逻辑卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# resize2fs /dev/vglong/lvlong<br>resize2fs 1.42.9 (28-Dec-2013)<br>Filesystem at /dev/vglong/lvlong is mounted on /mnt/longtestlvm; on-line resizing required<br>old_desc_blocks = 4, new_desc_blocks = 5<br>The filesystem on /dev/vglong/lvlong is now 8912896 blocks long.<br></code></pre></td></tr></table></figure><h4 id="扩展逻辑卷组"><a href="#扩展逻辑卷组" class="headerlink" title="扩展逻辑卷组"></a>扩展逻辑卷组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# vgextend vglong /dev/vdd<br>  Physical volume &quot;/dev/vdd&quot; successfully created.<br>  Volume group &quot;vglong&quot; successfully extended<br></code></pre></td></tr></table></figure><h4 id="缩减逻辑卷"><a href="#缩减逻辑卷" class="headerlink" title="缩减逻辑卷"></a>缩减逻辑卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# umount /mnt/longtestlvm<br><br>[root@longtestlvm ~]# e2fsck -f /dev/vglong/lvlong<br>e2fsck 1.42.9 (28-Dec-2013)<br>第一步: 检查inode,块,和大小<br>第二步: 检查目录结构<br>第3步: 检查目录连接性<br>Pass 4: Checking reference counts<br>第5步: 检查簇概要信息<br>/dev/vglong/lvlong: 13/2228224 files (0.0% non-contiguous), 184932/8912896 blocks<br><br><br>[root@longtestlvm ~]#  resize2fs /dev/vglong/lvlong  10G<br>resize2fs 1.42.9 (28-Dec-2013)<br>Resizing the filesystem on /dev/vglong/lvlong to 2621440 (4k) blocks.<br>The filesystem on /dev/vglong/lvlong is now 2621440 blocks long.<br><br><br>[root@longtestlvm ~]# lvresize -L 10G /dev/vglong/lvlong<br>  WARNING: Reducing active logical volume to 10.00 GiB.<br>  THIS MAY DESTROY YOUR DATA (filesystem etc.)<br>Do you really want to reduce vglong/lvlong? [y/n]: y<br>  Size of logical volume vglong/lvlong changed from 34.00 GiB (8704 extents) to 10.00 GiB (2560 extents).<br>  Logical volume vglong/lvlong successfully resized.<br></code></pre></td></tr></table></figure><h4 id="缩减逻辑卷组"><a href="#缩减逻辑卷组" class="headerlink" title="缩减逻辑卷组"></a>缩减逻辑卷组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# vgreduce vglong /dev/vdd<br></code></pre></td></tr></table></figure><h4 id="查看逻辑卷组"><a href="#查看逻辑卷组" class="headerlink" title="查看逻辑卷组"></a>查看逻辑卷组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# vgdisplay<br>  --- Volume group ---<br>  VG Name               vglong<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        2<br>  Metadata Sequence No  10<br>  VG Access             read/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                1<br>  Open LV               0<br>  Max PV                0<br>  Cur PV                2<br>  Act PV                2<br>  VG Size               39.99 GiB<br>  PE Size               4.00 MiB<br>  Total PE              10238<br>  Alloc PE / Size       2560 / 10.00 GiB<br>  Free  PE / Size       7678 / 29.99 GiB<br>  VG UUID               4flIRX-1oVR-MBy5-I2YT-gY2R-Eqaf-PmFq7b<br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# lvremove /dev/vglong/lvlong<br>Do you really want to remove active logical volume vglong/lvlong? [y/n]: y<br>  Logical volume &quot;lvlong&quot; successfully removed<br><br>[root@longtestlvm ~]# vgremove vglong<br>  Volume group &quot;vglong&quot; successfully removed<br>  <br>[root@longtestlvm ~]# pvremove /dev/vdb /dev/vdc /dev/vdd<br>  Labels on physical volume &quot;/dev/vdb&quot; successfully wiped.<br>  Labels on physical volume &quot;/dev/vdc&quot; successfully wiped.<br>  Labels on physical volume &quot;/dev/vdd&quot; successfully wiped.<br></code></pre></td></tr></table></figure><h4 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# pvmove /dev/vdb /dev/vdc<br></code></pre></td></tr></table></figure><h4 id="一些其他的内容"><a href="#一些其他的内容" class="headerlink" title="一些其他的内容"></a>一些其他的内容</h4><p>disk相关命令<br>fdisk 、 mkfs 、du 、 df 、dump2fs</p><h4 id="一些问题记录"><a href="#一些问题记录" class="headerlink" title="一些问题记录"></a>一些问题记录</h4><ol><li>已经将某个物理磁盘加入到 vg 中后，再将该物理盘进行分区<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# pvs<br>  WARNING: Device for PV cSASFg-dS4S-lrIP-hD3V-aJSR-EnzC-5bYp4B not found or rejected by a filter.<br>  Couldn&#x27;t find device with uuid cSASFg-dS4S-lrIP-hD3V-aJSR-EnzC-5bYp4B.<br>  PV         VG     Fmt  Attr PSize   PFree<br>  /dev/vdb   vglong lvm2 a--  &lt;20.00g &lt;20.00g<br>  /dev/vdc   vglong lvm2 a--  &lt;20.00g &lt;20.00g<br>  /dev/vdd1         lvm2 ---  100.00m 100.00m<br>  /dev/vdd2         lvm2 ---  100.00m 100.00m<br>  [unknown]  vglong lvm2 a-m  &lt;20.00g &lt;20.00g<br></code></pre></td></tr></table></figure></li></ol><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@longtestlvm ~]# vgreduce --removemissing vglong --force<br>  Volume group &quot;vglong&quot; is already consistent.<br>  <br><br>[root@longtestlvm ~]# pvs<br>  PV         VG     Fmt  Attr PSize   PFree<br>  /dev/vdb   vglong lvm2 a--  &lt;20.00g &lt;20.00g<br>  /dev/vdc   vglong lvm2 a--  &lt;20.00g &lt;20.00g<br>  /dev/vdd1         lvm2 ---  100.00m 100.00m<br>  /dev/vdd2         lvm2 ---  100.00m 100.00m<br></code></pre></td></tr></table></figure><h4 id="整体的一些想法"><a href="#整体的一些想法" class="headerlink" title="整体的一些想法"></a>整体的一些想法</h4><p>对于 lvm，可以用于多个磁盘组合成一个磁盘，且提供 raid 能力，这给存储提供了超大容量的可能性，可以考虑作为NAS的一种实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>disk</tag>
      
      <tag>raid</tag>
      
      <tag>lvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梳理一下要做的重要的事</title>
    <link href="/longblog/posts/21_09_30_to_think_what_is_the_important_things.html"/>
    <url>/longblog/posts/21_09_30_to_think_what_is_the_important_things.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时光飞逝，转眼就来到了季度的末尾，工作上，一般会在季末时进行季度总结，我觉得还挺有价值，自己也同样需要做这类季度总结，当然，更重要的，是梳理清楚自己下个季度有哪些重要的事要做。</p><h2 id="上个季度"><a href="#上个季度" class="headerlink" title="上个季度"></a>上个季度</h2><p>工作上，主要做私有化部署的整套内容，包含依赖摘除、工具链调研、环境搭建等诸多事，整体打分 60 分。</p><p><strong>【私有化】完成的事：</strong></p><ol><li>调研了多种私有化部署方案，例如 <code>k8s</code>、<code>micro kube</code>、<code>k3s</code> 等，最后基于多方面考虑，选择了 <code>k3s</code></li><li>调研了数个文件存储方案，例如 <code>glusterFS</code>、<code>minio</code>，最后选择了 <code>minio</code></li><li>为私有化部署开发了 <code>license server</code> 项目</li><li>部署脚本采用 <code>ansible</code> 管理方案</li></ol><p><strong>【私有化】未完成的事：</strong></p><ol><li>私有化的扩缩容方案</li><li>私有化的数据冷热备方案</li><li>私有化的升级迁移方案</li><li>私有化的权限控制方案</li><li>私有化后台[业务需求不明]</li></ol><p><strong>【质量与性能】完成的事：</strong></p><ol><li>调研多个性能压测工具，例如 <code>ab</code>、 <code>locust</code>、 <code>jmeter</code>、 <code>PTS</code> 、 <code>wrk</code>、<code>go-stress-testing</code>、<code>meter-sphere</code>、<code>k6</code> 等，由于主要是为 websocket 测试，未找到合适轮子，于是自己写，基于 <code>gorilla/websocket</code> 写的强业务耦合测试代码。</li><li>接口测试方面，接口测试框架经调研未发现好用的工具，主要调研了 <code>yapi</code>、 <code>postman</code>、 <code>swagger</code>、 <code>metersphere</code> ，于是依然使用自己造的接口测试轮子，改了部分 bug。</li><li>websocket 压测，阶段性瓶颈在于 <code>mongodb</code>，经部分调整，提升最大并发量 10 倍，瓶颈依然在 <code>mongodb</code>，下一阶段计划重新进行数据库选型。</li><li>代码质量方面，部分项目集成 <code>golangci-lint</code>，同时调研了多个代码质量保证方面的工具链，例如 <code>Covergates</code>、 <code>goc</code>、<code>gitlab pages</code> 等。</li></ol><p><strong>【质量与性能】未完成的事：</strong></p><ol><li>未能对压测进行系统性总结</li><li>未能对调研的各类工具做实操性文档</li><li>对于 <code>mongodb</code> 的性能瓶颈未能做更高层次的思考与总结</li><li>测试框架未能支持 rpc 测试</li><li>测试框架未能支持 延迟 操作</li><li>测试框架未能支持 form-data 支持</li><li>测试框架未能支持 数据库 存储</li><li>测试框架未能支持 录制 接口与自动化测试用例生成</li><li>代码质量保证还未推广到所有 golang 项目</li></ol><p><strong>【其他】完成的事：</strong></p><ol><li>完成了截图服务器开发和部署，为视觉感知测试铺了路</li><li>开始学习 计算机基础 类知识<ul><li>操作系统</li><li>计算机网络</li><li>序列化方案</li></ul></li><li>开始重新写博客</li></ol><p><strong>【其他】未完成的事：</strong></p><ol><li>视觉感知测试还没有做过比较细致的分析</li><li>计算机基础类知识没有记成笔记</li><li>博客内容规划还不够细致</li></ol><h2 id="这个季度"><a href="#这个季度" class="headerlink" title="这个季度"></a>这个季度</h2><p><strong>【质量与性能】要做的事：</strong></p><ol><li>充分调研 <code>nosql</code> 数据库, 结合业务需求，全面梳理适用场景<ul><li>mongodb</li><li>redis</li><li>groupcache</li><li>levelDB</li><li>cassandra</li><li>……</li></ul></li><li>形成基本完备的压测工具链体系<ul><li>解决 rpc 压测支持</li><li>解决 ws 压测自动化</li><li>解决 api 压测自动化</li><li>完成 接口测试 协议设计，最好能支持部分协议转换</li></ul></li><li>代码质量保证<ul><li>所有项目添加 代码静态检查 golangci-lint</li><li>工具库项目全部添加 测试覆盖度报告</li><li>所有有自动化测试的项目添加覆盖度 ci</li></ul></li><li>初步形成对第三方中间件的benchmark工具链<ul><li>redis</li><li>mongodb</li><li>mysql</li><li>kafka</li></ul></li></ol><p><strong>【私有化】要做的事：</strong></p><ol><li>私有化的扩缩容方案</li><li>私有化的数据冷热备方案</li><li>私有化的升级迁移方案</li><li>私有化的权限控制方案</li><li>私有化后台[业务需求不明]</li></ol><p><strong>【其他】要做的事：</strong></p><ol><li>把学习的内容进行梳理整合，并形成博客 * 30</li><li>刷 leetcode 题目 * 60</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要做的事情非常多，因此每天的时间要做好规划，不能 <code>什么堆到眼前再做什么</code>，每天要做好当天的事情总结。<br>加油。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>收拾一下，重新出发</title>
    <link href="/longblog/posts/21_09_20_new_start.html"/>
    <url>/longblog/posts/21_09_20_new_start.html</url>
    
    <content type="html"><![CDATA[<h3 id="预"><a href="#预" class="headerlink" title="预"></a>预</h3><p>前两天，收到腾讯网站备案人员的电话，说我的网站底部没有添加备案号，让补一下，我这才想起自己的博客已经很多年没更新了=.=!。</p><p>早上很早就醒了，也不想看手边的那些大部头技术书，于是就打开了我的博客，浏览了一遍自己曾经写下的文字。没想到，看到有些文章时竟忍不住产生一丝丝感动，回想起了自己一路走来的历程：</p><h3 id="前缘"><a href="#前缘" class="headerlink" title="前缘"></a>前缘</h3><ul><li>毕业前的实习是做的审计，半年左右的审计经历让我意识到，我在财会这条路上，走不远</li><li>于是开始问自己，我喜欢什么？</li><li>摇摆很久，最终选定试一下 编程</li><li>毫无任何头绪地学习技术，从 C、单片机、arduino 开始玩，也不知道能做啥</li><li>接触了树莓派，艰难地在 linux 环境上挣扎</li><li>前端的所见即所得让我看到一丝光亮，开始学习 html、css、js、jq、vue</li><li>不知道自己学得咋样了，模仿写了 网易云课堂 和 B站</li><li>听了老爸的话: “不知道行不行没关系，去试试看，不试试永远不知道行不行”，鼓了鼓劲去面试</li></ul><h3 id="中上篇"><a href="#中上篇" class="headerlink" title="中上篇"></a>中上篇</h3><ul><li>去了 极客邦 做前端开发工程师。距毕业过去了 4 个月</li><li>学习前端的知识，主要是 vue 生态中的种种</li><li>js 熟练了些，就学 nodejs，mysql</li><li>工作之余写点前后端的项目玩一下，例如时间胶囊(一个web记事本)</li><li>觉得在审美上没啥天赋，考虑看看后端</li><li>迷茫，简单学了 python、java、lua，套开源框架写 demo，主要是 web 开发</li></ul><h3 id="中下篇"><a href="#中下篇" class="headerlink" title="中下篇"></a>中下篇</h3><ul><li>朋友做自媒体收益不错，想去挣点钱，就提了离职。此时，差一天就满半年了</li><li>自媒体一直没上路，没啥思路，在家挣扎了几个月，觉得自己可能积淀不够，还是需要先去历练</li><li>又重新评估了 java 和 python，最后选了 go，陆陆续续学了 2 个月</li><li>之前用 nodejs 和 python 写过小项目，但对真实的企业开发完全没概念，没信心</li><li>内心十分不安，在爱人的鼓励下，终于还是投出去了一些简历</li><li>去了蓝湖，做后端开发。此时，据离开上家公司已经 6 个月</li></ul><h3 id="梦初醒"><a href="#梦初醒" class="headerlink" title="梦初醒"></a>梦初醒</h3><ul><li>这么久以来，我的学习环境都是自己搭的，逐渐也有了些熟练度，渐渐对 linux 系统比较感兴趣</li><li>学习运维的东西，主要是 docker、k8s、ansible、shell 这些</li><li>对服务器有种奇妙的感觉，于是买了一台24核的Dell服务器，用于平常测试</li><li>团队中有些跟运维接触比较多的事，都是我在做，比如 私有化部署、性能测试、集成测试 等等</li><li>做开发以来，一直后悔自己大学几年没有学相关知识，跟科班的同学相比，我起步几乎晚了半个世纪</li><li>也认识到自己在计算机基础上需要补补，于是开始看一些书，主要是 网络、操作系统、计算机组成、编译原理 这些</li><li>不仅在基础上不足，在经验上也十分欠缺，于是开始看一些有点深度的知识，主要是一些厉害的开源项目的源码 这些</li></ul><h3 id="脚下的路"><a href="#脚下的路" class="headerlink" title="脚下的路"></a>脚下的路</h3><p>到现在，距离来蓝湖已经 10 个月了，时光飞逝，令人不住感慨，现在是中秋的前一天，印象中正是秋高气爽之时，然而北京这两日阴雨连绵，天色昏沉，不经意间，也生出了些惆怅的情绪……</p><p>以前博客写的很少，学东西都是靠在脑海里留下一些印象，时间稍微一长就容易忘记，这样不好。作为程序员，写博客其实应该是基本功，和 算法、数学、计算机原理、设计模式 这些是一个层次的，属于那种具有长远价值的东西，我也应当多下功夫。</p><p>我重开这个博客，目的就是把我在技术学习时的一些收获进行总结梳理，用技术文章的方式，把对应的知识加工输出，一来，可以加深自己对一些问题的认识，二来，如果这些文章也能有那么一丝的作用，让来我的小站逛逛的同学们感到有所收获，那也算是推进了社会进步，哈哈哈哈。</p><p>将来的一段时间，我会把精力主要放在 第 26 和 第 27 这两条内容上，因此博客会记录一些： 计算机网络、操作系统、编译原理、数据库原理、分布式架构、服务治理 等这些方面的内容，也会看情况分享一些读书笔记、源码阅读感受等内容。</p><p>最后，希望未来越来越好，我们。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
