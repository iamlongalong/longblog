<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/longblog/static/img/favicon.png"><link rel="icon" href="/longblog/static/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="longalong"><meta name="keywords" content=""><title>几种后端通信方式的杂谈 - Longbao</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/longblog/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/longblog/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"iamlongalong.github.io",root:"/longblog/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/static/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/longblog/js/utils.js"></script><script src="/longblog/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/longblog/rss.xml" title="Longbao" type="application/atom+xml">
</head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/longblog/">&nbsp;<strong>Longbao</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/longblog/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/longblog/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/longblog/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/longblog/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/longblog/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/longblog/static/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="几种后端通信方式的杂谈"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> longalong </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-03-05 23:45" pubdate>2023年3月5日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 29 分钟</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">几种后端通信方式的杂谈</h1><div class="markdown-body"><h2 id="计算机的几种通信方式"><a href="#计算机的几种通信方式" class="headerlink" title="计算机的几种通信方式"></a>计算机的几种通信方式</h2><p>对于计算机而言，通信 是一件永远不可能被忽视的事情。通信 基本可以分为 进程内通信 和 进程间通信。 进程内通信的方式大致有： <code>① 共享内存</code> <code>② 变量传递</code>。进程间通信又需要分为 在同一操作系统上 和 在不同操作系统上，同一操作系统上的进程间通信主要有 <code>① 共享内存</code> <code>② 共享存储</code> <code>③ 管道(命名)</code> <code>④ 信号量</code> <code>⑤ 消息队列</code> <code>⑥ socket</code> 通信。不同操作系统上，则只能使用 <code>socket</code> 通信。</p><p>实际上，从上面可以看出，除了 <code>信号量</code> 的通信方式比较独特外，其他的通信方式都是基于 <code>共享</code> 或 <code>传递</code> 的进行。只是 共享的方式 和 传递的方式 有所差别。</p><h3 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h3><p>在 进程内通信时，共享内存 是可以被特定编程语言直接使用的内存格式，因此效率非常高；在进程间的共享内存上，内存是最底层的共享方式，因此内存格式需要自己约定，也就意味着所有传递的值 需要经过一定的格式转换，也就是 序列化的过程。</p><p>在 进程内通信时，变量传递可以分为 值传递 和 引用传递 ，所有的操作都是编程语言做的，我们只管使用即可。但在 进程间的消息传递时，我们则需要自己处理 消息格式 的问题，也即是 序列化和反序列化 的过程。</p><p>上述的这些通信方式，实际上是很通用的模型，不仅在操作系统层被使用，在应用层，我们基于这些模型造了很多工具或软件系统。例如，共享内存 我们有 <code>redis</code> 、<code>memcache</code> 等，共享存储 我们有 <code>mysql</code>、<code>etcd</code>、<code>mongodb</code> 等等，管道 我们有 <code>redis</code> ，消息队列 我们有 <code>kafka</code>、<code>zeroMQ</code> 、<code>rabbitMQ</code> 等等，甚至有一些 消息队列的通用协议，例如 <code>MQTT</code>、<code>AMQP</code> 等等。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>最繁荣的进程间通信方式，实际上还是 <code>socket</code> 通信，socket 本身只是一个接口定义，不过这个接口定义太通用了，任何消息传递几乎都可以套用这个接口，无论是 <code>文件</code>、<code>网络</code> 还是 <code>内存</code> 。</p><h2 id="服务端的常见通信方式"><a href="#服务端的常见通信方式" class="headerlink" title="服务端的常见通信方式"></a>服务端的常见通信方式</h2><p>对于服务端开发而言，最常用的还是基于 网络 的 socket 编程，最底层自然都依赖 TCP/UDP，在应用层上，我们有非常多的协议，例如 <code>http</code> 、<code>http2</code> 、 <code>http3</code> 、<code>websocket</code>、 <code>MQTT</code> 以及各种小领域的协议，其实，所有的协议，都是对特定领域的通信内容的通用抽象，例如，http 是一个很常用的互联网请求协议，包含 请求行 、请求头 、请求体 ，一般认为 http 是一个 文本协议，实际上这指的是其 序列化方式，文本内容直接通过 ascll [待验证] 进行传输，背景是 http 协议出生在 文本内容共享浏览 的互联网初始定位 的时代。</p><p>后来发现 http 的传输效率不高，于是 http2 做了 压缩消息头 、二进制分帧传输、连接复用 的优化。在后来，认为基于 tcp 的传输效率还是有点低，而现代基础设施整体是比较好的，因此基于 udp 在应用层做了一些消息质量保证的操作，用于提升传输效率。</p><p>其实 http 系列协议，都可以看做是在 http1.1 的协议约定基础上，在传输层做优化。 那么，是否有其他通过优化协议本身内容的方式呢？其实其他协议都是在做这件事。例如，<code>websocket</code>，建立在 tcp 之上，使用非常简洁的控制帧，通信消息全在消息体当中。还有一些追求极致性能的协议，甚至直接建立在 TCP 上做应用层消息传输，例如 kafka 的通信协议。</p><p>从 自定义消息结构 这个看待协议的角度出发，我们甚至可以认为 rpc 才是真正的一切协议的源头，可以想象曾经有各类自定义的 rpc 格式，例如 <code>samba</code>、<code>nfs</code>、<code>ssh</code> 等等，当他们具有一定的名气后，大家就把他们从 自定义 rpc 协议 的认识中拎出来，直接用他们的名字代替。也就是说，我们现在所自定义的各种 rpc 协议，当他们具有一定名气后，就可以拥有自己的 名字 。</p><p>阐述完各类协议的基本情况后，我们来聚焦一下 <code>http</code>、<code>http2</code>、<code>grpc</code>、 <code>ws</code> ，看一下他们的关系。</p><h3 id="几种协议的区别认识"><a href="#几种协议的区别认识" class="headerlink" title="几种协议的区别认识"></a>几种协议的区别认识</h3><p>Http 的全名叫 超文本传输协议，是互联网最常用的协议，分为 请求行 (method + path)、请求头 (header) 、请求体 (body)，请求体可以是二进制数据(经过编码传输)。</p><p>http2 是 http 的升级版，所有请求格式延续了 http 的格式，对上层应用来说整体没啥差别(如果仅当做http来用)，但是也提供了 服务端推送、stream 等功能。一定程度上，我们可以认为，http2 是 http 的 传输层封装 (充当 transport 层)。</p><p>grpc 是把 http2 当做传输层 (transport 层)。其他特性是自行实现的，例如 <code>interceptor</code>、<code>resolver</code>、<code>balancer</code>、<code>auth</code>、<code>log</code>、<code>status</code>(状态码)、<code>stats</code>(监控)。实际上，我们不能把 grpc 当做一种协议，而是一种 rpc 框架 (类似于 http 框架)，协议 有特定格式 或 接口约定，而 grpc 是用于生成特定 server 和 client 的一整套工具。</p><p>ws 是直接在 tcp 之上的一层通信协议，特点是 轻量、连接保持，ws的想象空间很大，实际上，如果你愿意，甚至可以使用 ws 作为 http 的 transport 层，也可以把 ws 作为 mqtt 的 transport 层，也可以把 ws 作为 grpc 的传输层。</p><p>一些情况下，我们可以认为，一个协议 或者 一个框架，为什么选择了某项技术 而并不是 其他技术，是由于 生态 决定的，例如为什么 grpc 选用了 http2 而不是直接的 tcp 连接？为什么后端服务调用大家使用 grpc 而不是 手写 http？为什么后端不用 ws 通信？</p><h3 id="ws的特点"><a href="#ws的特点" class="headerlink" title="ws的特点"></a>ws的特点</h3><p>ws 现在的主要场景在前后端的即时消息上，这得益于 ws 的 状态保持 的特性，那么，我们是否可以基于这个特性，做更多的事情？</p><p>比如，① 基于 ws 的 http 协议转换、② 基于 ws 的 grpc 协议转换、③ 基于 ws 的自定义 rpc 框架、④ 基于 ws 的自定义框架。</p><p>对于 ①，应用场景较少，如果是为了传输性能，那么使用 http2 就能解决，而且 http2 的生态更好。<br>对于 ②，可以，但目前已经有了基于 http 的 grpc 协议转换，使用 http2 的情况下，性能也没啥问题。<br>对于 ③，可以，但要考虑生态问题，这基本意味着重新实现整套 grpc 的各模块。<br>对于 ④，可以，但目前已经有一些 ws 框架，例如 socket.io，要考虑清楚为什么需要一套新的框架。</p><h3 id="我对于当前-http-、http2、grpc、ws-方式的基本判断"><a href="#我对于当前-http-、http2、grpc、ws-方式的基本判断" class="headerlink" title="我对于当前 http 、http2、grpc、ws 方式的基本判断"></a>我对于当前 http 、http2、grpc、ws 方式的基本判断</h3><ol><li>http 有完善的接口定义方式 (<code>openapi</code>)，http2 甚至 http3 在性能上和将来的生态上也非常不错。目前没有看到好的基于 http 接口定义 方式自动生产 server 和 client 的工具。</li><li>grpc 有完善的接口定义方式，性能上和生态上很不错，有自动生成代码的工具链。前端调用不支持直接通信，需要经过 http 协议再转一次(浏览器端 或 proxy 端)。</li><li>ws 有一定的生态支持，ws 的状态保持在一些场景下是非常不错的特性。ws 没有自动生成代码的工具。</li></ol><h3 id="ws有什么特殊的价值？"><a href="#ws有什么特殊的价值？" class="headerlink" title="ws有什么特殊的价值？"></a>ws有什么特殊的价值？</h3><p>ws 有两个特性： ① 连接保持 ② 协议轻量 。另外，ws 的生态不错 (主要指浏览器的特殊支持)。<br>ws 在一些需要长链接的场景下，非常有价值，比如： ① 协商缓存内容，② 服务端缓存内容(eg: 权限)</p><p>如果解决 ws 的 ① 重连状态保持 ② http 降级 ③ 代码自动生成 ④ 开发模式 ⑤ 测试工具包 问题，那么 ws 不失为一个很好的通信工具。</p><h2 id="代码生成的思考"><a href="#代码生成的思考" class="headerlink" title="代码生成的思考"></a>代码生成的思考</h2><p>代码生成是一个非常好的思路，可以保证代码的统一性，减少不规范的地方，可维护性更高。现在可以看到，在 client 和 server 代码生成上，grpc 做的是最好的，生态也比较开放，在这个基础上可以开发一些自己需要的功能。</p><p>Go-zero 框架是自己实现的一套语法解析并形成特定代码，提供了模板化的方法生成代码，也和 grpc 一样提供了自定义插件的方式，看上去野心不小。</p><p>Go-kratos 则是接入 grpc 的生态，通过扩展生成代码的方式，接入了自己的 http 和 rpc。</p><p>Go-frame 在接口自动化代码生产上没有动作，只是在 脚手架工具 中简化了 对 grpc 代码生成的命令。</p><p>除了上面说到的 基于接口文档 自动化生成 server 及 client 代码外，还有一些其他常用的可生成的代码：</p><ol><li>基于 数据库表 生成 结构体、orm、基本 crud 代码。</li><li>基于 接口定义，生成前端 client 代码。</li><li>生成部署侧的脚本或包 (docker、k8s、devspace等)</li></ol><p>第 1 点中的 model 生成，go-frame 和 go-zero 都有做。 第 2 点目前只有 go-zero 做了一些，grpc 也有一些。 第 3 点都有动作。</p><p>另外 ，补充一嘴，数据库的结构体生成 是可以 正反使用的，例如，通过 orm，生成数据库表，同样也可以通过 数据库表，生成 orm，这点可以参考 <a target="_blank" rel="noopener" href="https://blog.longalong.cn/posts/22_03_21_%E5%85%B3%E4%BA%8E%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81.html">关于基于接口定义的开发流</a> 最后的链接。</p><h3 id="一个疑惑"><a href="#一个疑惑" class="headerlink" title="一个疑惑"></a>一个疑惑</h3><p>按理，http 才是互联网下的王者，那么，为什么很少见到基于 http 的 接口定义文档 自动生成代码的工具呢？</p><p>实际上，相比于 protobuff 的 proto3 这种新的 DSL ，我们使用已有语言的成本可能更低，例如 基于 yaml 或者 基于 json 的，比如使用 openapi 的接口定义。甚至，使用一门我们熟悉的语言做接口描述，例如 js，然后代码生成则直接使用 js 进行拼接 ( 或模板渲染 )。</p><p>这个可以找找是否有相关的工具，如果没有，可以自己实现一个。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>杂七杂八写了一些自己的想法，很多表述不一定很精准，但思路确实还是有可参考性的，可以经常回味一下。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/longblog/tags/communication/">communication</a> <a class="hover-with-bg" href="/longblog/tags/backend/">backend</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/longblog/posts/22_07_11_what_is_serverless.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">serverless_究竟是何方神圣？</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/longblog/posts/22_07_19_21_44_some_discuss_about_microservice.html"><span class="hidden-mobile">服务化演进的一些问题探讨</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">备案: 粤ICP备2020131301号</a></span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/longblog/js/events.js"></script><script src="/longblog/js/plugins.js"></script><script src="/longblog/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/longblog/js/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/longblog/static/js/showiframe.js"></script><script src="/longblog/js/boot.js"></script></body></html>