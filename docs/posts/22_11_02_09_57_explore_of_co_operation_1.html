<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/longblog/static/img/favicon.png"><link rel="icon" href="/longblog/static/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="longalong"><meta name="keywords" content=""><title>协同场景的状态同步探索之一 - Longbao</title><link rel="stylesheet" href="https://static.longalong.cn/packages/blog/css/bootstrap.min.css"><link rel="stylesheet" href="https://static.longalong.cn/packages/blog/github-markdown.min.css"><link rel="stylesheet" href="/longblog/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://static.longalong.cn/packages/blog/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/longblog/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"iamlongalong.github.io",root:"/longblog/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/static/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/longblog/js/utils.js"></script><script src="/longblog/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/longblog/rss.xml" title="Longbao" type="application/atom+xml">
</head><body><header style="height:35vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/longblog/">&nbsp;<strong>Longbao</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/longblog/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/longblog/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/longblog/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/longblog/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/longblog/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/longblog/static/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="协同场景的状态同步探索之一"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> longalong </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-11-02 09:56" pubdate>2022年11月2日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 33 分钟</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">协同场景的状态同步探索之一</h1><div class="markdown-body"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前两天在整理 <a href="/longblog/posts/22_10_28_16_12_envolution_of_mess_system_first_launch.html" name="消息系统进化史-零号机">消息系统进化史-零号机</a> 的思路的时候，想到一种场景： 几个客户端之间想拥有一个公共的状态，任何一个客户端对该状态进行了更改，都能同步更改到其他客户端。</p><p>于是，在此思路上，做了 <a href="/longblog/posts/22_10_31_22_30_how_to_master_statement_management_in_fb_mode.html" name="如何搞定前后端一体的状态管理">如何搞定前后端一体的状态管理</a> ，基本思路是： 用一个 map 去保存状态，并对 map 的每个值添加监听器，如果操作了某个值，则对监听者发送事件通知。 基于此，在对特定的事件进行封装，就能实现多客户端拥有全局统一的状态了。</p><h2 id="简单思考"><a href="#简单思考" class="headerlink" title="简单思考"></a>简单思考</h2><p>这确实有一些实用价值。在协同场景下，这类需求还是存在的。</p><ol><li>没有 demo</li><li>没有进一步封装的 sdk</li></ol><h2 id="协同场景的简单思考"><a href="#协同场景的简单思考" class="headerlink" title="协同场景的简单思考"></a>协同场景的简单思考</h2><p>协同场景，简单来说，就是： 存在一个公共的资源，有多个用户可以对其进行操作。</p><p>最典型的场景是： 多人游戏、文档协作。 当然也有一些其他的场景，例如 在线协同设计、在线白板(教学、演示等)。</p><p>协同场景的基本逻辑，和上面做的 responsive map 是一样的，都是保证协同的多方所共同持有的那个公共资源拥有一致的状态。 而这个状态，可以是一个 map，也可能是其他数据结构，这是根据业务实际情况而定的。</p><p>为了实现协同，必不可少的步骤就是： 任意一方将状态更新时，都同步到其他方去。</p><p>因此，有两个隐形要求： ① 状态是能够传输的 ② 更新通知时能够及时发送的。 说人话一点大概是这样：</p><ul><li>状态的数据结构是可以被序列化的</li><li>需要一套消息系统将消息发送出去</li></ul><p>从工作职能上，我们可以按照上面的分析，划分成 <code>协同业务</code> 和 <code>消息系统</code> 两个部分。 协同业务 负责从业务角度 <code>设计数据结构</code> 、<code>协同事件序列化</code>、<code>协同事件处理</code>； 消息系统 负责从全局角度 <code>设计消息传输系统</code> 。</p><p>数据结构，目标是： 用符合资源模型的数据结构去描述共有资源。 这个跟业务强相关，姑且不描述了。</p><p>协同事件序列化，目标是：将当前操作变成能够通过网络传输的数据。</p><p>协同事件处理，目标是：将其他方发来的操作变动在自己的共有资源上进行还原。</p><p>一般来说，协同事件的传输内容有两个基本的方案： ① 同步操作。 ② 同步状态。 这两种方案均有其特点以及特定的应用场景。</p><p>例如，在一些棋牌类游戏中，由于公共资源的数据模型比较简单，因此，在任意游戏参与者做了操作之后，服务端都会把整个数据发送给各端。 比如，我打了一对 A，然后就剩下一张 3 了，服务器就会把当前所有牌的情况给各端发一次 (猜的，不一定真是这样啊)。</p><p>状态同步的缺点在于： 数据量大的时候会有性能问题。<br>状态同步的优点在于： 数据一致性很好保证。</p><p>因此，全量同步比较适用的场景是： 核心模型的数据结构不会特别复杂，对数据一致性要求很高。</p><p>而有一些场景下，数据结构十分复杂，每次全量同步就会存在性能瓶颈 (序列化瓶颈、网络瓶颈、反序列化瓶颈、diff 瓶颈)。 这种时候，就只能使用 <code>操作同步</code> 的方案。</p><p>操作同步，意味着在每次对资源进行操作时，把每个操作进行序列化，并把这些操作消息传输到其他端。 在接收到操作的端上，将操作反序列化后，把操作在本地进行 <code>回放</code>。</p><p>举个例子，我们假设有一个直播间，他的基本数据模型是一个 map ，例如是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;room_name&quot;</span>: <span class="hljs-string">&quot;first room&quot;</span>,<br>  <span class="hljs-attr">&quot;desc&quot;</span>: <span class="hljs-string">&quot;this is a test room&quot;</span>,<br>  <span class="hljs-attr">&quot;picture&quot;</span>: <span class="hljs-string">&quot;https://xx.xx.com/xxxxxxx.jpg&quot;</span>,<br>  <span class="hljs-attr">&quot;room_detail&quot;</span>: &#123;<br>	  <span class="hljs-attr">&quot;user_counts&quot;</span>: <span class="hljs-number">2</span>,<br>	  <span class="hljs-attr">&quot;users&quot;</span>: [&#123;<br>		  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;user001&quot;</span>,<br>		  <span class="hljs-attr">&quot;avatar&quot;</span>: <span class="hljs-string">&quot;https://xx.xx.com/xxx001.jpg&quot;</span>,<br>		  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;001&quot;</span><br>	  &#125;,&#123;<br>		  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;user002&quot;</span>,<br>		  <span class="hljs-attr">&quot;avatar&quot;</span>: <span class="hljs-string">&quot;https://xx.xx.com/xxx001.jpg&quot;</span>,<br>		  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;002&quot;</span><br>	  &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个用户对将这个房间的 desc 进行了修改，这将会产生这样的 option：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>	<span class="hljs-attr">&quot;desc&quot;</span>: <span class="hljs-string">&quot;this is a very fantastic room !&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者，你也可以做一层封装，类似于这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>	<span class="hljs-attr">&quot;desc&quot;</span>: &#123;<br>		<span class="hljs-attr">&quot;operation&quot;</span>: <span class="hljs-string">&quot;update&quot;</span>,<br>		<span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;this is a very fantastic room !&quot;</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际操作的数据结构设计，是跟业务直接相关的，不同的业务会有不同的设计，这里就只是举个例子。</p><p>这种操作同步的方案，优点在于： 传输的数据轻量，能支持比较复杂的数据模型。<br>缺点在于： 数据一致性比较难保证。</p><p>当下比较火热的协同产品，大都是比较复杂的数据模型，基本都选择了这类操作同步的方案。比如 在线文档。</p><h2 id="数据一致性的一些方案"><a href="#数据一致性的一些方案" class="headerlink" title="数据一致性的一些方案"></a>数据一致性的一些方案</h2><p>上面我们有讲到，使用 <code>操作同步</code> 的方案，会有数据一致性的问题，那么，我们一起来看一下数据一致性一般有哪些常规方案。</p><p>解决数据一致性的问题，可以分成两类场景：</p><ol><li>单主模型</li><li>多主模型</li></ol><p>单主模型下，出现数据一致性问题的主要场景就是 <code>事务</code>，通常是直接通过加锁实现，差别基本只存在于锁类型。</p><p>多主模型是数据一致性的重灾区，一般来说，可以有这些方法：分布式锁、共识算法、OT (操作转换)、CRDT(无冲突复制数据类型) 。</p><p>在协同操作的场景中，由于对响应速度的追求是很高的，因此最终会走上 <code>多主模型</code> 的 OT 和 CRDT 的方案。由于 OT 有一些不好解决的缺陷，因此 CRDT 成为众多协同产品的技术实现方案。CRDT 的介绍，可以看<a target="_blank" rel="noopener" href="https://www.zxch3n.com/crdt-intro/crdt-intro/">这篇文章</a> ，里面的连接挺全。</p><blockquote><p>关于 yjs 的介绍，可以参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/452980520">Yjs实现</a></p></blockquote><h2 id="vue-socket-io-的发现"><a href="#vue-socket-io-的发现" class="headerlink" title="vue-socket.io 的发现"></a>vue-socket.io 的发现</h2><p>在看 socket-io 的过程中，看到了一个有意思的项目： <a target="_blank" rel="noopener" href="https://github.com/MetinSeylan/Vue-Socket.io">Vue-Socket.io</a> , 这个项目在 github 上的赞是有 3.9k 的 (2022/11)，其相关项目 <a target="_blank" rel="noopener" href="https://github.com/probil/vue-socket.io-extended">vue-socket.io-extended</a> 的点赞也达到了 600+ 。</p><p>前者的功能是很简约的，仅仅提供了接收事件的能力，一定程度上封装了 vue store 的 mutation 能力。</p><p>后者在实现上，封装了 vue.Use 用法，写法上更抽象一些，最大的优点在于 提供了 类型，对于开发是很友好的。</p><p>这两个项目其实都是比较简单，但不妨碍很多人对其点赞，因为这对前端同学来说，实现了很有想象空间的能力。所有，对于一个项目而言，评判的标准并不是项目有多复杂，而是这个项目有什么价值？实现了什么能力？占据了什么生态位？</p><p>另外提一嘴，一个后起的项目，如果没有一些强痛点的突破，一般很难发展起来，这是由于生态位被占据了。 但 vue-socket.io-extended 这个项目算是起来了，我归结其原因有 2 ： ① 类型提示，开发更友好 ② 文档齐全，demo 很多。 整体来说，<code>用户友好</code> 算是可以和 <code>生态位</code> 匹敌的因素了。</p><p>vue-socket.io 能解决的问题是：</p><ul><li>将本地事件发送到其他客户端</li><li>接收其他客户端发来的事件</li></ul><p>事件本身可以作为需要传递的东西，用于在多端间进行一些操作触发，例如，在一个直播间里，一个用户操作了 <code>鼓掌</code>，该事件在其他端也可以同步进行动画效果展示。</p><p>事件还可以和 状态 相关联，这类事件 专门为 修改状态 服务，上面这两个库核心能力就是将 socket.io 这个事件传输机制 和 vuex 这个状态管理器 结合。</p><p>状态能相互关联了，想象空间就更大了。 一个 app 的各项能力，实际都是有其数据模型的，模型和展示之间存在着绑定关系 (中间一般挡着一些业务逻辑)，那么，一个供多方使用的功能模块，只要在设计时，就按照多用户使用的场景进行建模，那么就能实现一个用户对自己客户端 model 的修改，也同步到其他端。</p><p>这样的好处是，开发多用户功能时，不用以全局的、通过网络通信的视角看待系统，只需将系统看做一个本地多用户系统即可，在降低开发者心智负担上，还是有不少的价值。</p><p>上面的两个库，实现了前端的 vuex 和 事件接收和发送的打通。在真实应用中，一些简单的场景可以直接使用，例如，一个聊天室中，<code>房间人员</code> 和 <code>房间消息</code> ，这种基本只有 <code>append</code> 和 <code>del</code> 操作的类型，在不考虑严格的顺序情况下，就可以使用。</p><p>那么，如果对于 <code>大家都会操作</code> 的场景，或者有比较严格的 <code>消息顺序</code> 的场景，还是否适用呢？</p><p>这就涉及到协同冲突的问题了。</p><h2 id="协同冲突问题"><a href="#协同冲突问题" class="headerlink" title="协同冲突问题"></a>协同冲突问题</h2><p>多端协同，每一端都拥有一份模型数据的拷贝，且每端都能对模型数据进行操作，那么，在操作的时候，由于有网络传输的存在，就有可能出现 客户端 A 操作了资源 x，然后操作开始往 客户端 B 传输，还没传输到的时候，客户端 B 也操作了 x，并且向 A 发送操作。 当双方都收到操作后，就变成了两个客户端的数据不一致了。</p><p>这种多端协同时，会产生各端数据不一致的情况，就叫做协同冲突。</p><p>处理冲突的方式一般有两种模式： 集中式 和 分散式。 集中式的代表是 OT，中文翻译为 <code>操作转换</code>，处理逻辑是，由中央程序来确定该给协同各方回复什么消息。优点是，数据结构简单明了。缺点是，场景复杂了之后，需要做的操作转换就非常复杂，开发上容易出错。</p><p>最常被举例的场景就是 <code>文档协同</code>，例如一段文字 <code>abc</code> A 操作了 <code>删除1上的值a</code> 预期是 <code>bc</code>，同时 B 操作了 <code>在2的位置增加x</code> 预期是 <code>axbc</code>， 如果直接把 A 的操作给到 B，就会在 B 处变成 <code>xbc</code>，而 A 处就会变成 <code>bxc</code> ，两边就不一样了。 而 OT ，可能会把给 A 的操作变成 <code>在1的位置增加x</code>，A就成了 <code>xbc</code>，相当于处理了冲突。</p><p>上面是对于数组型顺序冲突的处理。 还有一些其他数据类型的冲突，例如 map。</p><p>另一种分散式的冲突处理方式，典型是 CRDT，这是一种通过在数据结构上下功夫，实现分散式协同过程中保持一致性的一种方案，典型的数据结构设计方案可以参考 Yjs 的实现。</p><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><ol><li>跑通流程</li><li>协同冲突的问题</li><li>封装 sdk</li><li>内网网络性能量化评估</li><li>设计好的接口 几乎是写一个库最有价值的内容！！！ 这就是 <code>建模</code> 的核心。这是软件工程师的核心技能之一。</li></ol><hr><blockquote><p>I will not be concerned at other men’s not knowing me; I will be concerned at my own want of ability.<br>— <cite>Confucius</cite></p></blockquote></div><hr><div><div class="post-metas mb-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/longblog/tags/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/">异步通信</a> <a class="hover-with-bg" href="/longblog/tags/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F/">消息系统</a> <a class="hover-with-bg" href="/longblog/tags/%E5%8D%8F%E5%90%8C/">协同</a> <a class="hover-with-bg" href="/longblog/tags/cooperation/">cooperation</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/longblog/posts/22_11_03_12_04_are_you_the_same_as_yourself_half_year_before.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">你还是半年前的你吗？</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/longblog/posts/22_11_01_13_46_review_of_mess_system_generation_zero.html"><span class="hidden-mobile">零号机之后的反思</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">备案: 粤ICP备2020131301号</a></span></div></footer><script src="https://static.longalong.cn/packages/blog/nprogress.min.js"></script><link rel="stylesheet" href="https://static.longalong.cn/packages/blog/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://static.longalong.cn/packages/blog/jquery.min.js"></script><script src="https://static.longalong.cn/packages/blog/js/bootstrap.min.js"></script><script src="/longblog/js/events.js"></script><script src="/longblog/js/plugins.js"></script><script src="/longblog/js/img-lazyload.js"></script><script src="https://static.longalong.cn/packages/blog/tocbot.min.js"></script><script src="https://static.longalong.cn/packages/blog/jquery.fancybox.min.js"></script><script src="https://static.longalong.cn/packages/blog/anchor.min.js"></script><script defer src="https://static.longalong.cn/packages/blog/clipboard.min.js"></script><script src="/longblog/js/local-search.js"></script><script src="https://static.longalong.cn/packages/blog/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/longblog/static/js/showiframe.js"></script><script src="/longblog/js/boot.js"></script></body></html>