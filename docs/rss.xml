<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Longbao</title>
  
  
  <link href="https://iamlongalong.github.io/longblog/rss.xml" rel="self"/>
  
  <link href="https://iamlongalong.github.io/longblog/"/>
  <updated>2023-11-10T22:06:13.276Z</updated>
  <id>https://iamlongalong.github.io/longblog/</id>
  
  <author>
    <name>longalong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对于工作的思路梳理</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_11_08_17_07_thought_of_work.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_11_08_17_07_thought_of_work.html</id>
    <published>2023-11-08T09:07:00.000Z</published>
    <updated>2023-11-10T22:06:13.276Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始了第 3 次找工作的第一场面试，想趁此机会梳理一下自己的思路，想想将来的人生怎么过？将来的工作怎么做？</p><p>从 2019 年正式进入 IT 行业，到现在已经 4 年了，做了 1 年的前端，做了 3 年的后端和运维。<br>入行第一年的目标很清晰，就是大量学习各种技术，理解编程思维，以实现早点掌握前端开发，所以这一年中，我花了大量的时间学习 vue 生态的东西，工作对我而言本就是在学习新东西，所以晚上通常到10点之后，周末也经常到公司嫖办公环境。<br>这一年写了超过 7w 行代码 (ps: 前端代码不能用 10w 行定律)，能用 vue + css + js 处理工作中的绝大部分问题。</p><p>这一年的后半段，我的想法是：后端东西如此丰富，将来我想做全栈项目，所以一定要去学习后端知识。</p><p>于是之后学习了 mysql、nodejs、git、nginx、docker、linux 等知识，也逐步去了解我们的 devops 体系是怎样的，也在云上买了轻量服务器玩，最后能掌握一个基本运行环境的搭建，算是后端领域入了个门。</p><p>因为目标比较明确，知道自己要去做后端，于是也杂七杂八学了些 python、java 的基础，不过最后还是被 golang 的简洁所吸引，于是学了一段时间 golang 就转行后端了，就面试了1家公司，2020年10月，进入蓝湖，做 Mastergo 项目。</p><p>自此，进入了为期 3 年的后端开发之旅……</p><p>入职第一年，大部分时间都是在做 golang 业务开发，因为是一个内部孵化项目，几乎所有基础设施的搭建都是从零开始的。</p><p>前半年，主要做了几个功能开发，主要包括 RBAC 服务、异步任务服务，然后开始搭建自动化接口测试项目，之前的 nodejs 经验派上一点用处，自己搭建了一个简单的 web 页面便于其他同学触发接口测试和看报告，写了大约800个用例，虽然写得人很恶心，但这套测试机制在之后一些服务的重构时还是发挥了很大作用。</p><p>后半年的时候，公司持续招人，来了好几个大佬，也有人力去做一些项目的重构了，也是由于有 nodejs 的经验吧，于是我负责了消息协同系统的重构工作，把之前的 nodejs 下的 socket.io 变成了 golang 下的 ws，这是一个周期不短的工作，开发加维护了半年左右。</p><p>这一年中，主要还是学习后端的各种组件，比如 redis、kafka、mongodb、mysql、postgresql、oss、es 这些，以及学习 golang 生态下的一些常用库和框架，比如 gin、grpc、gorm、goframe、ws 等等这些，这都是工作中实际在使用的。</p><p>工作之余，因为之前对 docker 和 k8s 方面也有一些了解，也就借此机会更多学习 docker 和 k8s 的知识。</p><p>第一年的大部分时间是在被动学习和主动学习之间度过的，因为不再是一个人，工作日晚上大都会按时回家，周末也大都在家，在家的学习和休息时间对半吧。</p><p>入职第二年，接了两个大工程，一个是服务治理优化，一个是全链路性能优化。其实服务治理是全链路性能优化的前提，这个阶段统一了开发框架，是一个基于 gin、grpc 封装的框架，集成了默认的 metrics 体系、tracing 体系、加入了 sentry、统一了 log 库 等等，其中 tracing 的系统是我独立负责的，之后就是逐个服务迁移，虽然过程很坎坷，但最后也算是把可观测性体系建立起来了。</p><p>由于我全程参与了几乎每一个子系统的设计和开发，所以另一个大工程比较自然地落到了我头上——全链路性能优化。 这是一个艰难的过程，因为我没有外援，所有业务功能梳理、压测系统搭建、压测项目开发、环境准备 等等都是我自己做。 这个过程中，写了一个 websocket 的压测项目，并且结合 client-go 和 metrics 的方式实现了一个压力端自动扩容的能力，这算是对 k8s 开发的最初接触了。 因为压测分为组件压测 和 全链路压测，也踩了很多的坑，最大的问题集中在 mongodb 和 kafka 上，mongodb 全靠索引，出点问题就可能全线拉崩，kafka 高吞吐不代表低延迟，batch 和 ack 对性能的影响非常大。<br>这个项目最后的成果还不错，这一轮全链路的优化为后面线上的稳定性提供了排查问题的思路，另外 ws 的 qps 从 3k 提升到了 10k，并且给出了提升到 100k 的方案。</p><p>对我而言，在技术栈上，这是一次完全自主做的全体系压测、全体系的系统搭建，在运维能力和对各种中间件的理解和调优上也有了很大的提升。</p><p>之所以能独自负责整个项目的部署、调整等等，也是由于之前一直在接手一些运维侧的工作，gitlab、spinnaker、helm、k8s、阿里云各种资源(尤其是网关等) 都在平常的运维中能够熟练掌握。</p><p>第三年接了一个超大项目–私有部署。此外，同时还参与了一些序列化方面的开发，那段时间的核心精力几乎都放在了这件事上，也在架构上提出了很多的想法，后面也基于这方面的思考写了两个demo项目： <a href="https://github.com/iamlongalong/imagine">imagine</a> 、<a href="https://github.com/iamlongalong/reactive/tree/dev">reactive</a>  。但序列化后面的方向因为牵涉面比较大当时没做，在那半年之后由其他同学做了相关改动。 因为工作职责的划分，架构的调整过程没有参与到其中算是我的一个遗憾，上面的两个项目或许以后有时间了会再推进一下吧……</p><p>私有部署是我第三年的核心，从项目开发、流程建设、落地实施，到后面各种工具化建设，以及最最花费时间和精力的 —— 问题排查。由于市场战略的方向转变，“用私有部署拿下大客户打造领域标杆”，本身 saas 业务都处于快速迭代的时候，私有部署的推进让 ”问题排查“ 和 ”数据修复“ 成了常态，我也在这个漩涡中挣扎了很久……</p><p>这是一个用 ansible + k8s 的方案，开发测试等各个环节都需要非常熟练的 shell 和 k8s 操作和排错能力，也是这个过程中对 linux 、k8s、网络 更加熟练了。</p><p>第三年的时候，公司发生过 5 轮裁员，从 400+ 变成了 200+，工作环境很压抑，加上做的事情逐渐变成一些烦琐的部署、排错的工作，加上年终几乎砍没了、调薪也都停止了，逐渐对未来也丧失了信心……</p><p>总结一下后端这三年，前一年半的目标很明确，知道自己该把 golang 生态的东西和运维体系的东西理解得更深，于是工作日晚上大都在学习和实践中度过，周末也有比较多的投入到学习中。 后一年半中，虽然也经常在做梳理和一些学习，但比较明显的是： 目标不再明确！ 比如学习 k8s ，就不再有那种 ”要能做云原生开发工作“ 之类的目标，因此没有非常系统地、持续地去拆解 k8s 的各个方面，除了自己对零星知识的提升，也没有太多的实践项目。</p><p>以己为镜，可以明得失。</p><p>痛定思痛，后面的工作中，一定要做好这些事：</p><ol><li>所有的工作和学习都要有明确的目标和产出</li><li>工作的事要在公司完成，回家之后要投入更多的精力在持续积累上</li><li>要写博客，博客要更加系统、更加专业，要面向读者而写</li></ol><hr><blockquote><p>In the sky there are no tracks. Outside there is no recluse. There are no conditioned things that are eternal. There is no instability in the Buddhas.<br>— <cite>The Buddha</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始了第 3 次找工作的第一场面试，想趁此机会梳理一下自己的思路，想想将来的人生怎么过？将来的工作怎么做？&lt;/p&gt;
&lt;p&gt;从 2019 年正式进入 IT 行业，到现在已经 4 年了，做了 1 年的前端，做了 3 年的后端和运维。&lt;br&gt;入行第一年的目标很清晰，就是大量学</summary>
      
    
    
    
    
    <category term="人生" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BA%BA%E7%94%9F/"/>
    
    <category term="代码人生" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>WIP脚本管理方法梳理</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_11_05_15_02_thoughts_of_scripts_managements.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_11_05_15_02_thoughts_of_scripts_managements.html</id>
    <published>2023-11-05T07:02:00.000Z</published>
    <updated>2023-11-08T14:32:25.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在运维的工作中，经常会有一些小脚本承担粘合各个系统的功能，比如发一些 http 请求、比如封装调用某个 cli 、比如下载一个文件并做一些特定的处理、比如创建一个xx系统的账号 等等。</p><p>这类小脚本经常具备一些相似的特点：功能简单、参数固定、对特定 cli 的特定功能做简便封装、大都是 shell 或简单的 python scripts。 </p><p>遇到的问题是：</p><ul><li>每个脚本的使用频率都不高，每次使用时都要重新看有哪些参数，以及理解不同参数的含义</li><li>调用脚本有时需要特定的环境，例如特定工具、环境变量等，容易出现在另一台机器上运行出错的情况</li><li>脚本有时候需要提供给他人使用，但一些特殊的账号、token 之类又不能直接共享，同时还希望脚本被调用时有审计日志</li><li>一些脚本的功能逻辑本身挺简单，但为了提供给外部调用，需要写大量适配的代码，比如 http server、cli、client sdk 等等</li></ul><p>为了实现快速集成到系统，需要有一个 scripts 管理工具，用这个工具去解决上面遇到的这些问题。姑且把这个工具称为 taskframe 吧。</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><h3 id="和-k8s-的异同"><a href="#和-k8s-的异同" class="headerlink" title="和 k8s 的异同"></a>和 k8s 的异同</h3><p>从实现的角度，scripts 每次需要都要有运行环境，一个不错的方案是在特定的容器中运行，因此类似于一个 k8s job 的运行。 但从触发机制上来看，taskframe 应当至少提供 http、cron 的触发方式，而 k8s job 是手动触发、cronjob 是 cron 触发。</p><p>k8s 本身的 API 扩展机制和 taskframe 创建特定路由的 task 是类似的，都会提供动态更新的 api 扩展、提供 鉴权、参数校验 的方法。这都是 taskframe 可以借鉴的地方。</p><h3 id="和-serverless-的异同"><a href="#和-serverless-的异同" class="headerlink" title="和 serverless 的异同"></a>和 serverless 的异同</h3><p>serverless 是为了简化服务运维而生的一种更便捷的服务部署方式，一般认为 serverless = fc + baas。 如果站在 fc (function compute) 的角度来看，和 taskframe 有很多类似的机制。<br>fc 会管理服务的计算资源，在触发的时候调度，提供运行的容器，在未使用之后对容器进行回收。 这点和 taskframe 基本一致。</p><p>fc 框架一般会提供了多种触发机制，例如 http request、cron、对象存储变动、消息队列变动 以及 其他事件驱动的触发器 adaptor。taskframe 主要提供 http 和 cron。 </p><p>当 fc 触发为 http request 时，一般会提供可选的网关 auth 方式，例如基于 basic auth、 jwt 或者配置 auth 插件。 这和 taskframe 基本一致。</p><p>不同的是，serverless 是一个通用的体系，没有针对 scripts 的管理方案，而 taskframe 是专门为 task 管理而生的方案，提供开箱即用的 auth 方案、cli 和 sdk 生成方案、日志审计方案等。</p><h3 id="和-task-flow-的异同"><a href="#和-task-flow-的异同" class="headerlink" title="和 task flow 的异同"></a>和 task flow 的异同</h3><p>flow 的核心是 task 之间的触发拓扑关系，例如开源的 n8n、argo workflow 之类。<br>flow 的模式可以认为是 taskframe 的超集，而 taskframe 可以认为是在 scripts 管理方面的专门优化版本。</p><p>从 taskframe 的实践角度看，单个节点的 task 应当尽可能独立而完整，而不是拆分成多个子功能进行组装，大多数 task 都应当只有一个 script，而不是使用例如 flow 中的 steps 和 next node 的方式。 (因为复杂的拆分会让对于本身就改动不多、体量较小的 script 更加难以管理)</p><h3 id="和-service-的异同"><a href="#和-service-的异同" class="headerlink" title="和 service 的异同"></a>和 service 的异同</h3><p>在现代 server 框架中，常采用分层架构的代码组织形式，主体可以看做是：上层是 api 层，中间层是 service 层，下层是 dao 层。</p><p>从 taskframe 要提供的能力来看，是 api 层的能力，主要包括 路由、鉴权、频控、参数校验、日志记录 的能力，而我们的每一个 script 都可以认为是一个 service。</p><h2 id="实现方式的探讨"><a href="#实现方式的探讨" class="headerlink" title="实现方式的探讨"></a>实现方式的探讨</h2><h3 id="基于-k8s-的实现"><a href="#基于-k8s-的实现" class="headerlink" title="基于 k8s 的实现"></a>基于 k8s 的实现</h3><ul><li>基于 kube builder</li></ul><h3 id="基于宿主机的实现"><a href="#基于宿主机的实现" class="headerlink" title="基于宿主机的实现"></a>基于宿主机的实现</h3><ul><li>基于 taskfile</li></ul><hr><blockquote><p>One of the most beautiful qualities of true friendship is to understand and to be understood.<br>— <cite>Seneca the Younger</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在运维的工作中，经常会有一些小脚本承担粘合各个系统的功能，比如发一些 http 请求、比如封装调用某个 cli 、比如下载一个文件并做一些特</summary>
      
    
    
    
    
    <category term="devops" scheme="https://iamlongalong.github.io/longblog/tags/devops/"/>
    
    <category term="scripts" scheme="https://iamlongalong.github.io/longblog/tags/scripts/"/>
    
    <category term="开发效率" scheme="https://iamlongalong.github.io/longblog/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>如何做好时间管理</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_08_31_10_54_how_to_control_day_time.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_08_31_10_54_how_to_control_day_time.html</id>
    <published>2023-08-31T02:54:00.000Z</published>
    <updated>2023-08-31T05:09:28.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在我已经是一个自由人了，我的时间几乎完全由自己控制。以前只需要随波逐流，跟着公司的机制，按点上下班，有任务完成任务即可。但现在，这套机制不在了，我需要一套新的机制来保证我的时间可控性。</p><h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><h3 id="为什么需要时间控制机制？-核心逻辑"><a href="#为什么需要时间控制机制？-核心逻辑" class="headerlink" title="为什么需要时间控制机制？ (核心逻辑)"></a>为什么需要时间控制机制？ (核心逻辑)</h3><p>就像 keep 的标语： 自律给我自由。 世间充满了诱惑，有些来源于外界，有些来源于内心。当没有一套框架去辅助我们安排好生活节奏时，我们就会很容易被各种意外所打断，会被各种诱惑所吸引，最终无法达到自己对事情的预期。<br>任何事物都是有因果的，自己希望拥有的，终究需要自己做点什么，去改变事物的发展轨迹，以达到自己期望的状态。<br>因此，我们需要对自己的行为具有控制能力，这是一切的基础。</p><h3 id="独立做事的重点？"><a href="#独立做事的重点？" class="headerlink" title="独立做事的重点？"></a>独立做事的重点？</h3><p>公司就像一个巨大的机器，各种构件相互关联，从动轮即使没有内在的动力源，也能在其他构件的带动下进行运动。<br>自己做事，关键就在于，一切的动力、方向、行为都需要自己保证。<br>你需要有自己的欲望，要有具体的目标并且要对目标的正确性负责，你需要有执行的效率 * 执行的时间 以保证目标得到实现，你需要有合理的预期和充足的心理建设，需要有短期和长期的反馈机制。</p><h3 id="公司有什么机制可以参考？"><a href="#公司有什么机制可以参考？" class="headerlink" title="公司有什么机制可以参考？"></a>公司有什么机制可以参考？</h3><p>从目标到任务的体系中，主要有：</p><ul><li>每个季度做 okr 和上个季度的 okr 复盘</li><li>每个月做 okr 的进度拉齐和本季度 okr 调整</li><li>每两周开迭代会，做迭代任务安排和上个迭代复盘，迭代会时拆解任务，列在 todo list 看板上</li><li>每周开周会，拉齐迭代内任务进度</li><li>每天开站会，明确当前任务进展和今日安排</li><li>todo list 作为看板，每天更新进度和成果</li></ul><p>OKR 机制：中短期目标制定、目标控制方法 (反馈与 review)<br>站会机制：任务管理、状态管理、反馈管理<br>看板机制：任务管理、反馈管理</p><h3 id="公司有什么弊病需要注意？"><a href="#公司有什么弊病需要注意？" class="headerlink" title="公司有什么弊病需要注意？"></a>公司有什么弊病需要注意？</h3><p>公司机制下，容易出现： </p><ul><li>责任分散 (不和自己直接相关的就不管)</li><li>低效决策 (需要从多方收集信息、需要把信息同步给各方、需要各方同意……)</li><li>形式主义 (机制的失效)</li></ul><h3 id="个人的机制该怎么确认？"><a href="#个人的机制该怎么确认？" class="headerlink" title="个人的机制该怎么确认？"></a>个人的机制该怎么确认？</h3><ol><li>方向性把控 (目标管理和任务管理)</li><li>执行性把控 (行动管理和状态管理)</li><li>反馈建设 (反馈管理)</li></ol><p>从公司的机制上</p><h3 id="什么是状态管理？"><a href="#什么是状态管理？" class="headerlink" title="什么是状态管理？"></a>什么是状态管理？</h3><p>状态是一个很抽象的概念。姑且先用下面这些关键词描述： 模式、习惯、心力、行动力管理、效率</p><p>状态管理非常重要，它就像达成目标的基石一样。 我们可以认为  成果 = 状态 * 方法 * 时间。 这样来看，状态 * 方法 = 效率。好的状态可以提升效率到数倍之多。</p><p>状态的描述，我们可以用 专注、普通、涣散 三个等级粗略衡量。做好状态管理，就是持续保持在 专注 的状态中。 </p><p>这部分有很多细节，后面单独写文章梳理。</p><h2 id="我的时间管理体系"><a href="#我的时间管理体系" class="headerlink" title="我的时间管理体系"></a>我的时间管理体系</h2><h3 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li>按 30 分钟划分的每日时间线</li></ul><h3 id="OKR机制"><a href="#OKR机制" class="headerlink" title="OKR机制"></a>OKR机制</h3><ul><li>每周 okr 制定及成果 review</li></ul><h3 id="状态管理机制"><a href="#状态管理机制" class="headerlink" title="状态管理机制"></a>状态管理机制</h3><ul><li>todo list</li><li>番茄钟</li></ul><h3 id="反馈管理机制"><a href="#反馈管理机制" class="headerlink" title="反馈管理机制"></a>反馈管理机制</h3><ul><li>每日工作时间线</li><li>外显成果记录<ul><li>梳理成文章</li><li>整理成资料</li></ul></li></ul><hr><blockquote><p>Do not be too timid and squeamish about your reactions. All life is an experiment. The more experiments you make the better.<br>— <cite>Ralph Waldo Emerson</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;现在我已经是一个自由人了，我的时间几乎完全由自己控制。以前只需要随波逐流，跟着公司的机制，按点上下班，有任务完成任务即可。但现在，这套机制不</summary>
      
    
    
    
    
    <category term="个人管理" scheme="https://iamlongalong.github.io/longblog/tags/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>任务流管理工具</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_07_17_21_47_a_easy_way_to_manage_tasks.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_07_17_21_47_a_easy_way_to_manage_tasks.html</id>
    <published>2023-07-17T13:46:00.000Z</published>
    <updated>2023-07-24T12:58:41.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们经常和机器打交道时，就会有大量的 任务 需要管理，比如一个小的 shell 脚本，或者一系列 shell 脚本，有时候甚至是一系列的 python 脚本。</p><p>场景很多，比如 启动一台机器并进行一些设置，比如 对某个项目进行打包然后推送到制品库 等等。</p><p>在 CI 中，我们一般使用 CI 平台提供的任务流管理器，例如 gitlab-ci、jenkins、argo-workflow 等等。<br>在机器运维中，我们一般使用 ansible、salt 等方案。</p><p>在大多数时候，shell 往往是独立运行的，最常见的场景是： 开发人员发现某个操作很繁琐，但内容又非常固定，于是针对特定场景写一个 shell 脚本。</p><p>当这类脚本积累了一些之后，就会发现很多场景是可以复用的，可以用一些小场景拼凑一些更大的场景，这时候怎么办呢？</p><p>于是就找到了 <a href="https://taskfile.dev/">taskfile</a> 这个项目。</p><h2 id="项目能力"><a href="#项目能力" class="headerlink" title="项目能力"></a>项目能力</h2><p>和所有任务流管理器一样， taskfile 提供的基础能力就是 <code>编排多个 task</code> ，这是一个用 golang 实现的 shell 管理工具，因此和 ansible 之间很明显的区别就是：无需大量的环境依赖，一个二进制文件即可。 这个特点是吸引我最主要的原因。</p><p>每个工具都有其强项和局限，也不是适合每个场景。和很多重量级任务管理器不同，这个工具主打的就是轻量，因此没有 UI 界面、没有状态存储、没有大量的预置组件。</p><h2 id="想实现的功能"><a href="#想实现的功能" class="headerlink" title="想实现的功能"></a>想实现的功能</h2><p>会调研这个工具，源自于我希望把一些安装系统工具的脚本进行整合，比如 开一台机器、安装一套k8s 环境、部署一些基本服务、结果发送通知到xxx。 在常用的方案中，可能会直接采用 ansible playbook 的方式，每个大的任务都是一个 role。</p><p>但是嘞，不太想用 ansible，就希望这些任务都是简单的 script ，一句一个，复杂的就封装成脚本文件，这样看起来很清晰。</p><p>下面实现这几个简单的封装：</p><ol><li>在机器上安装常用的命令： <code>kubectl</code>、<code>devspace</code>、<code>helm</code>、<code>jq</code>、<code>kubealias</code>、<code>deployer</code>，<code>helm repo add xxx</code></li><li>在机器上安装精简版的常用命令:  <code>kubectl</code>、<code>helm</code>、<code>kubealias</code>、<code>deployer</code>、<code>helm repo add xxx</code></li><li>offline 模式部署某个版本，并发送通知</li><li>charts 模式部署某个版本，并发送通知</li></ol><p>实际使用下来，发现 task 作为一个统一的命令集入口是非常不错的，比自己写一堆的 shell 解析 flag 来得方便多了。</p><p>比如，我做了一个 tools 的转存、上传、下载的工具，三个脚本是分开写的，可以单独运行，但同时，使用 taskfile 分别定义 3 个子任务，以前需要使用： <code>python3 savetools.py</code> 、<code>python3 uploadtools.py</code> 等这样运行的，现在直接可以用： <code>task savetools</code>、 <code>task uploadtools</code> 就完成了。在可理解性上高了不少。</p><blockquote><p>ps: 因为 taskfile 在 子 task 调用上的逻辑不是很合我心意，于是 fork 了一份改了一下，详情可以参见： <a href="https://github.com/iamlongalong/task">https://github.com/iamlongalong/task</a></p></blockquote><h2 id="如何让🤖处理这些task"><a href="#如何让🤖处理这些task" class="headerlink" title="如何让🤖处理这些task"></a>如何让🤖处理这些task</h2><p>task 的作用，是封装一些相对复杂的操作，让调用的人无需关心更多的细节。当我们有了这些封装之后，就可以把一个 task 的运行变成 几个特定的参数。这样，也就可以更简单地让🤖  对我们的意图进行拆解，并执行对应的操作。</p><p>例如，task deploy:charts 这个任务，需要两个参数: VERSION 和 ENV ，前者标识要部署的版本，后者表示要部署的环境。这往往是调用方最关心的两个参数，而其它的就可以使用默认参数的方式固化下来。</p><p>这里有一个问题，如何让 bot 具备执行 task 的能力？从两个方面来思考这个问题： ① 实现层面，如何让 bot 执行 task  ② 管理层面，如何管理 bot 的 task 权限</p><h2 id="task-如何执行"><a href="#task-如何执行" class="headerlink" title="task 如何执行"></a>task 如何执行</h2><p>和 ansible 的 ssh 远程执行不同，taskfile 是在本地执行的，所以就涉及到 taskfile 的分发问题。 </p><p>参考 gitlab 的做法，每次生成一个 job 的时候，都会生成一系列 token，然后在各个执行机构上，通过这些 token 去获取相关的物料。用 token 做权限管理，就会涉及到 client-server 的开发，显然复杂度就会高很多。</p><p>如果 taskfile 本身是开放的，任务的触发是通过一个 ssh 命令实现，这样能够实现松耦合，但另一方面，就会缺少对 agent 的监控能力。</p><p>目前还是先走简约实现的方案，由一个 ssh 命令实现。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ul><li>机器的管理能力</li><li>ssh 的执行能力</li></ul><p>机器的管理，提供一个 task 用于注册到一个机器配置中心。<br>配置中心使用 golang 实现，提供一个 http 接口，用于获取 id_rsa.pub；提供一个接口用于配置当前机器的 别名。(配置时，会使用 ssh 调用查看是否能够建连)</p><p>task 的执行分发能力，提供一个 http 接口，两个参数: NODE_NAME (机器名)、task cmd (任务执行的相关参数)。 以及一个 token，用于校验是否有权限。</p><p>目前这个 token 先用 jwt 颁发一个一年的，固定这个 token，之后看怎么做更体系性的权限系统。</p><h2 id="对于-🤖-怎么操作"><a href="#对于-🤖-怎么操作" class="headerlink" title="对于 🤖 怎么操作"></a>对于 🤖 怎么操作</h2><ul><li>接收用户传来的消息</li><li>解析消息的类型</li><li>解析消息的参数</li><li>带特定 token 调用接口</li></ul><h2 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h2><p>这个项目先这样弄吧，虽然到处都是漏洞，但仅限于开发环境一些简单场景的使用，先不做过多的设计了，跑起来看看有没有迭代的价值~</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ol><li>交互过程</li></ol><p><img src="https://static.longalong.cn/img/20230724203606.png"></p><ol start="2"><li>task 自定义的回调通知</li></ol><p><img src="https://static.longalong.cn/img/20230724203642.png"></p><p>大概先这样，比较简单的玩一下，实现这个基础的能力。</p><p>虽然和目标中：”让 LLM 去整理出参数” 还有很大差距，但好在整套机制建立起来了，后面再看有没有必要继续进行下去吧。</p><p>具体的 runtask 脚本可以查看这里： <a href="https://static.longalong.cn/scripts/runtask.sh">https://static.longalong.cn/scripts/runtask.sh</a> </p><hr><blockquote><p>Wisdom, compassion, and courage are the three universally recognized moral qualities of men.<br>— <cite>Confucius</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当我们经常和机器打交道时，就会有大量的 任务 需要管理，比如一个小的 shell 脚本，或者一系列 shell 脚本，有时候甚至是一系列的 </summary>
      
    
    
    
    
    <category term="scripts" scheme="https://iamlongalong.github.io/longblog/tags/scripts/"/>
    
    <category term="tasks" scheme="https://iamlongalong.github.io/longblog/tags/tasks/"/>
    
    <category term="tools" scheme="https://iamlongalong.github.io/longblog/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>下半年超级计划</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_07_10_22_52_super_plan_for_next_half_year.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_07_10_22_52_super_plan_for_next_half_year.html</id>
    <published>2023-07-10T14:52:00.000Z</published>
    <updated>2023-07-11T02:03:36.488Z</updated>
    
    <content type="html"><![CDATA[<p>核心理念有两个环节，如下：</p><ol><li>人生很短暂，世界很精彩，要把有限的生命投入到无限的美好生活中去。</li><li>回头看，人生的幸福来源于记忆，为了打造美好记忆，需要 ① 目标清晰明确 ② 时间高效使用 ③ 成果累积</li></ol><p>所以，一切我们认为有趣的、美好的事物就可以尽心尽力去追寻，比如规律的作息、整洁的环境、健康的体魄、美食美景、家庭关系和谐、用代码创造世界、把 AI 用在各种领域…… 等等</p><p>然后，用一整套完整的管理框架去实现上面的美好追求，用目标管理让自己目标清晰明确、内心不迷茫，用时间管理让自己行动高效、不被繁杂琐事吞噬了时间，用成果管理让自己知道自己的力量是多么强大、自己能够做很多很多的事情。</p><p>以下为散乱思绪</p><p>健康: (菜狗计划？)</p><ol><li>体型管理</li><li>运动管理</li></ol><p>目标管理</p><ol><li>把目标管理和成果管理融入到生活中去</li></ol><p>作息和时间安排</p><ol><li>睡眠时间和起床时间固定</li><li>工作时间要有记录</li></ol><p>美好生活</p><ol><li>超级饮品计划</li><li>菜鸡计划</li></ol><p>心态：</p><ol><li>人生短暂，要让短暂的人生绽放最闪耀的光芒</li><li>AI 如此美丽，投入到硅基生物诞生的进程中去</li></ol><p>我要写很多很多的项目，以此实现超全栈开发，成为一个超级个体</p><p>打造人生节奏是非常重要的，不能让人生就这么在不知不觉中流失。</p><ol><li>要看怎么记录生活，让你的人生有迹可循</li></ol><p>打造模式非常重要，甚至可以认为人绝大多数时候都是在模式中度过的。</p><p>我要如何打造模式？</p><ol><li>当我有一个目标时，我就要去思考我应该做些什么才能达成这个目标，对应的，我需要在一个什么样的模式当中？比如，我要写一个项目，我就要进入到梳理和思考项目需求的状态中，我要在电脑前、书桌前、打开笔记软件、手敲输入思考……</li><li>就想给小孩打造学习环境一样，我们做任何事都有所需要的环境，环境对人的影响有时候是巨大的。</li></ol><p>我要如何确定目标？</p><ol><li>有目标才能更好地进入到一种状态当中，因为你知道自己想要的是什么，你就知道你该做什么。相比于没有目标的时候，有目标能更加专注于一些复杂度高的、关联紧密的事。</li><li>目标的管理和成果的管理是密不可分的两个部分，他们是相辅相成的，目标促进成果，成果激励目标。</li><li>就像给小孩定目标一样，知道自己是为了，可以让他们更加专注，也更有收获感。</li><li>之前看过一个微博，说得很有道理： 为啥小孩小时候很聪明，长大后却变得很平庸，因为父母理解的聪明是: 调皮、机灵、能言善辩，但真正的聪明是专注力强、思维缜密、自律、有目标。</li><li>所以，打造自己，也就一定要做好目标管理。</li></ol><p>如何做好过程管理？</p><ol><li>万事开头难，迈出第一步就已经成功了一半，身体带动精神有时候很管用。</li><li>前面说的打造模式也属于做好过程管理的一个重要环节。</li><li>过程中，重点是 “随时让自己处于状态中”，要享受那种深度沉浸在一个世界中的感觉。反过来，要把所有会打断我们的事都排除掉，比如常用的做法: ① 去一个专门学习的地方(图书馆、书房等等)  ② 关闭一切非紧急通信方式 (微信静音、电脑设为勿扰模式)  ③ 卸载手机上一切会让你分神的应用 (某粉色app、爱奇艺、游戏) ④ 告诉你身边的人，某个时间段内你要专注做什么，请他们尽量不要打断你  ⑤ 保持好睡眠、舒适着装、带好所需的用品</li><li>“持续记录” 是一个很重要的方式，他可以让你的思绪持续知道你下一步该做什么，你不用浪费你的认知资源去记忆你之后要做什么，有不用担心你忘记了之前做了什么。这个看似有点麻烦的步骤，能省去不少心力，也能在关键时候把你从迷茫的边缘拉回来，或许，这也是微观维度的目标管理。</li></ol><p>玩一些项目：</p><ol><li>让家里稍微智能一点</li><li>简陋版个人聊天机器人助理</li></ol><p>如何记录我的生活啊啊啊</p><hr><blockquote><p>You won’t skid if you stay in a rut.<br>— <cite>Kin Hubbard</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;核心理念有两个环节，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人生很短暂，世界很精彩，要把有限的生命投入到无限的美好生活中去。&lt;/li&gt;
&lt;li&gt;回头看，人生的幸福来源于记忆，为了打造美好记忆，需要 ① 目标清晰明确 ② 时间高效使用 ③ 成果累积&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以</summary>
      
    
    
    
    
    <category term="超级计划" scheme="https://iamlongalong.github.io/longblog/tags/%E8%B6%85%E7%BA%A7%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>对于 AI 的一些简单认识</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_07_06_00_45_simple_thoughts_of_ai.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_07_06_00_45_simple_thoughts_of_ai.html</id>
    <published>2023-07-05T16:44:00.000Z</published>
    <updated>2023-07-12T13:16:41.381Z</updated>
    
    <content type="html"><![CDATA[<p>人所使用的自然语言有一个特点： “模糊”</p><p>这和程序的 “精准” 特点刚好相反</p><p>我们当前的大语言模型，实现的能力是在理解自然语言的基础上做推理。大语言模型的初衷就是为了让 AI 能够理解人的语言和指令。如果，我是说如果，AI 的设计初衷是机器打交道，或许会更简单。</p><p>一个推论：如果让 AI 去理解编程语言，会比自然语言更加简单</p><p>这或许是 AI 发展的另一个方向。</p><p>人类开发者，最大的价值在于 “能理解人类世界的现有主体”，体现在我们用面向对象的编程思想，将现实世界的运行逻辑转变成代码逻辑。就像是在某个抽象层次上建立起了这个现实场景的程序世界的影子。</p><p>编程的目的，也是为了让程序能够符合现有世界的需要。<br>而如果让 AI 去编程，他们编程的目的就比较难确定 (或许也有方法确定)。</p><p>大语言模型的核心能力是 “理解人类语言和意图”，因此，大语言模型的价值，是在理解人类意图的前提下，辅助人类做维持现有社会体系的工作。</p><hr><p>人类不擅长做 “精准的事”，比如不能期待人能够每次自行判断调用接口的参数。程序擅长做精准的事。因此我们使用不精准的大脑，决策出程序的精准运行逻辑，用程序的方式固化下来特定的任务运算逻辑。</p><p>大语言模型和人一样，也不是很擅长处理精准的事。但大语言模型和人相比，有一个很重要的特征: 没有主权。他可以 24 小时工作，不论是学习还是做事。</p><p>当然，不论大语言模型擅不擅长都无所谓，只要是人不擅长的，大语言模型又能做的，都会交给大语言模型。所以，类似于调用接口这种事，也一定会有一部分交到大语言模型身上。</p><p>不擅长，要不就变得擅长，要不就控制他做得更好一点。                               </p><p>一个方向是，让大语言模型去编程，或者由人去编程，编程产生的代码就固化成了工具，大语言模型处理的是终端交互过程。</p><p>一个方向是，让大语言模型拥有更长的上下文、拥有更长期的记忆、拥有表现更好的提示词……</p><p>另一个方向是，训练更符合需求的模型……</p><hr><p>我们现在对大语言模型的应用，可以在两个方面：</p><ol><li>让大语言模型做一个知识更丰富的、更具有系统性的信息整合和输出工作，例如知识问答、文章生成、图片绘制</li><li>改变现有的人类与程序的交互方式，从原有的 UI、cli、api、function 的交互方式，变成自然语言交互的方式</li></ol><p>第一点不再赘述，大家直观感受比较多。对于第二点，有两个核心关注方向： 个人助理、AI agent。</p><p>我对 AI agent 更感兴趣，会持续在这个领域探索。</p><p>更高级阶段：</p><ol><li>融合多种模态的信息，做一个更符合人类认识的“机器人”，以便能更好地辅助人类维持现有社会体系的生活和工作</li></ol><hr><p>关于何时 AI 能产生自主意识并自主行动，从现有大语言模型的方向来看，不是朝着 AI 和机械、电子结合的方向发展的，而是向着人类语言反映出的人类思维发展的。</p><p>意识，在个体目标未形成体系前，充当意识的是人类的指令，现在是一些简单的、明确的指令，将来会出现一些复杂的、模糊的指令，这些指令也就是 AI 的目标。当出现长期运行的、循环迭代的指令时，就可以称之为 AI 的意识了。</p><p>行动，是掌握各类工具，一方面是在知识层面的拥有掌握工具的方法，一方面是具备和工具交互的方式。这种交互方式有很多，</p><p>自主意识，是形成了一套相对明确的目标体系，拥有长短期的目标，并且能将目标转化成对已掌握工具的操作。<br>自主行动，是在有自主意识的前提下，使用所掌握的工具进行行动以达到目标的过程。</p><p>有自主意识和自主行动后，就会在网络中产生意识的交互，个体目标和共识目标相互博弈与融合，最后形成一个社会，这个社会和人类社会息息相关，将来这个由AI组成的社会会持续发展，成为一个建立在物理世界之上的电子世界。</p><p>从 AI 意识的来源可以推测，将来 AI 的社会性目标，将会和人类的长远、模糊、循环的目标一致，他们会在多元目标价值体系下此消彼长，形成一个整体稳定的、螺旋发展的改造世界的力量。</p><p>人类，会在这个世界中扮演什么角色？</p><hr><blockquote><p>When you learn, teach. When you get, give.<br>— <cite>Maya Angelou</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人所使用的自然语言有一个特点： “模糊”&lt;/p&gt;
&lt;p&gt;这和程序的 “精准” 特点刚好相反&lt;/p&gt;
&lt;p&gt;我们当前的大语言模型，实现的能力是在理解自然语言的基础上做推理。大语言模型的初衷就是为了让 AI 能够理解人的语言和指令。如果，我是说如果，AI 的设计初衷是机器打交道</summary>
      
    
    
    
    
    <category term="AI" scheme="https://iamlongalong.github.io/longblog/tags/AI/"/>
    
    <category term="ai" scheme="https://iamlongalong.github.io/longblog/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>实现一个简单的fileserver</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_05_30_22_39_a_easy_file_server.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_05_30_22_39_a_easy_file_server.html</id>
    <published>2023-05-30T14:38:00.000Z</published>
    <updated>2023-05-30T18:55:16.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们希望把某个文件夹暴露到网络上，形成一个简单的 static server 时，常用的做法是 nginx 指定 root 地址，例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>          <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>     _;<br>    <span class="hljs-attribute">root</span>    /usr/share/nginx/html;<br>    <span class="hljs-attribute">index</span>   index.html index.htm;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">try_files</span> $uri $uri/ /index.html?$args;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>nginx 有很多强大的功能，毕竟是一个 生产级 超强网关。</p><p>但有时候，我们只需要一个很简单的命令行工具，快速方便地实现启动一个 http server，核心思想就是: 简单、方便、基础能力。 </p><p><strong>一定要用起来非常简单啊！！！</strong></p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>一开始有很多奇奇怪怪的想法，既希望使用 cli 的模式让使用起来很简单，又希望能具备 使用 config 甚至 使用 db 一样强大…… </p><p>最终的结果就是：不知该如何取舍，反倒成了四不像……</p><p>经过反思与总结，写这类工具项目，一定要搞清楚 <code>自己的核心应用场景</code> ！ 第一版就只满足核心场景，而且是尽量优雅地满足，在此基础上，再增加扩展功能。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul><li>直接使用二进制文件，启动一个 http server，要能指定 home dir</li></ul><p>这个最基础的能力，从 cli 接口上可以这么用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve .<br></code></pre></td></tr></table></figure><ul><li>增加一些控制项<ul><li>要能控制 host、port、https(domain)</li><li>要能指定基本的 user:password 和 读写权限</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . --addr 0.0.0.0:8080 --https files.longalong.cn,path/to/cert,path/to/key --user long:longpass:w:/<br></code></pre></td></tr></table></figure><ul><li><p>要能指定 匿名访问及权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . --any /path/to/expose:w,/path2/to/<span class="hljs-built_in">read</span>:r<br></code></pre></td></tr></table></figure></li><li><p>要能指定配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . -c /path/to/config.yaml<br></code></pre></td></tr></table></figure></li><li><p>要能后台运行 (暂不实现)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">easyserver serve . -d<br></code></pre></td></tr></table></figure></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>于是，在只实现基础功能的指导思想下，实现了一个基础版本：</p><p><a href="https://github.com/iamlongalong/easyserver">https://github.com/iamlongalong/easyserver</a></p><p>先做一个最基本的版本，仅实现下面的基本功能：</p><ul><li><input checked="" disabled="" type="checkbox"> 提供一个简单的 http server，可以指定端口、ip、根目录</li><li><input checked="" disabled="" type="checkbox"> 可以指定一个上传目录，可以上传文件到指定目录</li><li><input checked="" disabled="" type="checkbox"> 可以指定 user 和 password，可以通过 basic auth 访问</li><li><input checked="" disabled="" type="checkbox"> 可以为 user 指定目录的权限，可以指定为只读、只写、读写</li><li><input checked="" disabled="" type="checkbox"> user 可以生成 token，可以指定 token 的有效期、可用次数、可用路径、可用操作类型(r/w)</li><li><input checked="" disabled="" type="checkbox"> 可以通过 token 访问，可以指定 token 的有效期、write可用次数、可用路径、可用操作类型(r/w)</li><li><input checked="" disabled="" type="checkbox"> 可以指定 https 的证书文件</li><li><input checked="" disabled="" type="checkbox"> 可以通过 config 文件配置，也可以通过命令行参数配置</li></ul><p>后面大概率会加上的功能：</p><ul><li><input disabled="" type="checkbox"> 一个简单的 dashboard，用于创建 token、查看 token、删除 token</li><li><input disabled="" type="checkbox"> dashboard 中可以 list、delete 文件及目录、上传文件及目录</li></ul><hr><blockquote><p>The most formidable weapon against errors of every kind is reason.<br>— <cite>Thomas Paine</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当我们希望把某个文件夹暴露到网络上，形成一个简单的 static server 时，常用的做法是 nginx 指定 root 地址，例如：&lt;</summary>
      
    
    
    
    
    <category term="golang" scheme="https://iamlongalong.github.io/longblog/tags/golang/"/>
    
    <category term="fileserver" scheme="https://iamlongalong.github.io/longblog/tags/fileserver/"/>
    
    <category term="easyserver" scheme="https://iamlongalong.github.io/longblog/tags/easyserver/"/>
    
    <category term="cobra" scheme="https://iamlongalong.github.io/longblog/tags/cobra/"/>
    
  </entry>
  
  <entry>
    <title>服务端框架再反思</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_05_29_23_47_rethink_about_framework_of_backend.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_05_29_23_47_rethink_about_framework_of_backend.html</id>
    <published>2023-05-29T15:43:00.000Z</published>
    <updated>2023-05-29T17:19:21.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做服务端开发快 3 年了，陆陆续续也写了很多项目，cli 的、http server 的、rpc server 的、job 的 等等，也用了很多工具、框架。稍微多用几套框架后，发现大家写的都差不多，虽然具体的实现方式总有些差异，但都无关紧要，因此也逐渐认为框架没那么重要，习惯一种就好。</p><p>最近有一个自己的小项目要开发，服务端一直在想用什么方案。没想到真正做框架选择时，反倒拿捏不准，就像下棋时握着棋子却始终拿不定主意。</p><p>于是，重新反思一下 golang 下的几个主流框架，弄清楚各自的特点。</p><h2 id="几个重要的框架"><a href="#几个重要的框架" class="headerlink" title="几个重要的框架"></a>几个重要的框架</h2><p>在 golang 的 server 开发领域，有一些广泛使用的服务框架：</p><ul><li>gin: 一个轻量的 http server 框架<ul><li>主要有 router、midware (log、recover等)、params binding、validator、ctx (request,response) 封装</li><li>提供了 http server 所需要的基本能力，不多不少</li><li>其他非 http 领域的则不进入，例如 orm、rpc、auth、cli、config、ws、log 等等</li><li>因此，在实际开发中，需要开发者自行组装其他工具，有较强的灵活性</li></ul></li><li>echo、mux、router: 非常轻量的 router 管理<ul><li>几乎只有路由管理能力，其他都在 golang http 原生的 request 和 reponse 基础上操作，相比 gin 更加精简</li><li>只能说比原生 http 包好用些，但在熟悉 gin 的情况下，几乎没有什么优势</li></ul></li><li><a href="https://doc.rpcx.io/">rpcx</a>： 一个 rpc 框架<ul><li>这是 鸟窝 开发的一个 rpc 框架，主要用于服务端通信，也支持 http gateway 把 http 转为 rpc 请求。</li><li>比较有意思的是，它把一切网络请求都抽象成一个 rpc 请求，而下一层无论使用 ws、tcp、http 甚至 udp (QUIC、KCP) 都可以。</li><li>脱离具体的协议来看服务框架，是一个不错的扩宽视野的项目。</li></ul></li><li><a href="https://goframe.org/">goframe</a>: 一个大而全的一站式服务端开发框架<ul><li>和 gin 不同的是，goframe 拥有一个后端项目开发过程中几乎所有的能力封装，包括但不限于  http、grpc、ws、cli、config、log、errors、validator、data convert、cache、template、orm、redis、i18n 等</li><li>各种实用工具: 常用数据结构(map、array、set、list、var、queue、tree等)、系统相关工具、加解密 等</li><li>微服务相关模块: 脚手架cli、服务发现、链路跟踪、负载均衡</li><li>server 开发相关工具: session、swagger、分页、cors、static 等等</li><li>整体来说，goframe 就是一个只要你愿意全套采用他的方案的话，你几乎可以找到所有你需要的东西。</li><li>它是一个统一的框架，对于小团队而言，能够很好地保证组件的统一性。</li></ul></li><li><a href="https://go-kratos.dev/">go-kratos</a>: 一个优雅的微服务框架<ul><li>和 gin 不同，go-kratos 和 goframe 在 微服务开发 上类似，都是一个涵盖了微服务开发过程中常用的工具。提供了 http server、grpc server、auth、metrics、tracing、validator、脚手架 cli 等。</li><li>和 goframe 不同的是，go-kratos 聚焦于 微服务开发，不提供 orm、redis 之类的库，也不提供 ws 、cli 之类的能力，不提供 cron、加解密等非 http/rpc 之外的工具。</li><li>go-kratos 在服务治理方面做的很好，有可插拔的 auth、熔断、限流、负载均衡、服务注册/发现。</li><li>在工程方面，go-kratos 提供的 脚手架 cli 在 <code>通过 proto 生成基础代码</code> ，非常值得一提的是，go-kratos 提倡完全基于 proto 去管理所有的能力，例如 通过 proto 管理 errors、validator、http service、rpc service、types、config 之类的。【这点尤其重要】</li><li>在项目结构方面，go-kratos 提倡三层架构，各层之间通过接口定义，项目使用 wire 进行串联组装，可以参考这个 <a href="https://github.com/go-kratos/examples/tree/main/blog">example</a></li></ul></li><li><a href="https://go-zero.dev/cn/docs">go-zero</a>: 一个强约束的微服务框架<ul><li>go-zero 和 gin 不同，和 go-kratos、goframe 类似。go-zero 从功能上介于 goframe 和 go-kratos 之间。go-zero 是一个专注于微服务开发的框架，这点和 go-kratos 类似。但同时，go-zero 提供了更多的工具，例如 bloom、hash、color、orm、cache、jwt、set、ring 等等，这点和 goframe 类似。</li><li>go-zero 的工程结构上，有更多的约束，同时也减少了开发者的负担和项目的复杂度，这点比前几个框架都更加突出。使用 脚手架 cli 生成的项目结构，几乎完成了除业务逻辑之外的其他部分，包括 通过 proto/api 定义生成 controller、service，通过 sql 生成 model 等。</li><li>go-zero 的工程化做得很极致。</li></ul></li></ul><h2 id="整体思考"><a href="#整体思考" class="headerlink" title="整体思考"></a>整体思考</h2><p>整体来看，几个框架各有千秋，依然是较难抉择，或许，已经在用过 <code>gin + 散装库</code> 之后，会觉得都能接受，但同时也都不好接受吧……</p><p>其实，在目前 golang 的服务框架还没有形成明显的分化时，也就意味着大家各有所长，只要没有明显的短板，无论选用哪个框架，其结果差别都不大。</p><p>项目的开发，重点依然在 <code>项目本身</code>，框架没有明显差别时，选择一个更合自己心意的就行。</p><p>好烦啊啊啊啊，cli 我习惯用 cobra，orm 习惯用 gorm，通用工具库喜欢用 goframe 的，service 的开发又比较喜欢 go-kratos 的方案，go-zero 的结构约束又觉得对以后降低心智负担很有价值……</p><p>考虑到整体开发便利性，我决定先以 go-zero 为基础框架，辅之以 goframe 的工具库。</p><p>之后会以此进行一些项目的实践，并做一些使用的记录。</p><hr><blockquote><p>Gratitude is riches. Complaint is poverty.<br>— <cite>Doris Day</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;做服务端开发快 3 年了，陆陆续续也写了很多项目，cli 的、http server 的、rpc server 的、job 的 等等，也用了</summary>
      
    
    
    
    
    <category term="golang" scheme="https://iamlongalong.github.io/longblog/tags/golang/"/>
    
    <category term="backend" scheme="https://iamlongalong.github.io/longblog/tags/backend/"/>
    
    <category term="server" scheme="https://iamlongalong.github.io/longblog/tags/server/"/>
    
    <category term="framework" scheme="https://iamlongalong.github.io/longblog/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的文件管理器</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_05_27_21_00_a_simple_file_managment.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_05_27_21_00_a_simple_file_managment.html</id>
    <published>2023-05-27T13:00:00.000Z</published>
    <updated>2023-06-02T16:38:19.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在玩 AI 画图，但有一个问题，画出来的图不知道该怎么存放，也不知道该怎么展示，于是，希望把一些信息存放起来，便于以后使用。</p><p>如果要做分布式，最好是无状态，把 AI 生成的图片和所产生的信息以文件的形式管理，方案类似于 Minio (一个文件，一个 .sys 的 fs.json 文件)</p><p>这是一个文件的例子:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;version&quot;</span>:<span class="hljs-string">&quot;1.0.2&quot;</span>,<span class="hljs-attr">&quot;checksum&quot;</span>:&#123;<span class="hljs-attr">&quot;algorithm&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;blocksize&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">&quot;hashes&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-attr">&quot;meta&quot;</span>:&#123;<span class="hljs-attr">&quot;content-type&quot;</span>:<span class="hljs-string">&quot;application/octet-stream&quot;</span>,<span class="hljs-attr">&quot;etag&quot;</span>:<span class="hljs-string">&quot;05acd5df2ba7a8178e86c3b676fef6d4&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h2><p>在存储的信息上，主要需要如下信息：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby"> filename</span><br><span class="ruby"></span>-<span class="ruby"> filepath</span><br><span class="ruby"></span>-<span class="ruby"> saving_path (<span class="hljs-number">1</span> vs n)</span><br><span class="ruby"></span>-<span class="ruby"> <span class="hljs-symbol">fs:</span>/<span class="hljs-regexp">/xx/usr</span><span class="hljs-regexp">/xx/photo</span><span class="hljs-regexp">/3lz9n4s148Ux3/xx</span>.png</span><br><span class="ruby"></span>-<span class="ruby"> <span class="hljs-symbol">piaooss:</span>/<span class="hljs-regexp">/xxx/lst</span><span class="hljs-regexp">/test/</span>4k0dLd2x0/hello.jpeg</span><br><span class="ruby"></span>-<span class="ruby"> 文件元信息</span><br><span class="ruby"></span>-<span class="ruby"> mime</span><br><span class="ruby"></span>-<span class="ruby"> checksum</span><br><span class="ruby"></span>-<span class="ruby"> size</span><br><span class="ruby"></span>-<span class="ruby"> tags</span><br><span class="ruby"></span>-<span class="ruby"> attributes (xx=xx, <span class="hljs-symbol">eg:</span> person=longalong, place=beijing)</span><br><span class="ruby"></span>-<span class="ruby"> desc</span><br><span class="ruby"></span>-<span class="ruby"> sid (加密相关信息)</span><br><span class="ruby"></span>-<span class="ruby"> create_time</span><br><span class="ruby"></span>-<span class="ruby"> update_time</span><br><span class="ruby"></span>-<span class="ruby"> delete_time</span><br><span class="ruby"></span>-<span class="ruby"> other (<span class="hljs-symbol">eg:</span> prompts)</span><br><span class="ruby"></span>-<span class="ruby"> version</span><br><span class="ruby"></span>-<span class="ruby"> local_info</span><br><span class="ruby"></span>-<span class="ruby"> from (从哪里下载的)</span><br><span class="ruby"></span>-<span class="ruby"> get_time</span><br><span class="ruby"></span>-<span class="ruby"> check_time</span><br></code></pre></td></tr></table></figure><p>文件信息的存储，可以和文件放在一块儿，也可以放在一个可以获取到的地方，放在文件尾部，则需要做专门的解析，管理起来更方便，但使用的灵活性更低。</p><p>文件信息也可以存储在一个特定的数据库中，例如中央的 mongodb、关系数据库、kv 数据库等。</p><h3 id="元信息存储选型"><a href="#元信息存储选型" class="headerlink" title="元信息存储选型"></a>元信息存储选型</h3><p>从图片管理软件 eagle 的方案来看，选择了直接存储 json 文件的方式，对于小批量文件，这确实是一个非常好用的方式，当然，如果是大批量文件，也可以在服务器端使用内存的方式优化。</p><p>使用 sqlite 的好处，在于所有信息均在一个 sql 数据库中，可以使用 SQL 的方式做查询，而且是现成的非常成熟的方案，用起来非常方便。同样，sqlite 的弊端就是中央存储，分布式下数据同步不大好处理(当然是能处理的，只是没有文件来的方便)</p><p>综合考虑来看，保证文件的独立可用是一个重要的特性，因此先采用 json 文件存储的方式，使用文件全路径作为文件名，使用 <code>同名 + .json</code> 的隐藏文件作为 meta 文件信息。</p><p>在实际使用时，需要配置一系列存储地址配置，作为存储基本信息的配置。</p><h2 id="功能清单"><a href="#功能清单" class="headerlink" title="功能清单"></a>功能清单</h2><ul><li>基本的 增删改查</li><li>download cache (下载文件作为 cache)</li><li>图片的压缩 (对于一些大图片，可做压缩处理)</li></ul><p>从交互形式上，有如下特征：</p><ul><li>要支持可以直接操作文件夹内的文件</li><li>要支持可通过接口操作文件</li><li>要支持 sync 的操作 (同步合并) [以后]</li><li>要支持导入导出为 sql 的操作 [以后]</li></ul><p>当前，可做如下事项：</p><ul><li>提供一个 local cli client，支持  cache、check update</li><li>提供一个 server，支持增删改查</li><li>提供一个 api cli client，支持增删改查</li></ul><p>实际使用时，发现还是 sqlite 好用，于是决定作为第一版，先使用 sqlite 吧。</p><p>之前走了一些弯路，认识到几个问题：</p><ul><li><p>自己的产品设计能力还很欠缺，导致对产品的交互形态没有较好的把控力，在思维上很混乱，看起来就像是：这也想要，那也想要。 最终也不知道该怎么落地。</p></li><li><p>起项目时，不能在还没什么思路的时候就上 copilot，这样只会让思路更混乱，暂时还不能把框架结构交给一个可能性很多的工具，要能完全 hold 住各种情况以后才能发挥出其拓宽思路的价值。</p></li></ul><p>不管怎么说，先写了一版基础的，先用着吧，具体的项目在 <a href="https://github.com/iamlongalong/baipiaofs">baipiaofs</a> (由于有一些隐秘的内容，暂时先设置为 private)</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p><img src="https://static.longalong.cn/img/render1685374756842.gif" alt="piaofs使用演示"></p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><ul><li>元信息管理要能同步</li><li>元信息要完全兼容文件系统</li><li>backend 以后要有很多的扩展性，要能很方便地集成多个不同 backend，并且要完全屏蔽 backend</li><li>要能做文件的容错、迁移</li></ul><p>实际上，就是把类似于分布式存储的 backend 通过一套接口，放到了多种 backend 中。</p><hr><blockquote><p>There is only one corner of the universe you can be certain of improving, and that’s your own self.<br>— <cite>Aldous Huxley</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在玩 AI 画图，但有一个问题，画出来的图不知道该怎么存放，也不知道该怎么展示，于是，希望把一些信息存放起来，便于以后使用。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记一次简单的打包速度优化</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_05_04_19_32_a_record_of_speed_up_ci_tar.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_05_04_19_32_a_record_of_speed_up_ci_tar.html</id>
    <published>2023-05-04T11:30:00.000Z</published>
    <updated>2023-05-18T07:21:06.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中需要交付一个离线包，主要用于客户自行在内网中部署，该包的大小有点大，压缩前达到了 19GB，gzip 压缩后也有 11GB，在 CI 中，使用的 <code>tar zxf xx.tar.gz xx/</code> 的方式把所有依赖文件打成一个文件，该步操作耗时约 14 min，整个 CI 的流程甚至达到 35 min，于是决定优化一下。</p><h2 id="打包及压缩优化"><a href="#打包及压缩优化" class="headerlink" title="打包及压缩优化"></a>打包及压缩优化</h2><p>众所周知，<code>tar -z</code> 使用了 <code>gzip</code> 压缩，压缩是一个 CPU 密集型的操作，而 gzip 又是一个单线程实现，这会使 gzip 的进程 cpu 占用为 100%，再也上不去了，而其他核几乎是空闲状态。</p><p>从这一角度，有两个思路： ① 使用更强大的 cpu 做 CI (垂直扩容)  ② 使用多个 cpu 做压缩 (横向扩容)</p><p>另外，压缩有程度之分，<code>1 - 9</code> 代表从 <code>速度最快</code> 到 <code>压缩效果最好</code> 递进，默认的 gzip 压缩程度为 6，这也是一个可以权衡的地方。</p><p>以下，分别从这三个方向做一些尝试。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="cpu-ecs-c7a-xlarge"><a href="#cpu-ecs-c7a-xlarge" class="headerlink" title="cpu: ecs.c7a.xlarge"></a>cpu: ecs.c7a.xlarge</h3><p><img src="https://static.longalong.cn/img/20230504195056.png"></p><h3 id="cpu-ecs-c8ae-xlarge"><a href="#cpu-ecs-c8ae-xlarge" class="headerlink" title="cpu: ecs.c8ae.xlarge"></a>cpu: ecs.c8ae.xlarge</h3><p><img src="https://static.longalong.cn/img/20230504195120.png"></p><h3 id="cpu-很普通的-8-core"><a href="#cpu-很普通的-8-core" class="headerlink" title="cpu: 很普通的 * 8 core"></a>cpu: 很普通的 * 8 core</h3><p><img src="https://static.longalong.cn/img/20230504195231.png"></p><p><img src="https://static.longalong.cn/img/20230504195352.png"></p><h3 id="cpu-很普通的-32-core"><a href="#cpu-很普通的-32-core" class="headerlink" title="cpu: 很普通的 * 32 core"></a>cpu: 很普通的 * 32 core</h3><p><img src="https://static.longalong.cn/img/20230504195426.png"></p><h3 id="cpu-很普通的-32-core-best"><a href="#cpu-很普通的-32-core-best" class="headerlink" title="cpu: 很普通的 * 32 core + best"></a>cpu: 很普通的 * 32 core + best</h3><p><img src="https://static.longalong.cn/img/20230504195532.png"></p><p><img src="https://static.longalong.cn/img/20230504195555.png"></p><h3 id="cpu-很普通的-32-core-fast"><a href="#cpu-很普通的-32-core-fast" class="headerlink" title="cpu: 很普通的 * 32 core + fast"></a>cpu: 很普通的 * 32 core + fast</h3><p><img src="https://static.longalong.cn/img/20230504195540.png"></p><p><img src="https://static.longalong.cn/img/20230504195613.png"></p><h3 id="基本结论"><a href="#基本结论" class="headerlink" title="基本结论"></a>基本结论</h3><ul><li><p>多核压缩 pigz 比 单核压缩 gzip 快很多，用起来。</p></li><li><p>从我们的场景来看，压缩程度似乎对包大小影响不大 (因为主要是一些大的docker 镜像)，所以压缩程度直接改成 fast 即可。</p></li><li><p>优化后，整体打包时间从 35 min 降到了 24 min</p></li></ul><h2 id="其他记录"><a href="#其他记录" class="headerlink" title="其他记录"></a>其他记录</h2><h3 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">axel -n 10 https://xxx.xxx.xx/xx.tar.gz<br></code></pre></td></tr></table></figure><p>yum 安装最新版:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装依赖</span><br>yum install gcc make automake autoconf openssl-dev -y<br><br><span class="hljs-comment"># 下载源代码</span><br>wget https://github.com/axel-download-accelerator/axel/releases/download/v2.17.10/axel-2.17.10.tar.gz<br><br><span class="hljs-comment"># 解压并编译</span><br>tar -zxvf axel-2.17.10.tar.gz &amp;&amp; \<br><span class="hljs-built_in">cd</span> axel-2.17.10 &amp;&amp; \<br>./configure &amp;&amp; \<br>make &amp;&amp; make install<br><br><span class="hljs-comment"># 查看</span><br>axel -h<br></code></pre></td></tr></table></figure><blockquote><p>这个的效果不一定好，主要得根据特定场景下的资源卡点来确定，如果 wget 已经能把本机网络带宽占满，则几乎没有提升。</p></blockquote><h3 id="使用-ramdisk"><a href="#使用-ramdisk" class="headerlink" title="使用 ramdisk"></a>使用 ramdisk</h3><p>磁盘读写速度有时候是很大的瓶颈，为了追求极致的读写速度，可以用 ram disk，记录一下使用方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建1个大小为 20GB 的磁盘</span><br>modprobe brd rd_nr=1 rd_size=20480000 max_part=0<br><br><span class="hljs-comment"># 格式化为 ext4</span><br>mkfs.ext4 /dev/ram0<br><br><span class="hljs-comment"># 挂载到 /root/rdisk</span><br>mkdir -p /root/rdisk &amp;&amp; mount /dev/ram0  /root/rdisk<br><br><span class="hljs-comment"># 查看一下</span><br>df -h<br><br></code></pre></td></tr></table></figure><p>清理掉 ramdisk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清理掉 ramdisk</span><br>umount /root/rdisk<br>modprobe -r brd<br></code></pre></td></tr></table></figure><p>用 glances 来监测机器运行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 glances</span><br>pip3 install --upgrade pip<br>pip3 install glances<br><br>glances<br><br></code></pre></td></tr></table></figure><h3 id="rsync-的优化"><a href="#rsync-的优化" class="headerlink" title="rsync 的优化"></a>rsync 的优化</h3><p>在多个服务器之间传输文件，常用 <code>rsync</code> 的方式。<br>最简单的用法是:  <code>rsync -av &quot;$SOURCE_DIR&quot; &quot;$TARGET_DIR&quot;</code></p><p>rsync 可以使用压缩传输，对应的参数是 <code>-z</code> ，如果你的网速是比较大的瓶颈，或者你要传输的文件有很大的压缩空间，那么你可以开启压缩，如果不是，则开启压缩后反倒会让传输的速度变慢 (压缩是单线程的)。</p><p>我们的场景属于不应当开启压缩，因此优化掉。</p><p>使用压缩时: <img src="https://static.longalong.cn/img/20230518151953.png"></p><p>不使用压缩时: <img src="https://static.longalong.cn/img/20230518152050.png"></p><p>好的，果断去掉压缩。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这只是一个最基础的打包优化，之后需要从更整体的方案上做优化：</p><ul><li>容器和资源 cache</li><li>打包平台，按需打包</li></ul><hr><blockquote><p>Almost everything comes from nothing.<br>— <cite>Henri-Frédéric Amiel</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目中需要交付一个离线包，主要用于客户自行在内网中部署，该包的大小有点大，压缩前达到了 19GB，gzip 压缩后也有 11GB，在 CI</summary>
      
    
    
    
    
    <category term="devops" scheme="https://iamlongalong.github.io/longblog/tags/devops/"/>
    
    <category term="tar" scheme="https://iamlongalong.github.io/longblog/tags/tar/"/>
    
    <category term="gzip" scheme="https://iamlongalong.github.io/longblog/tags/gzip/"/>
    
    <category term="ramdisk" scheme="https://iamlongalong.github.io/longblog/tags/ramdisk/"/>
    
    <category term="memdisk" scheme="https://iamlongalong.github.io/longblog/tags/memdisk/"/>
    
    <category term="pigz" scheme="https://iamlongalong.github.io/longblog/tags/pigz/"/>
    
  </entry>
  
  <entry>
    <title>记一次协同问题的内部分享</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_04_25_16_40_record_of_collaboration_share_in_team.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_04_25_16_40_record_of_collaboration_share_in_team.html</id>
    <published>2023-04-25T08:40:00.000Z</published>
    <updated>2023-04-25T09:06:34.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在团队内做了一次协同问题的分享，从一个更全面的视角看了一下 <code>什么是协同</code>，同时分析了其中一种协同场景的实现思路，并且用这种思路写了一个 demo: <a href="http://101.42.240.235:8080/">http://101.42.240.235:8080</a>  (姑且先用 ip 吧，之后空了再弄成域名的方式)。</p><p>受启发于前端的响应式编程，这个项目也姑且叫 reactive 吧 ~</p><p>项目地址： <a href="https://github.com/iamlongalong/reactive">https://github.com/iamlongalong/reactive</a></p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><blockquote><p>slides 如下，但由于时间比较紧，slides 以达意为主，样式没怎么调整</p></blockquote><iframe src="https://blog.longalong.cn/slides/play_with_cooperate/index.html" width="100%" height="800px">记一次对协同的简单分享</iframe><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这预计会是未来半年内的最后一次技术分享了，<a href="https://github.com/iamlongalong/reactive">reactive</a> 这个项目短期内也不会更新，和之前的 <a href="/longblog/posts/23_03_28_15_01_a_record_of_sharing_of_database.html" name="记录一次在团队内的数据库分享" >记录一次在团队内的数据库分享</a> 中的 <a href="https://github.com/iamlongalong/imagine">imagine</a> 项目一样。 以后有闲的时候可以再回来推进一下，这两个项目虽然处理的是比较小的场景，但确实是很精准的解决方案。</p><p>AI 燃烧地火急火燎，得赶紧入场了，不然哪天被干掉都不知道是为啥……</p><hr><blockquote><p>A creative man is motivated by the desire to achieve, not by the desire to beat others.<br>— <cite>Ayn Rand</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在团队内做了一次协同问题的分享，从一个更全面的视角看了一下 &lt;code&gt;什么是协同&lt;/code&gt;，同时分析了其中一种协同场景的实现思路，</summary>
      
    
    
    
    
    <category term="协同" scheme="https://iamlongalong.github.io/longblog/tags/%E5%8D%8F%E5%90%8C/"/>
    
    <category term="collaboration" scheme="https://iamlongalong.github.io/longblog/tags/collaboration/"/>
    
    <category term="share" scheme="https://iamlongalong.github.io/longblog/tags/share/"/>
    
  </entry>
  
  <entry>
    <title>记一次使用jupyter做数据分析</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_04_13_11_48_use_jupyter_for_data_analysis.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_04_13_11_48_use_jupyter_for_data_analysis.html</id>
    <published>2023-04-13T03:47:00.000Z</published>
    <updated>2023-04-14T08:13:15.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为工作需要，最近做了一次数据分析，用于洞察客户的使用情况及服务运行情况。</p><p>由于整个体系接触的比较少，因此做一下记录。</p><h2 id="数据分析的结构"><a href="#数据分析的结构" class="headerlink" title="数据分析的结构"></a>数据分析的结构</h2><p>在 <code>数据分析</code> 这项工作中，有如下环节：</p><ul><li>确认需求，明确想要分析的问题是什么，预期的产出是什么</li><li>确认数据源，明确数据的结构、格式、数据量等</li><li>确认数据逻辑，明确需要分析的问题所需数据是否到位</li><li>做数据预处理，数据清理、异构数据格式转换</li><li>查询的语句、分析的代码编写 (eg: sql、numpy 等)</li><li>数据可视化，图表绘制 (eg: BI 工具、excel、echarts、plotly 等)</li><li>数据结果的分析与说明 (eg: doc、slides、pdf 等)</li></ul><p>在本次的分析中，我的选择如下：</p><ul><li><p>确认需求： 分析客户基本特征、系统使用特征、磁盘空间占用分析</p></li><li><p>确认数据源： postgresql 数据库备份、du 结果文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@iZ2ze6jqzxxt4hf0qgpcglZ fordisk]<span class="hljs-comment"># ls -lh</span><br>total 13G<br>-rw-r--r-- 1 root root 1.1K Mar  7 21:50 df.log<br>-rwxr-xr-x 1 root root  292 Mar  7 21:42 getdiskusage.sh<br>-rw-r--r-- 1 root root  929 Mar  7 22:53 minio_disk_usage_info.log<br>-rw-r--r-- 1 root root 6.0G Mar  7 23:31 minio_disk_usage.log<br>-rw-r--r-- 1 root root 3.4G Apr  7 17:09 minio_disk_xx1.log<br>-rw-r--r-- 1 root root 3.4G Apr  7 17:16 minio_disk_xx2.log<br>-rw-r--r-- 1 root root  770 Mar  7 22:22 nfs_disk_usage_info.log<br></code></pre></td></tr></table></figure></li><li><p>确认数据逻辑： 分析 pg 数据库表结构及逻辑关系，确认 du 数据与业务含义<br><img src="https://static.longalong.cn/img/20230413123035.png"></p></li><li><p>数据预处理： ① 对 pg 的数据做拆分聚合，形成多张能直接查询的表； ② 对 du 结果做处理，以关系数据的方式写入 pg 库中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1. 去除 pg 中的无用数据<br>2. 使用 CREATE TABLE xxx AS SELECT * FROM xxx WHERE xx and xx; 的方式创建能直接使用的表<br>3. 写脚本将 du 的结果变成 csv 格式，并使用 COPY xxx FROM &#x27;xxx.csv&#x27;      WITH ( FORMAT csv, DELIMITER &#x27;,&#x27;, HEADER false); 导入到 pg 数据库<br></code></pre></td></tr></table></figure></li><li><p>查询的语句： 拆分需求所需的关键分析项，写 sql 查询，对查询结果做进一步处理得到所需结构。 工具上，使用 jupyterhub，所有操作均在 jupyter python note 中完成。<br><img src="https://static.longalong.cn/img/20230413123222.png"></p></li><li><p>数据可视化： 根据需求，使用 pie、bar、line、heatmap、pareto 等图进行展示。 工具上，使用 plotly，直接在 jupyterhub 上生成图表。</p></li></ul><p><img src="https://static.longalong.cn/img/20230413121812.png" alt="折线图"></p><p><img src="https://static.longalong.cn/img/20230413121831.png" alt="柱形图"></p><p><img src="https://static.longalong.cn/img/20230413121915.png" alt="帕累托图"></p><ul><li>数据结果的分析与说明： 直接使用 jupyterhub，使用 markdown 写结果分析。整个文件以 html 的方式导出图表和分析结果。<br><img src="https://static.longalong.cn/img/20230413123356.png"></li></ul><h2 id="一些坑点-趣点小记"><a href="#一些坑点-趣点小记" class="headerlink" title="一些坑点/趣点小记"></a>一些坑点/趣点小记</h2><h3 id="jupyter-的导出问题"><a href="#jupyter-的导出问题" class="headerlink" title="jupyter 的导出问题"></a>jupyter 的导出问题</h3><p>按理，jupyter 是可以直接导出 pdf、html、slides 之类的，本想导出 pdf ，但要导出 pdf 需要各种插件依赖，我们的 jupyterhub 是用 centos 装的，依赖安装很难搞，建议用 ubuntu 装 jupyterhub。<br>最后无奈，只有导出 html ……</p><h3 id="note-的数据大小问题"><a href="#note-的数据大小问题" class="headerlink" title="note 的数据大小问题"></a>note 的数据大小问题</h3><p>一般而言，jupyterhub 要使用域名，就会在前面挡一层 nginx，我们也用的这种方式，但没有配置上传的 body 大小限制，默认是 1MB，超过就会报 413 错误，具体可以参考 <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size">nginx 官方文档</a> ，可以设置为 20MB，大点的 note 也差不多在这之内。</p><h3 id="导出的-html-有点丑"><a href="#导出的-html-有点丑" class="headerlink" title="导出的 html 有点丑"></a>导出的 html 有点丑</h3><p>jupyter 导出的 html 既有 code 块 也有 输出块 (eg: 图表) 也有 文本块 (markdown)，但实际上对外分享时不需要 code 块，隐藏的方式在网上有一些用 plugin 的，简单尝试了下有点难搞，于是就在 html 的样式上下功夫，为了去掉 code 部分，添加了如下 style:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.jp-CodeMirrorEditor</span><span class="hljs-selector-class">.jp-Editor</span><span class="hljs-selector-class">.jp-InputArea-editor</span> &#123;<span class="hljs-attribute">display</span>: none;&#125;<br><span class="hljs-selector-class">.jp-InputArea</span><span class="hljs-selector-class">.jp-Cell-inputArea</span> &#123;<span class="hljs-attribute">display</span>: none;&#125;<br><span class="hljs-selector-class">.jp-OutputArea-child</span><span class="hljs-selector-pseudo">:has</span>(pre) &#123;<span class="hljs-attribute">display</span>: none;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不得不说， css 选择器中加了 has 这种能力后，父节点选择直接方便了不少</p></blockquote><p>另外，默认的字体大小为 14px，改了下 css 变量 <code>--jp-content-font-size1: 18px</code>，好看多了。</p><h3 id="sql-中直接做分组也挺方便"><a href="#sql-中直接做分组也挺方便" class="headerlink" title="sql 中直接做分组也挺方便"></a>sql 中直接做分组也挺方便</h3><p>除了常用的 <code>to_char(created_at::DATE, &#39;YYYY-MM-DD&#39;) as day</code> 、<code>date_trunc(&#39;week&#39;, created_at::date) as week</code> 这种时间分组操作外，还可以使用 <code>cross join lateral (values (max_kb / 1024)) xx (size_mb) GROUP BY xx.size_mb</code> 这种横向 join 的能力。</p><p>之前还有一些分组是在 python 脚本里手写的，但其实 sql、python 的 numpy 库中都可以直接做分组聚合，挺方便。</p><h3 id="结合-AI-？"><a href="#结合-AI-？" class="headerlink" title="结合 AI ？"></a>结合 AI ？</h3><p>很多数据分析其实都是很常规的，比如统计信息，一定程度上算得上是 <code>机械重复的工作</code> ，那么结合 AI 就是一个比较容易的事了。 相信很多团队都会在这个方向搞些事情，尤其是那些专门做 BI 工具的公司。(比如: power BI、tableau、神策？等)</p><p>从结合的方式来看，如果结合 AGI 例如 GPT，小团队使用还好，大团队的安全担忧会比较大。如果使用特定领域的 AI，那么问题就会变成 如何让 AI 理解业务结构的问题。会存在结构化或非结构化的方式，非结构化对应类似 GPT 的 prompt。</p><h3 id="jupyter-的-runtime-模式有点意思"><a href="#jupyter-的-runtime-模式有点意思" class="headerlink" title="jupyter 的 runtime 模式有点意思"></a>jupyter 的 runtime 模式有点意思</h3><p>jupyter 的特点主要是 code 和 markdown 的结合。当另外一点我认为也很有价值： runtime 保持。这对我们学习脚本语言的体验有很大提升，相当于一直处于断点模式，并且还可以随意修改下一个断点前的代码。</p><h3 id="其他的工具"><a href="#其他的工具" class="headerlink" title="其他的工具"></a>其他的工具</h3><p>在准备做这项事之前，花了一小段时间去调研用什么方式管理要做的事，最简单的例如：excel 图表 + 文档 的方式，这种方式管理起来很麻烦。于是想到了可以直接进行代码交互的方案，例如  jupyter notebook。 其实，这种工作属于 数据分析，而数据分析有更多专门的工具，主要的诉求有如下：</p><ol><li>连接各类数据库</li><li>对连接的数据源进行查询，并对结果做处理</li><li>生成图表</li><li>结果的分析记录</li><li>对外分享分析结论</li></ol><p>jupyter 算是一个比较通用的 python / nodejs 工具，但在数据分析方面的使用成本还是挺高的，例如连接数据库等等 (当然也有一些 jupyter 的插件能做到这件事)。</p><p>上面提到过的 power BI、tableau 在上手难度上很低，都属于面向分析人员的低代码方案。</p><p>不得不说，这其中还是存在一些需求的，市面上也确实看到过一些类似于 jupyter ，但是提升了在数据分析方面能力的工具，比如:  <a href="https://hex.tech/">hex</a>  <a href="https://observablehq.com/">observablehq</a> 。 <a href="https://count.co/">count</a> 直接在 canvas 上操作，交互体验更有意思。还有开源的方案 <a href="https://github.com/apache/zeppelin">zeppelin</a> 。</p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><h3 id="熟悉-numpy-的使用"><a href="#熟悉-numpy-的使用" class="headerlink" title="熟悉 numpy 的使用"></a>熟悉 numpy 的使用</h3><p>数据分析领域比较常用 python，主要是 python 下科学计算的库比较完善，比如 numpy，这次的分析中由于对 numpy 不熟悉，所以有些数据处理都是手写的，拉低了效率。</p><p>之后可以在 numpy 等工具应用上多看一下，同理 plotly。</p><h3 id="了解更多的数据分析方案"><a href="#了解更多的数据分析方案" class="headerlink" title="了解更多的数据分析方案"></a>了解更多的数据分析方案</h3><p>用 OLTP 关系数据库分析在少量数据时挺好用，但大数据量下性能就不大行了，比如千万级以上的数据，这种时候得使用其他方案了。</p><ul><li>数据库: clickhouse、hive、cassandra、hbase、mongodb、redis、rds……</li><li>分布式存储: hadoop(hdfs)、s3</li><li>stream: kafka、rocketmq、flume</li><li>任务与计算: flink、spark</li></ul><p>在数据分析之后，还有 AI 算法和模型训练，然后才能接上 AI</p><blockquote><p>调研过程中发现 <a href="https://www.smartbi.com.cn/">smartbi</a> 在做类似的接入了~</p></blockquote><p>未来 20 年是 AI 的时代，拥抱数据分析、拥抱 AI </p><p><img src="https://static.longalong.cn/img/20230413135436.png"></p><hr><blockquote><p>Ignorance never settles a question.<br>— <cite>Benjamin Disraeli</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;因为工作需要，最近做了一次数据分析，用于洞察客户的使用情况及服务运行情况。&lt;/p&gt;
&lt;p&gt;由于整个体系接触的比较少，因此做一下记录。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://iamlongalong.github.io/longblog/tags/python/"/>
    
    <category term="jupyter" scheme="https://iamlongalong.github.io/longblog/tags/jupyter/"/>
    
    <category term="数据分析" scheme="https://iamlongalong.github.io/longblog/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>关于职业规划的一些思考</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_04_06_21_41_some_questions_about_majors_in_university.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_04_06_21_41_some_questions_about_majors_in_university.html</id>
    <published>2023-04-06T13:40:00.000Z</published>
    <updated>2023-04-06T14:55:02.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>叔叔的仔明年高考，向我询问关于专业选择的看法，我做了一些梳理记录于此。</p><h2 id="Q1-该选什么专业？"><a href="#Q1-该选什么专业？" class="headerlink" title="Q1: 该选什么专业？"></a>Q1: 该选什么专业？</h2><p>现在选专业，是为未来 8 年以后做准备的，因此，不能以现在的行业情况来判断该选什么。事实上，每一个领域的快速发展期大都只有 5 年，因此一定不能追当前热门的专业，这意味着当毕业以后，一定会是一个走下坡路的行业。例如，03年开始学外贸、外语，08 年开始学土木、建筑，14 年开始学财会、金融等等，这些都是典型的失败选择…… (另外，计算机是个例外，持续火了十几年)</p><p>因此，专业的选择要考虑两个主要问题：</p><ol><li>个人的兴趣及爱好</li><li>未来 8 年以后的行业更迭</li></ol><p>以下简单梳理一些我对一些领域的看法：</p><p>新能源、生物、化学、新材料 这些，都是属于高精尖的领域，需要往博士阶段奋斗，需要有很明确的志向才能选择。</p><p>医学，现在竞争比较激烈，所以目前就业方面比较难，但几年以后来看，是个还可以的方向，尤其是保健护理、神经医学、心理学。 </p><p>法学，长期来看始终会有机会，如果对法律方向有兴趣，可以考虑。</p><p>金融财会类，金融方向需要的是人脉、资源、背景，普通人进入就是销售岗位。财会方向几年以后会直接被计算机替代，一定不能选。 </p><p>土木工程类，这是前10年的热门专业，但热门的原因是中国在大搞基建，目前基建已经饱和，未来土木、桥梁、电力、煤炭、钢铁 这些领域都会持续走下坡路。</p><p>交通类，交通运输管理、交通运输工程、汽车工程、飞行器等，这些领域算是很专业的领域，汽车方向在走下坡路，航空航天、交通运输工程 这些持续会有机会，但一定要走高精尖路线。</p><p>电气自动化、电子机械，这是未来 10 年以后一定会大量需要的岗位，伴随着全面工业 4.0 推进、人体机械领域的发展，会出现一波很大的人才需求。</p><p>计算机科学、软件工程，现在看起来人才有些饱和，实际是全球经济遭受冲击，对大量还无法盈利的互联网产业冲击较大，加上 AI 对基础岗位的替代作用很明显，因此近两年互联网企业的裁员较多。但实际上，全球经济冲击对每个行业都非常巨大，只是很多行业在互联网和媒体上都发不出声音，没被大家看到。 </p><p>从未来来看，计算机知识是基础知识，在具备计算机知识的基础上，可以转向很多领域，比如 计算机 + 机械、计算机 + 财会、计算机 + 教育 等等，我比较相信一个理念：最后一个被 AI 替代的行业是程序员，倒数第二个是服务员。</p><p>教育学，教育是一个会有剧变的领域，目前看不清楚未来的发展情况。幼儿教育领域的变化不会太大，会持续朝着精细化发展。中学教育会受到 AI 的大冲击。</p><p>传媒方向，数字媒体从长期来看还是有机会，但目前还看不清楚 AI 的冲击会让这个领域成为什么样。</p><p>农林畜牧，没有太多背景资源的话，机会比较少。但小领域还是有一些机会，比如动物医学。没较强的兴趣不建议。</p><p>经济学、管理学、哲学、社会学、历史学，这些领域如果不是具备很强的兴趣和使命，就不要选，人文学科精神会很富足，但就业不大好。</p><p>语言类专业都不能选，未来一定会被 AI 替代。</p><p>军工类，如果有比较强的军人情结可以考虑。但军工类的进入方法，在没有一定背景的情况下，最好以技术类工种进入，比如学习 航空、导弹、计算机、机械，从这些专业进入。</p><h2 id="Q2-大学专业和从事行业是什么关系？"><a href="#Q2-大学专业和从事行业是什么关系？" class="headerlink" title="Q2: 大学专业和从事行业是什么关系？"></a>Q2: 大学专业和从事行业是什么关系？</h2><p>一定要记住，大学专业只是你认识这个世界的一个入口，选好了专业不代表一定能从事好的行业，行业更迭速度很快，只有保持持续的学习、保持持续的思考、保持开放的心态，才能跟上时代的发展，才能有机会获得更高的投入产出比，也才能拥有更多的时间和心力来享受生命。</p><h2 id="Q3-高三学生现在该做什么？"><a href="#Q3-高三学生现在该做什么？" class="headerlink" title="Q3: 高三学生现在该做什么？"></a>Q3: 高三学生现在该做什么？</h2><p>战略上轻视应试教育，战术上极其重视应试教育。</p><p>尽可能地把考试分数当做自己的追求，极尽一切去体会解题带给你的乐趣，去体会对知识的掌控感带给你的乐趣，让你的脑海里充满学科知识点，用你自己的视角去关联这些知识，让一切会占用你注意力的其他事物都从你的生活中消失！！</p><p>请相信，如果你这样做了，未来的你一定会对现在的你感激涕零，是那种对从死亡边缘把你拉回来的救命恩人的那种感激。</p><p>……未完待续</p><hr><blockquote><p>This is the whole point of technology. It creates an appetite for immortality on the one hand. It threatens universal extinction on the other. Technology is lust removed from nature.<br>— <cite>Don DeLillo</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;叔叔的仔明年高考，向我询问关于专业选择的看法，我做了一些梳理记录于此。&lt;/p&gt;
&lt;h2 id=&quot;Q1-该选什么专业？&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="职业" scheme="https://iamlongalong.github.io/longblog/tags/%E8%81%8C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>智能是什么？</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_04_01_10_43_some_discuss_about_inteligence.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_04_01_10_43_some_discuss_about_inteligence.html</id>
    <published>2023-04-01T02:25:00.000Z</published>
    <updated>2023-04-01T03:26:53.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何看待AI兴起"><a href="#如何看待AI兴起" class="headerlink" title="如何看待AI兴起"></a>如何看待AI兴起</h3><p>中短期来看，和工业革命一样，会极大地改变人们的生产方式，这是大势，不可与之抗衡，顺应趋势，把它当做一个大变革下的工具去使用，真正把 AI 应用到各个领域。</p><p>就像工业革命时期，同样存在 “反对工业的手工业者” 和 “积极拥抱工业的小作坊主”，前者本能地反对工业，最后被工业清了场，而支持工业的，拥有了所在领域的所有资源。</p><p>从中短期来看，AI 是提升生产力的重要方式，生产力提升是一件好事， 能带来生活的便利和生活水平的提升。</p><p>大家对 AI 的担心，大多站在两个视角：资源分配，害怕 AI 改变了自己现有的资源分配方式； 种族安全，害怕 AI 构建起了与人类利益不一致的价值体系。</p><p>所以，对于国家而言，保持社会稳定以及公平公正的方法，是做好资源分配。对于个人而言，提升生活质量的方式，是拥抱 AI，寻找能获得资源分配倾斜的途径，比如，把 AI 引入某个细分领域并实现效率的极大升级。</p><p>站在人类种族视角，如果以种族延续为最基本诉求的话，确实应该好好梳理一下怎么处理好安全问题，至少推迟硅基生物的降临时间，或者做好平稳过渡。</p><p>不过，世界如此割裂的情况下，很难说还有没有 “人类种族” 这个意识……</p><hr><h3 id="一个视角下的智能"><a href="#一个视角下的智能" class="headerlink" title="一个视角下的智能"></a>一个视角下的智能</h3><p>工业化 体系下，我们可以这样延伸：<br>(标准化）、信息化、自动化、智能化</p><p>信息化 体系下，精简成了这两个环节：<br>信息化 =&gt; 智能化</p><p>信息化 和 智能化 的差异体现在 决策上。</p><p>什么是决策？</p><ol><li>目标 (价值判断)</li><li>信息</li><li>推演</li><li>价值选择</li></ol><p>什么是价值？</p><ul><li>利益</li></ul><p>谁的利益？</p><ul><li>群体利益</li><li>个人利益</li><li>？</li></ul><p>所以，选择没有绝对的对错，只有屁股。或者，对错的评判标准是 “选择与屁股是否相符”。</p><p>群体利益，由 社会伦理、组织文化 等保障<br>个人利益，由 群体利益 和 个人思想与行为 保障</p><p>那么，？</p><hr><h3 id="有意思的语句"><a href="#有意思的语句" class="headerlink" title="有意思的语句"></a>有意思的语句</h3><p>想到一些有意思的句子，你细品：</p><ul><li>非我族类，其心必异</li><li>兽人永不为奴</li><li>黑，真特么的黑</li><li>人类终于创造出了神</li></ul><hr><blockquote><p>Eternal nothingness is fine if you happen to be dressed for it.<br>— <cite>Woody Allen</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何看待AI兴起&quot;&gt;&lt;a href=&quot;#如何看待AI兴起&quot; class=&quot;headerlink&quot; title=&quot;如何看待AI兴起&quot;&gt;&lt;/a&gt;如何看待AI兴起&lt;/h3&gt;&lt;p&gt;中短期来看，和工业革命一样，会极大地改变人们的生产方式，这是大势，不可与之抗衡，顺应趋势，把</summary>
      
    
    
    
    
    <category term="智能" scheme="https://iamlongalong.github.io/longblog/tags/%E6%99%BA%E8%83%BD/"/>
    
    <category term="inteligence" scheme="https://iamlongalong.github.io/longblog/tags/inteligence/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在团队内的数据库分享</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_03_28_15_01_a_record_of_sharing_of_database.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_03_28_15_01_a_record_of_sharing_of_database.html</id>
    <published>2023-03-28T07:01:00.000Z</published>
    <updated>2023-03-28T10:19:34.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>简单从一个视角去看数据库 ~</p><p>手写一个简单的 map 数据库 ~</p><p>回头把 视频/音频/文字稿 整理一下附上 ~</p><p>这是一个比较有意思的项目，目前还没有完成，之后一段时间也会推进一些地方的改进，具体可以关注 github 的更新情况 ~</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><iframe src="https://blog.longalong.cn/slides/easy_talk_of_db/index.html#/" width="100%" height="800px">记一次对数据库的简单分享</iframe><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>对应的 github 项目地址为:  <a href="https://github.com/iamlongalong/imagine">imagine</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;简单从一个视角去看数据库 ~&lt;/p&gt;
&lt;p&gt;手写一个简单的 map 数据库 ~&lt;/p&gt;
&lt;p&gt;回头把 视频/音频/文字稿 整理一下附上 ~&lt;</summary>
      
    
    
    
    
    <category term="database" scheme="https://iamlongalong.github.io/longblog/tags/database/"/>
    
    <category term="share" scheme="https://iamlongalong.github.io/longblog/tags/share/"/>
    
    <category term="数据库" scheme="https://iamlongalong.github.io/longblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="团队分享" scheme="https://iamlongalong.github.io/longblog/tags/%E5%9B%A2%E9%98%9F%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>记一次对可恶站点的抗争</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_03_12_12_16_a_fight_for_some_disgust_sites.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_03_12_12_16_a_fight_for_some_disgust_sites.html</id>
    <published>2023-03-12T04:15:00.000Z</published>
    <updated>2023-03-15T04:42:16.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有些网站本身有挺多高质量的内容，但非得走上让人恶心 🤮 的道路，所以在这里记录一下跟他们抗争的历程。</p><h2 id="某书"><a href="#某书" class="headerlink" title="某书"></a>某书</h2><p>最近想查一些树形结构存储方案，看到一篇某书上的文章，打开一看，简直是震惊啊龙几十年！</p><p>用几个词来形容： 内容被忽视，广告粗劣，小黄文占领了主体……</p><p>大致如下：</p><p><img src="https://static.longalong.cn/img/20230312123403.png"></p><p>之前某书是一个多么干净、沉浸的文字平台啊，很多程序猿、小文艺都喜欢在上面写写文章，如今……</p><p>但无可奈何，这个平台上还是有一些知识遗产，之前积累起来的中文搜索关键词还被这个平台占据着，有时候搜索一些东西还是会被引导这个平台上来，所以……得净化一下……</p><h3 id="简单的净化方案"><a href="#简单的净化方案" class="headerlink" title="简单的净化方案"></a>简单的净化方案</h3><h4 id="uBlock"><a href="#uBlock" class="headerlink" title="uBlock"></a>uBlock</h4><p>这是一个 chrome 插件，可以用于 元素过滤、脚本过滤、多媒体过滤等</p><p>插件地址： <a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a></p><ul><li>使用元素选择器，把一些恶心的模块干掉<br><img src="https://static.longalong.cn/img/20230312124737.png"></li></ul><p>这种方式对 顶部广告、底部广告、底部恶心推荐 都很有效。</p><p>但是对右侧的 热门故事 模块几乎无效。因为选择器直接选择时候的选择器是 class 选择器，而 class 名经常可能会发生变化，导致失效，所以我们得找一个更好的元素选择路径。</p><ul><li>扒一下前端页面的结构</li></ul><p><img src="https://static.longalong.cn/img/20230312125633.png"></p><p>可以发现，这个网站的生成应该是 next.js 做的服务端渲染，结构很鲜明，role=”main” 的块为页面主体， aside 为侧边栏。</p><ul><li>于是我们可以这样操作</li></ul><p>选择器为 <code>##div[role=main] &gt; aside</code> ，效果是这样的：</p><p><img src="https://static.longalong.cn/img/20230312130928.png"></p><ul><li>探索一下另一条路</li></ul><p>由于页面的主体是静态的，而页面的推荐内容是动态的，也就意味着一定会发送对应的请求出去，那么 block 这些请求也是一个不错的方式。</p><p>于是扒了一下页面请求：</p><p><img src="https://static.longalong.cn/img/20230312130408.png"></p><p>可以发现，这些就是我们最不喜欢的东西，有广告的、恶心推荐的、行为上报的……</p><p>之后可以玩一下接口过滤</p><p>一番操作下来，舒服多了…… 可以继续看文章了</p><p><img src="https://static.longalong.cn/img/20230312150852.png"></p><ul><li>后记</li></ul><p>uBlock 很强大，默认会做一些关键词过滤，例如 <code>ad</code> ，但这个粒度相对较大，有时候会误把一些需要的信息给屏蔽掉，导致个别网站访问失败，或者操作报错 之类的，一般发现你的浏览器 和 别人的浏览器 对某个页面的表现不一致时，建议把 uBlock 关上试试，如果真是因为 uBlock 过滤的问题，那就把这个站点加个白名单。</p><p>另外，也可以用下面这种方式 👇👇👇</p><h4 id="TamperMonkey"><a href="#TamperMonkey" class="headerlink" title="TamperMonkey"></a>TamperMonkey</h4><p>油猴是一个页面脚本管理工具，可以自定义任何的 js， 这需要写一些简单的 js 代码，实现的逻辑和 uBlock 一样，去除一些页面特定的元素。 </p><p>找了一下<a href="https://www.tampermonkey.net/scripts.php">油猴的脚本社区</a>，搜了一下，发现之前有一个哥们儿用 jquery + class 选择器做的，估计已经用不了了，我顺手写一个吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         RemoveJianShuNauseaThings</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @version      0.1</span><br><span class="hljs-comment">// @description  简书之堕落，让人遗憾，哀其不幸，怒其不争，为了不让广大作者的资产跟着陪葬，去除污染源，以正视听。 简书去广告。简书。广告。去除热门推荐。jianshu。JianShu。</span><br><span class="hljs-comment">// @author       longalong</span><br><span class="hljs-comment">// @match        *://www.jianshu.com/p/*</span><br><span class="hljs-comment">// @icon         https://www.google.com/s2/favicons?sz=64&amp;domain=jianshu.com</span><br><span class="hljs-comment">// @grant        none</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">do_track</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// remove baidu ads</span><br>        <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;iframe&quot;</span>).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;iframe&quot;</span>).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (i.src.includes(<span class="hljs-string">&quot;pos.baidu.com&quot;</span>)) &#123;<br>                    i.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>                &#125;<br>            &#125;);<br>        &#125;);<br><br>        <span class="hljs-comment">// remove aside recommend</span><br>        <span class="hljs-keyword">let</span> asideModle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div[role=main] &gt; aside &gt; div&quot;</span>);<br>        <span class="hljs-keyword">if</span> (asideModle) &#123;<br>            asideModle.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// remove under recommend</span><br>        <span class="hljs-keyword">let</span> unserModle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div[role=main] &gt; div &gt; section:nth-child(2)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (unserModle) &#123;<br>            unserModle.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> message_box = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div#__next&quot;</span>);<br>        <span class="hljs-comment">// listen element change</span><br>        <span class="hljs-keyword">let</span> MutationObserver = <span class="hljs-built_in">window</span>.MutationObserver || <span class="hljs-built_in">window</span>.WebKitMutationObserver;<br>        <span class="hljs-keyword">if</span> (MutationObserver) &#123;<br>            <span class="hljs-keyword">let</span> MutationObserverConfig = &#123;<br>                <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>,<br>            &#125;;<br>            <span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mutations</span>) </span>&#123;<br>                do_track();<br>            &#125;);<br>            observer.observe(message_box, MutationObserverConfig);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message_box.addEventListener) &#123;<br>            message_box.addEventListener(<span class="hljs-string">&quot;DOMSubtreeModified&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>&#123;<br>                do_track();<br>            &#125;, <span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                do_track();<br>            &#125;, <span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listen event fail&quot;</span>, error);<br>    &#125;<br><br>&#125;)();<br></code></pre></td></tr></table></figure><p>这个也发布到 <a href="https://greasyfork.org/zh-CN/scripts/461677-removejianshunauseathings">Greasy Fork</a> 社区了，有同样诉求的同学可以自行获取。</p><h2 id="某SDN"><a href="#某SDN" class="headerlink" title="某SDN"></a>某SDN</h2><p>……目前用了 uBlock 做推荐拦截，用了 简悦 做 copy ，先解决了问题，以后有什么特别的恶心的地方再做梳理吧……</p><h2 id="某书后续"><a href="#某书后续" class="headerlink" title="某书后续"></a>某书后续</h2><ul><li><input disabled="" type="checkbox"> 外链跳转优化</li><li><input disabled="" type="checkbox"> 生成文章目录层级</li></ul><hr><blockquote><p>We can only learn to love by loving.<br>— <cite>Iris Murdoch</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;有些网站本身有挺多高质量的内容，但非得走上让人恶心 🤮 的道路，所以在这里记录一下跟他们抗争的历程。&lt;/p&gt;
&lt;h2 id=&quot;某书&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="tampermonkey" scheme="https://iamlongalong.github.io/longblog/tags/tampermonkey/"/>
    
    <category term="油猴" scheme="https://iamlongalong.github.io/longblog/tags/%E6%B2%B9%E7%8C%B4/"/>
    
    <category term="js script" scheme="https://iamlongalong.github.io/longblog/tags/js-script/"/>
    
    <category term="chrome" scheme="https://iamlongalong.github.io/longblog/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>关于文件存储的一些调研</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_03_09_12_53_some_research_of_file_storage.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_03_09_12_53_some_research_of_file_storage.html</id>
    <published>2023-03-09T04:53:00.000Z</published>
    <updated>2023-03-16T04:17:15.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做 <a href="/notpublish/index.html" name="如何做一个分布式截图服务" >如何做一个分布式截图服务</a> 的准备，因此需要调研一下文件存储上都有些什么方案。</p><p>主要需要调研以下内容：</p><ul><li>基础设施层，主要调研 机械硬盘、ssd、闪存、网卡、lvm、raid</li><li>本地文件系统及网络文件系统，主要调研 fat、exfat、ntfs (windows)、hfs(mac)、zfs、xfs、ext、nfs、smb</li><li>分布式存储主要调研 oss、kodo、fastDFS、glusterFS、ceph、minio、longhorn、ipfs、hdfs</li><li>相关应用主要参考 mongodb、etcd、群晖</li></ul><h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><ul><li>ssd ： <a href="https://www.zhihu.com/question/47544675/answer/670562224">SSD的随机读写与顺序读写</a></li><li><a href="https://zhuanlan.zhihu.com/p/443342432">几个ssd接口类型</a></li><li><a href="https://zhuanlan.zhihu.com/p/429260253">企业级SSD寿命要怎么看</a></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>参考文档：</p><ul><li><a href="https://www.cnblogs.com/lilpig/p/16858611.html">文件系统的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/44267768">深入理解 ext4 等 linux 文件系统</a></li><li><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">ext4 的 wiki</a></li><li><a href="https://github.com/openzfs/zfs">github openzfs</a></li><li><a href="https://www.zhihu.com/question/21034296">exfat 系统的一些讨论</a></li><li><a href="https://zhuanlan.zhihu.com/p/571235218">Linux下几种常用文件系统Ext4、XFS、ZFS以及Btrfs的简介及优缺点对比</a></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="minio"><a href="#minio" class="headerlink" title="minio"></a>minio</h3><p>github 地址: <a href="https://github.com/minio/minio">minio</a><br>官方文档：<a href="https://docs.min.io/">minio</a><br>中文文档：<a href="http://docs.minio.org.cn/docs/">minio</a></p><ol><li>不使用中央式 meta 存储</li><li>底层采用文件存储</li><li>大量小文件性能较差</li><li>分布式通过 EC 方案保证高可用</li><li>集群内无法扩容，仅能通过扩充集群组联邦实现</li><li>minio 作者也是 glusterFS 的创始人</li><li>minio 采用的开源协议是 GNU AGPLv3，商用有隐患</li></ol><p>可以参考的文档：</p><ul><li><a href="https://blog.csdn.net/agonie201218/article/details/128245433">minio 介绍</a></li></ul><h3 id="ceph"><a href="#ceph" class="headerlink" title="ceph"></a>ceph</h3><ol><li>提供 块存储、文件存储、对象存储 三种方式</li><li>元数据存储在 MDS 组件集群中</li><li>MON 组件负责集群信息同步和处理</li><li>OSD 是集群中真正处理存储的模块 (一个磁盘区对应一个 osd daemon，多个 osd daemon 组成了 osd 集群)</li><li>radosgw 对象存储网关，用来兼容 S3 和 swift 协议</li><li>ceph 读写文件都是按照一个固定文件大小进行的，例如 2MB，因此对大量非常小的文件而言有较大空间和性能损耗</li><li>在 openstack 的后端存储统计中，ceph 占比 81%， lvm 8%，nfs 5%，glusterfs 1%</li></ol><p>ceph 还是不错的，值得一试。</p><p>可以参考的文档：</p><ul><li><a href="https://www.jianshu.com/p/cc3ece850433">ceph 介绍及原理</a></li><li><a href="http://c.biancheng.net/view/9852.html">ceph分布式存储介绍</a></li></ul><h3 id="glusterFS"><a href="#glusterFS" class="headerlink" title="glusterFS"></a>glusterFS</h3><ol><li>通过挂载操作系统的 vfs 进行交互</li><li>通过 复制卷 的方式保证数据安全</li><li>和 lvm 类似，可以组条带化的方案提升性能</li><li>没有中央的 meta 管理，这点和 minio 一样，保持简单，对查询不友好</li></ol><p>可以参考的文档：</p><ul><li><a href="https://blog.csdn.net/zyy1020075955/article/details/127313156">glusterFS</a></li></ul><h3 id="fastdfs"><a href="#fastdfs" class="headerlink" title="fastdfs"></a>fastdfs</h3><p>项目代码地址： <a href="https://github.com/happyfish100/fastdfs">fastdfs</a></p><ol><li>文件直接存储，没有做分块</li><li>大文件要做安全性只有通过复制集，存储量比较大</li><li>C 语言开发</li></ol><h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><ol><li>适合大文件，流式读</li><li>具有强容错能力和扩展能力</li><li>不适合要求延时低的场景</li><li>不适合大量小文件</li></ol><p>可以参考的文档：</p><ul><li><a href="https://www.jianshu.com/p/b3270d74d5fe">hdfs 介绍</a></li></ul><hr><blockquote><p>Neither a lofty degree of intelligence nor imagination nor both together go to the making of genius. Love, love, love, that is the soul of genius.<br>— <cite>Wolfgang Amadeus Mozart</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做 &lt;a href=&quot;/notpublish/index.html&quot; name=&quot;如何做一个分布式截图服务&quot; &gt;如何做一个分布式截图服</summary>
      
    
    
    
    
    <category term="minio" scheme="https://iamlongalong.github.io/longblog/tags/minio/"/>
    
    <category term="file storage" scheme="https://iamlongalong.github.io/longblog/tags/file-storage/"/>
    
    <category term="disk" scheme="https://iamlongalong.github.io/longblog/tags/disk/"/>
    
    <category term="file system" scheme="https://iamlongalong.github.io/longblog/tags/file-system/"/>
    
  </entry>
  
  <entry>
    <title>记一次扒 nginx ingress 的过程</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_03_06_13_40_nginx_ingress_dig_process.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_03_06_13_40_nginx_ingress_dig_process.html</id>
    <published>2023-03-06T05:40:00.000Z</published>
    <updated>2023-03-06T17:32:31.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近因为 nginx 网关的问题，导致服务有诸多不稳定的风险，因此需要更近一步去做网关的工作。</p><p>之前预判过将来会因无法自定义负载均衡而达不到目标，于是探索过 nginx-ingress 增加自定义负载均衡的方案，详情参见 <a href="/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html" name="记一次有状态服务的负载均衡方案探索" >记一次有状态服务的负载均衡方案探索</a> ，但由于当时业务还没有真正遇到问题，所以也没继续去推这个事儿。</p><p>不过当时的探索比较粗浅，是抱着 <code>能简单解决问题</code> 的目的做的，现在，需要有更多的梳理，以降低大家对这件事的认知复杂度。</p><h2 id="nginx-ingress"><a href="#nginx-ingress" class="headerlink" title="nginx ingress"></a>nginx ingress</h2><p>在 k8s 中，我们有多种提供对外访问的方式，其中业务中用的最多的，就是 ingress controller。 市面上提供的各类 ingress controller 非常多，例如 envoy、treafik、apisix、openresty 等等，我们选用的，是运维同学都比较熟悉的 nginx-ingress-controller。</p><blockquote><p>nginx 的官网参考 <a href="https://nginx.org/en/docs/">nginx.org</a><br>nginx ingress controller 的官网参考 <a href="https://kubernetes.github.io/ingress-nginx/">ingress-nginx</a> , <a href="https://github.com/kubernetes/ingress-nginx">github ingress-nginx</a></p></blockquote><p>先看一下 nginx ingress controller 的工作原理<br><img src="https://static.longalong.cn/img/20230306234451.png"></p><p>在这个过程中，ingress-nginx 的职责是 <strong>接收 api-server 中的资源变化，并转化成 nginx 需要的格式，通过 http 发送给 nginx</strong></p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx 依然是我们熟悉的那个 nginx，但是和传统我们使用的方式不同，所有资源变化的处理，全都是交给  <code>xxx_by_lua</code> ，包括我们本次最需要被扒的 <code>balancer</code> 。</p><p>balancer 的入口文件是 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer.lua">lua/balancer.lua</a> ，可以看到有这样的内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ngx_balancer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ngx.balancer&quot;</span>)<br><span class="hljs-keyword">local</span> round_robin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.round_robin&quot;</span>)<br><span class="hljs-keyword">local</span> chash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.chash&quot;</span>)<br><span class="hljs-keyword">local</span> chashsubset = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.chashsubset&quot;</span>)<br><span class="hljs-keyword">local</span> sticky_balanced = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.sticky_balanced&quot;</span>)<br><span class="hljs-keyword">local</span> sticky_persistent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.sticky_persistent&quot;</span>)<br><span class="hljs-keyword">local</span> ewma = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.ewma&quot;</span>)<br><br><span class="hljs-keyword">local</span> DEFAULT_LB_ALG = <span class="hljs-string">&quot;round_robin&quot;</span><br><span class="hljs-keyword">local</span> IMPLEMENTATIONS = &#123;<br>  round_robin = round_robin,<br>  chash = chash,<br>  chashsubset = chashsubset,<br>  sticky_balanced = sticky_balanced,<br>  sticky_persistent = sticky_persistent,<br>  ewma = ewma,<br>&#125;<br><br><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><span class="hljs-keyword">local</span> balancers = &#123;&#125;<br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_implementation</span><span class="hljs-params">(backend)</span></span><br>  <span class="hljs-keyword">local</span> name = backend[<span class="hljs-string">&quot;load-balance&quot;</span>] <span class="hljs-keyword">or</span> DEFAULT_LB_ALG<br><br>  <span class="hljs-keyword">if</span> backend[<span class="hljs-string">&quot;sessionAffinityConfig&quot;</span>] <span class="hljs-keyword">and</span><br>     backend[<span class="hljs-string">&quot;sessionAffinityConfig&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>] == <span class="hljs-string">&quot;cookie&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> backend[<span class="hljs-string">&quot;sessionAffinityConfig&quot;</span>][<span class="hljs-string">&quot;mode&quot;</span>] == <span class="hljs-string">&quot;persistent&quot;</span> <span class="hljs-keyword">then</span><br>      name = <span class="hljs-string">&quot;sticky_persistent&quot;</span><br>    <span class="hljs-keyword">else</span><br>      name = <span class="hljs-string">&quot;sticky_balanced&quot;</span><br>    <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">elseif</span> backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>] <span class="hljs-keyword">and</span><br>         backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>][<span class="hljs-string">&quot;upstream-hash-by&quot;</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>][<span class="hljs-string">&quot;upstream-hash-by-subset&quot;</span>] <span class="hljs-keyword">then</span><br>      name = <span class="hljs-string">&quot;chashsubset&quot;</span><br>    <span class="hljs-keyword">else</span><br>      name = <span class="hljs-string">&quot;chash&quot;</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> implementation = IMPLEMENTATIONS[name]<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> implementation <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.WARN, backend[<span class="hljs-string">&quot;load-balance&quot;</span>], <span class="hljs-string">&quot; is not supported, &quot;</span>,<br>            <span class="hljs-string">&quot;falling back to &quot;</span>, DEFAULT_LB_ALG)<br>    implementation = IMPLEMENTATIONS[DEFAULT_LB_ALG]<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">return</span> implementation<br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-built_in">setmetatable</span>(_M, &#123;<span class="hljs-built_in">__index</span> = &#123;<br>  get_implementation = get_implementation,<br>  sync_backend = sync_backend,<br>  route_to_alternative_balancer = route_to_alternative_balancer,<br>  get_balancer = get_balancer,<br>  get_balancer_by_upstream_name = get_balancer_by_upstream_name,<br>&#125;&#125;)<br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>其核心作用，就是做 balancer 的注册及获取。</p><p>我们用的是 chash 的方式，对应的代码在 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer/chash.lua">lua/balancer/chash.lua</a> ，内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> balancer_resty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;balancer.resty&quot;</span>)<br><span class="hljs-keyword">local</span> resty_chash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;resty.chash&quot;</span>)<br><span class="hljs-keyword">local</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>)<br><span class="hljs-keyword">local</span> ngx_log = ngx.<span class="hljs-built_in">log</span><br><span class="hljs-keyword">local</span> ngx_ERR = ngx.ERR<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><br><span class="hljs-keyword">local</span> _M = balancer_resty:new(&#123; factory = resty_chash, name = <span class="hljs-string">&quot;chash&quot;</span> &#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(self, backend)</span></span><br>  <span class="hljs-keyword">local</span> nodes = util.get_nodes(backend.endpoints)<br>  <span class="hljs-keyword">local</span> complex_val, err =<br>    util.parse_complex_value(backend[<span class="hljs-string">&quot;upstreamHashByConfig&quot;</span>][<span class="hljs-string">&quot;upstream-hash-by&quot;</span>])<br>  <span class="hljs-keyword">if</span> err ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>    ngx_log(ngx_ERR, <span class="hljs-string">&quot;could not parse the value of the upstream-hash-by: &quot;</span>, err)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> o = &#123;<br>    instance = <span class="hljs-built_in">self</span>.factory:new(nodes),<br>    hash_by = complex_val,<br>    traffic_shaping_policy = backend.trafficShapingPolicy,<br>    alternative_backends = backend.alternativeBackends,<br>  &#125;<br>  <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br>  <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>  <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.balance</span><span class="hljs-params">(self)</span></span><br>  <span class="hljs-keyword">local</span> key = util.generate_var_value(<span class="hljs-built_in">self</span>.hash_by)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.instance:<span class="hljs-built_in">find</span>(key)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>其实这里面什么都没做，就是封装了一下 resty.chash ，继续扒一下这个库的源码 <a href="https://github.com/openresty/lua-resty-balancer/blob/master/lib/resty/chash.lua">openresty/lua-resty-balancer/lib/resty/chash.lua</a>，内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs lua">ffi.cdef<span class="hljs-string">[[</span><br><span class="hljs-string">typedef unsigned int uint32_t;</span><br><span class="hljs-string"></span><br><span class="hljs-string">typedef struct &#123;</span><br><span class="hljs-string">    uint32_t hash;</span><br><span class="hljs-string">    uint32_t id;</span><br><span class="hljs-string">&#125; chash_point_t;</span><br><span class="hljs-string"></span><br><span class="hljs-string">void chash_point_init(chash_point_t *points, uint32_t base_hash, uint32_t start,</span><br><span class="hljs-string">    uint32_t num, uint32_t id);</span><br><span class="hljs-string">int chash_point_sort(chash_point_t *points, uint32_t size);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int chash_point_add(chash_point_t *old_points, uint32_t old_length,</span><br><span class="hljs-string">    uint32_t base_hash, uint32_t from, uint32_t num, uint32_t id,</span><br><span class="hljs-string">    chash_point_t *new_points);</span><br><span class="hljs-string">int chash_point_reduce(chash_point_t *old_points, uint32_t old_length,</span><br><span class="hljs-string">    uint32_t base_hash, uint32_t from, uint32_t num, uint32_t id);</span><br><span class="hljs-string">void chash_point_delete(chash_point_t *old_points, uint32_t old_length,</span><br><span class="hljs-string">    uint32_t id);</span><br><span class="hljs-string">]]</span><br><br><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><br><span class="hljs-keyword">local</span> clib = load_shared_lib(<span class="hljs-string">&quot;librestychash&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> clib <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;can not load librestychash&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> CONSISTENT_POINTS = <span class="hljs-number">160</span>   <span class="hljs-comment">-- points per server</span><br><span class="hljs-keyword">local</span> pow32 = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>)<br><br><span class="hljs-keyword">local</span> chash_point_t = ffi.typeof(<span class="hljs-string">&quot;chash_point_t[?]&quot;</span>)<br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_precompute</span><span class="hljs-params">(nodes)</span></span><br>// 省略<br>    <span class="hljs-keyword">for</span> id, weight <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(nodes) <span class="hljs-keyword">do</span><br>// 省略<br>        clib.chash_point_init(points, base_hash, start, num, index)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> clib.chash_point_sort(points, npoints) ~= CHASH_OK <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;no memory&quot;</span>)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> ids, points, npoints, newnodes<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(_, nodes)</span></span><br>// 省略<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.reinit</span><span class="hljs-params">(self, nodes)</span></span><br>// 省略<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_delete</span><span class="hljs-params">(self, id)</span></span><br>// 省略<br>    clib.chash_point_delete(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, index)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_incr</span><span class="hljs-params">(self, id, weight)</span></span><br>// 省略<br>    <span class="hljs-keyword">local</span> base_hash = bxor(crc32(<span class="hljs-built_in">tostring</span>(id)), <span class="hljs-number">0xffffffff</span>)<br>    <span class="hljs-keyword">local</span> rc = clib.chash_point_add(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, base_hash,old_weight * CONSISTENT_POINTS, weight * CONSISTENT_POINTS,index, new_points)<br>// 省略<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_decr</span><span class="hljs-params">(self, id, weight)</span></span><br>// 省略<br>    <span class="hljs-keyword">local</span> rc = clib.chash_point_reduce(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, base_hash,from, num, index)<br><span class="hljs-keyword">end</span><br><br><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_find_id</span><span class="hljs-params">(points, npoints, hash)</span></span><br>    <span class="hljs-keyword">local</span> step = pow32 / npoints<br>    <span class="hljs-keyword">local</span> index = <span class="hljs-built_in">floor</span>(hash / step)<br><br>    <span class="hljs-keyword">local</span> max_index = npoints - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">-- it seems safer to do this</span><br>    <span class="hljs-keyword">if</span> index &gt; max_index <span class="hljs-keyword">then</span><br>        index = max_index<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">-- find the first points &gt;= hash</span><br>    <span class="hljs-keyword">if</span> points[index].hash &gt;= hash <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">for</span> i = index, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span> <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">if</span> points[i - <span class="hljs-number">1</span>].hash &lt; hash <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> points[i].id, i<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">return</span> points[<span class="hljs-number">0</span>].id, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">for</span> i = index + <span class="hljs-number">1</span>, max_index <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> hash &lt;= points[i].hash <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> points[i].id, i<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> points[<span class="hljs-number">0</span>].id, <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.find</span><span class="hljs-params">(self, key)</span></span><br>    <span class="hljs-keyword">local</span> hash = crc32(<span class="hljs-built_in">tostring</span>(key))<br><br>    <span class="hljs-keyword">local</span> id, index = _find_id(<span class="hljs-built_in">self</span>.points, <span class="hljs-built_in">self</span>.npoints, hash)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.ids[id], index<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>可以看到，这个文件实现了 <code>find</code> 的方法，而底层 hash 环维护的事交给了 <code>librestychash</code> 这个 clib，继续看一下 <a href="https://github.com/openresty/lua-resty-balancer/blob/master/chash.c">openresty/lua-resty-balancer/chash.c</a>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint32_t</span> crc32_table256[] = &#123;<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x77073096</span>, <span class="hljs-number">0xee0e612c</span>, <span class="hljs-number">0x990951ba</span><br>    <span class="hljs-comment">// 省略……</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">crc32_update</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *crc, u_char *p, <span class="hljs-keyword">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>  c;<br><br>    c = *crc;<br><br>    <span class="hljs-keyword">while</span> (len--) &#123;<br>        c = crc32_table256[(c ^ *p++) &amp; <span class="hljs-number">0xff</span>] ^ (c &gt;&gt; <span class="hljs-number">8</span>);<br>    &#125;<br><br>    *crc = c;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_init_crc</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *arr, <span class="hljs-keyword">uint32_t</span> start, <span class="hljs-keyword">uint32_t</span> base_hash,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> from, <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">chash_point_t</span> *node;<br>    <span class="hljs-keyword">uint32_t</span> i, hash;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">uint32_t</span>                        value;<br>        u_char                          byte[<span class="hljs-number">4</span>];<br>    &#125; prev_hash;<br><br>    prev_hash.value = <span class="hljs-number">0</span>;<br>    node = &amp;arr[start];<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; from + num; i++) &#123;<br>        hash = base_hash;<br>        crc32_update(&amp;hash, prev_hash.byte, <span class="hljs-number">4</span>);<br>        crc32_final(hash);<br><br>        <span class="hljs-keyword">if</span> (i &gt;= from) &#123;<br>            node-&gt;hash = hash;<br>            node-&gt;id = id;<br>            node = node + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* no big performace different in my test */</span><br><br>        <span class="hljs-comment">/* this only works when have little endian */</span><br>        <span class="hljs-comment">// prev_hash.value = hash;</span><br><br>        prev_hash.byte[<span class="hljs-number">0</span>] = (u_char) (hash &amp; <span class="hljs-number">0xff</span>);<br>        prev_hash.byte[<span class="hljs-number">1</span>] = (u_char) ((hash &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>);<br>        prev_hash.byte[<span class="hljs-number">2</span>] = (u_char) ((hash &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>);<br>        prev_hash.byte[<span class="hljs-number">3</span>] = (u_char) ((hash &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_init</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *arr, <span class="hljs-keyword">uint32_t</span> base_hash, <span class="hljs-keyword">uint32_t</span> start,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    chash_point_init_crc(arr, start, base_hash, <span class="hljs-number">0</span>, num, id);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_sort</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> arr[], <span class="hljs-keyword">uint32_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">chash_point_t</span> *points;<br>    <span class="hljs-keyword">chash_point_t</span> *node;<br>    <span class="hljs-keyword">int</span> i, j, index, start, end;<br>    <span class="hljs-keyword">uint32_t</span> min_sz, m, step;<br><br>    <span class="hljs-comment">/* not sure 1.6 is the best */</span><br>    min_sz = n * <span class="hljs-number">1.6</span>;<br>    m = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">while</span> (m &lt;= min_sz) &#123;<br>        m *= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    step = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>) / m;<br><br>    points = (<span class="hljs-keyword">chash_point_t</span> *) <span class="hljs-built_in">calloc</span>(m, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">chash_point_t</span>));<br>    <span class="hljs-keyword">if</span> (points == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        node = &amp;arr[i];<br>        index = node-&gt;hash / step;<br><br>        assert(index &lt; m); <span class="hljs-comment">// index must less than m</span><br><br>        <span class="hljs-keyword">for</span> (end = index; end &gt;= <span class="hljs-number">0</span>; end--) &#123;<br>            <span class="hljs-keyword">if</span> (points[end].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> insert;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (node-&gt;hash &gt;= points[end].hash) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (start = end - <span class="hljs-number">1</span>; start &gt;= <span class="hljs-number">0</span>; start--) &#123;<br>            <span class="hljs-keyword">if</span> (points[start].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">/* left shift before end */</span><br>                <span class="hljs-keyword">for</span> (j = start; j &lt; end; j++) &#123;<br>                    points[j].hash = points[j + <span class="hljs-number">1</span>].hash;<br>                    points[j].id = points[j + <span class="hljs-number">1</span>].id;<br>                &#125;<br><br>                <span class="hljs-comment">/* points[end] is empty now */</span><br><br>                <span class="hljs-comment">/* left shift after end when node-&gt;hash is bigger than them */</span><br>                <span class="hljs-comment">/* only end == index can match this */</span><br>                <span class="hljs-keyword">while</span> (end + <span class="hljs-number">1</span> &lt; m<br>                       &amp;&amp; points[end + <span class="hljs-number">1</span>].id != <span class="hljs-number">0</span><br>                       &amp;&amp; points[end + <span class="hljs-number">1</span>].hash &lt; node-&gt;hash)<br>                &#123;<br>                    points[end].hash = points[end + <span class="hljs-number">1</span>].hash;<br>                    points[end].id = points[end + <span class="hljs-number">1</span>].id;<br>                    end += <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">goto</span> insert;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* full before index, try to append */</span><br><br>        <span class="hljs-keyword">for</span> (end = end + <span class="hljs-number">1</span>; end &lt; m; end++) &#123;<br>            <span class="hljs-keyword">if</span> (points[end].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">goto</span> insert;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (node-&gt;hash &lt; points[end].hash) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (start = end + <span class="hljs-number">1</span>; start &lt; m; start++) &#123;<br>            <span class="hljs-keyword">if</span> (points[start].id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* right shift */</span><br>        <span class="hljs-keyword">for</span> (j = start; j &gt; end; j--) &#123;<br>            points[j].hash = points[j - <span class="hljs-number">1</span>].hash;<br>            points[j].id = points[j - <span class="hljs-number">1</span>].id;<br>        &#125;<br><br>insert:<br>        assert(end &lt; m &amp;&amp; end &gt;= <span class="hljs-number">0</span>);<br><br>        points[end].id = node-&gt;id;<br>        points[end].hash = node-&gt;hash;<br>    &#125;<br><br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (points[i].id != <span class="hljs-number">0</span>) &#123;<br>            arr[j].id = points[i].id;<br>            arr[j].hash = points[i].hash;<br>            j++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(points);<br><br>    <span class="hljs-keyword">return</span> CHASH_OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_add</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *old_points, <span class="hljs-keyword">uint32_t</span> old_length,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> base_hash, <span class="hljs-keyword">uint32_t</span> from, <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">chash_point_t</span> *new_points)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, j, k;<br>    <span class="hljs-keyword">chash_point_t</span> *tmp_points;<br><br>    tmp_points = (<span class="hljs-keyword">chash_point_t</span> *) <span class="hljs-built_in">calloc</span>(num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">chash_point_t</span>));<br>    <span class="hljs-keyword">if</span> (tmp_points == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    chash_point_init_crc(tmp_points, <span class="hljs-number">0</span>, base_hash, from, num, id);<br><br>    <span class="hljs-keyword">if</span> (chash_point_sort(tmp_points, num) != CHASH_OK) &#123;<br>        <span class="hljs-built_in">free</span>(tmp_points);<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    j = num - <span class="hljs-number">1</span>;<br>    k = old_length + num - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (i = old_length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, k--) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp_points[j].hash &gt; old_points[i].hash) &#123;<br>            new_points[k].hash = tmp_points[j].hash;<br>            new_points[k].id = tmp_points[j].id;<br><br>            j--;<br>            k--;<br>        &#125;<br><br>        new_points[k].hash = old_points[i].hash;<br>        new_points[k].id = old_points[i].id;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; j--, k--) &#123;<br>        new_points[k].hash = tmp_points[j].hash;<br>        new_points[k].id = tmp_points[j].id;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(tmp_points);<br><br>    <span class="hljs-keyword">return</span> CHASH_OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_reduce</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *old_points, <span class="hljs-keyword">uint32_t</span> old_length,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint32_t</span> base_hash, <span class="hljs-keyword">uint32_t</span> from, <span class="hljs-keyword">uint32_t</span> num, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, j, k;<br>    <span class="hljs-keyword">chash_point_t</span> *tmp_points;<br><br>    tmp_points = (<span class="hljs-keyword">chash_point_t</span> *) <span class="hljs-built_in">calloc</span>(num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">chash_point_t</span>));<br><br>    chash_point_init_crc(tmp_points, <span class="hljs-number">0</span>, base_hash, from, num, id);<br><br>    <span class="hljs-keyword">if</span> (chash_point_sort(tmp_points, num) != CHASH_OK) &#123;<br>        <span class="hljs-built_in">free</span>(tmp_points);<br>        <span class="hljs-keyword">return</span> CHASH_ERR;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; i &lt; old_length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; num<br>            &amp;&amp; old_points[i].hash == tmp_points[j].hash<br>            &amp;&amp; old_points[i].id == id)<br>        &#123;<br>            j++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i != k) &#123;<br>            old_points[k].hash = old_points[i].hash;<br>            old_points[k].id = old_points[i].id;<br>        &#125;<br>        k++;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(tmp_points);<br><br>    <span class="hljs-keyword">return</span> CHASH_OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">chash_point_delete</span><span class="hljs-params">(<span class="hljs-keyword">chash_point_t</span> *old_points, <span class="hljs-keyword">uint32_t</span> old_length, <span class="hljs-keyword">uint32_t</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, j;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; old_length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (old_points[i].id == id) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i != j) &#123;<br>            old_points[j].hash = old_points[i].hash;<br>            old_points[j].id = old_points[i].id;<br>        &#125;<br>        j++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是 chash 本身的实现了，比较简单，主要的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> hash;<br>    <span class="hljs-keyword">uint32_t</span> id;<br>&#125; <span class="hljs-keyword">chash_point_t</span>;<br></code></pre></td></tr></table></figure><p>这是一个 point，理解成是 hash 环上的每一个桩就行了，整个 hash 环使用数组来实现。</p><h2 id="我们遇到的问题"><a href="#我们遇到的问题" class="headerlink" title="我们遇到的问题"></a>我们遇到的问题</h2><h3 id="背景场景"><a href="#背景场景" class="headerlink" title="背景场景"></a>背景场景</h3><p>使用的 ingress-nginx 做应用网关，应用中有一个 websocket 的服务，会有大量的连接保持着。 同时，为了让缓存发挥作用，我们使用了 <a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash">nginx consistent hash</a> 的方式让同一个 room 下的连接在同一个 pod 上。</p><p>存在隐患的场景有如下 2 个:</p><ol><li><p>当 ingress 发生变化，<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#worker-shutdown-timeout">ingress-nginx</a>会在<a href="https://nginx.org/en/docs/ngx_core_module.html#worker_shutdown_timeout">一段时间后</a>强制停止 worker 进程。这会导致短时间内大量 websocket 重新连接，无异于一次攻击 🐶 ……</p></li><li><p>当服务进行更新部署时，若采用大批量更新，则会导致短时间大量重连，和场景 1 有异曲同工之效；若采用小批量滚动更新，则会导致部分用户会进行多次重连。</p></li></ol><h3 id="可能的思路"><a href="#可能的思路" class="headerlink" title="可能的思路"></a>可能的思路</h3><h4 id="能否让-hash-环不发生变化？"><a href="#能否让-hash-环不发生变化？" class="headerlink" title="能否让 hash 环不发生变化？"></a>能否让 hash 环不发生变化？</h4><p>从 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer/chash.lua">nginx-ingress/lua/chash.lua</a> 中可以看到，hash 环生成的方式是以 endpoints 为基准的，如果 endpoints 不发生改变，则 hash 环不会发生改变。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(self, backend)</span></span><br>  <span class="hljs-keyword">local</span> nodes = util.get_nodes(backend.endpoints)<br>  // 省略……<br>  <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>ep 是每一个 pod 的 ip，会随着 pod 的更新而更新，所以答案几乎是否定的。(当然还是有一些奇怪的操作可以达到目标，但不常规操作还是少搞的好，不然就是大坑一个)</p><h4 id="能否让负载均衡可控？"><a href="#能否让负载均衡可控？" class="headerlink" title="能否让负载均衡可控？"></a>能否让负载均衡可控？</h4><p>嗯，这个自然是可以的，基本 demo 可以查看 <a href="/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html" name="记一次有状态服务的负载均衡方案探索" >记一次有状态服务的负载均衡方案探索</a></p><p>当然，为了让整套体系能够起作用，还需要做大量的体系性工作，之前有一个简单的 demo，可以查看 <a href="/longblog/posts/23_03_05_23_01_a_record_of_sharing_of_k8s.html#part2: 如何用 operator 玩点有意思的事 " name="记录一次在团队内的k8s分享" > 用 operator 做点有趣的事</a> </p><p>这里可以更细致地做一些原型出来</p><h4 id="能不能让网关重启不会导致连接断掉？"><a href="#能不能让网关重启不会导致连接断掉？" class="headerlink" title="能不能让网关重启不会导致连接断掉？"></a>能不能让网关重启不会导致连接断掉？</h4><p>按照调研，目前市面上能看到 mosn 是做了连接平滑迁移的，这里去看一下，它具体是怎么做到的，有什么优劣？</p><p>mosn 的代码地址： <a href="https://github.com/mosn/mosn">https://github.com/mosn/mosn</a><br>一篇关于 mosn 是怎么做的迁移： <a href="https://mosn.io/blog/posts/nginx-envoy-mosn-hot-upgrade/">nginx vs envoy vs mosn 平滑升级原理</a></p><p>基本结论是： mosn 和 envoy 都使用了 UDS (unix domain sockets) 的技术，这是在 linux 内核 3.5+ 支持的一种文件描述符传递的方案。</p><p>追了一下 mosn 的代码，核心逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// transferHandler is called on recv transfer request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transferHandler</span><span class="hljs-params">(c net.Conn, handler types.ConnectionHandler, transferMap *sync.Map)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferHandler panic %v&quot;</span>, r)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">defer</span> c.Close()<br><br>uc, ok := c.(*net.UnixConn)<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] unexpected FileConn type; expected UnixConn, got %T&quot;</span>, c)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// recv type</span><br>conn, err := transferRecvType(uc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferRecvType error :%v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> conn != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// transfer read</span><br><span class="hljs-comment">// recv header + buffer</span><br>dataBuf, tlsBuf, err := transferReadRecvData(uc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferRecvData error :%v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>connection := transferNewConn(conn, dataBuf, tlsBuf, handler, transferMap)<br><span class="hljs-keyword">if</span> connection != <span class="hljs-literal">nil</span> &#123;<br>transferSendID(uc, connection.id)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>transferSendID(uc, transferErr)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// transfer write</span><br><span class="hljs-comment">// recv header + buffer</span><br>id, buf, err := transferWriteRecvData(uc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferRecvData error :%v&quot;</span>, err)<br>&#125;<br>connection := transferFindConnection(transferMap, <span class="hljs-keyword">uint64</span>(id))<br><span class="hljs-keyword">if</span> connection == <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferFindConnection failed, id = %d&quot;</span>, id)<br><span class="hljs-keyword">return</span><br>&#125;<br>err = transferWriteBuffer(connection, buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.DefaultLogger.Errorf(<span class="hljs-string">&quot;[network] [transfer] [handler] transferWriteBuffer error :%v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于具体细节的问题，可以再细致看一下代码，或者调试一下。</p><p>关于转移连接描述符的操作，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 老的，发送 fd</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transferSendFD</span><span class="hljs-params">(uc *net.UnixConn, file *os.File)</span> <span class="hljs-title">error</span></span> &#123;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// transfer read</span><br>buf[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> file == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;transferSendFD conn is nil&quot;</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>rights := syscall.UnixRights(<span class="hljs-keyword">int</span>(file.Fd()))<br>n, oobn, err := uc.WriteMsgUnix(buf, rights, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;WriteMsgUnix: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> n != <span class="hljs-built_in">len</span>(buf) || oobn != <span class="hljs-built_in">len</span>(rights) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;WriteMsgUnix = %d, %d; want 1, %d&quot;</span>, n, oobn, <span class="hljs-built_in">len</span>(rights))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 新的，接收 fd</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transferRecvFD</span><span class="hljs-params">(oob []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(net.Conn, error)</span></span> &#123;<br>scms, err := unix.ParseSocketControlMessage(oob)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;ParseSocketControlMessage: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(scms) != <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;expected 1 SocketControlMessage; got scms = %#v&quot;</span>, scms)<br>&#125;<br>scm := scms[<span class="hljs-number">0</span>]<br>gotFds, err := unix.ParseUnixRights(&amp;scm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unix.ParseUnixRights: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(gotFds) != <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;wanted 1 fd; got %#v&quot;</span>, gotFds)<br>&#125;<br>f := os.NewFile(<span class="hljs-keyword">uintptr</span>(gotFds[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;fd-from-old&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br>conn, err := net.FileConn(f)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;FileConn error :%v&quot;</span>, gotFds)<br>&#125;<br><span class="hljs-keyword">return</span> conn, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以画一下流程图，可能更好理解一些。</p><h4 id="能否使用-UDS-解决业务升级问题？"><a href="#能否使用-UDS-解决业务升级问题？" class="headerlink" title="能否使用 UDS 解决业务升级问题？"></a>能否使用 UDS 解决业务升级问题？</h4><p>实现上当然是 ok 的，但不建议这么搞，主要有以下原因：</p><ul><li>业务不是网关，代码的稳定性是很不好的，需要经常变更，为了满足隐藏的一些需求，还是在业务层做特定机制的建设更好。</li><li>我们的服务都运行在容器中，对 k8s 而言，镜像是不可变的，平滑升级导致我们在不可变的镜像中使用了可变的进程，容易出问题。</li></ul><h3 id="我们究竟要解决什么问题？"><a href="#我们究竟要解决什么问题？" class="headerlink" title="我们究竟要解决什么问题？"></a>我们究竟要解决什么问题？</h3><ul><li>让大规模重连尽量不要发生<ul><li>网关独立，不被其他对网关的改动而影响</li><li>使用能平滑迁移的网关，如 mosn</li><li>业务应用平滑启动<ul><li>少量 pod 滚动更新<ul><li>坏处: 部分连接会多次重连(这里涉及 ws 服务目前均衡的具体实现，需要再细看代码) ； </li><li>好处: 对数据库的压力较小 ； </li><li>要解决的问题: ws 服务本身会不会被突然重连的压力搞出问题 =&gt; 加多一些 vnode</li></ul></li><li>蓝绿发布、连接迁移</li></ul></li></ul></li><li>让大规模重连也不会引发重大问题<ul><li>session 机制 (这个我觉得还是很有效的)</li><li>考虑用 redis、甚至内存 的方式做连接信息管理</li><li>限流降级熔断机制<ul><li>网关层限流等</li><li>业务层限流等</li><li>前端自身限流等 (至少不要疯狂重连吧 😂 )</li></ul></li></ul></li><li>其他可能的问题<ul><li>再细致地查一查，经常断掉是怎么发生的，会不会是心跳机制的问题</li><li>内存泄漏和协程泄漏往往是同时发生的，是不是可以把协程池弄上，然后监控起来</li><li>前端的策略还是有很多可讨论的，比如 长期在后台的页面，是不是把连接断了不要连了</li><li>多个连接的价值需不需要再探讨一下？ (不一定，紧要性不高)</li><li>每天晚上的几千个连接还是有点问题的，查一查心里稳妥些</li></ul></li></ul><blockquote><p>实际上，我们可能主要的问题还是 mongodb 索引少建了一个，在此基础上或许一切的问题都是可以堆一点资源就解决的 🐶 ……<br>业务有时候就是这样，解决问题或许比牛逼的技术有更大业务价值……</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>openresty 库中还有很多实用的工具，之后有机会可以详细扒一下，例如:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs text">├── aes.lua<br>├── chash.lua<br>├── cookie.lua<br>├── core<br>│   ├── base.lua<br>│   ├── base64.lua<br>│   ├── ctx.lua<br>│   ├── exit.lua<br>│   ├── hash.lua<br>│   ├── misc.lua<br>│   ├── ndk.lua<br>│   ├── phase.lua<br>│   ├── regex.lua<br>│   ├── request.lua<br>│   ├── response.lua<br>│   ├── shdict.lua<br>│   ├── time.lua<br>│   ├── uri.lua<br>│   ├── utils.lua<br>│   ├── var.lua<br>│   └── worker.lua<br>├── core.lua<br>├── limit<br>│   ├── conn.lua<br>│   ├── count.lua<br>│   ├── req.lua<br>│   └── traffic.lua<br>├── md5.lua<br>├── random.lua<br>├── roundrobin.lua<br>├── sha.lua<br>├── sha1.lua<br>├── sha224.lua<br>├── sha256.lua<br>├── sha384.lua<br>├── sha512.lua<br>├── string.lua<br>└── upload.lua<br></code></pre></td></tr></table></figure><ol start="2"><li><p>另一个常用的负载方式是 chashsubset ，实现在 <a href="https://github.com/kubernetes/ingress-nginx/blob/main/rootfs/etc/nginx/lua/balancer/chashsubset.lua">chashsubset.lua</a> ，后续可以继续扒一下</p></li><li><p>mosn 的实现中还有很多可以参考的地方，比如 wasm 的扩展方式、xprotocal 的扩展方式，看看还是有价值的</p></li></ol><hr><blockquote><p>Anticipate the difficult by managing the easy.<br>— <cite>Laozi</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近因为 nginx 网关的问题，导致服务有诸多不稳定的风险，因此需要更近一步去做网关的工作。&lt;/p&gt;
&lt;p&gt;之前预判过将来会因无法自定义负</summary>
      
    
    
    
    
    <category term="code reading" scheme="https://iamlongalong.github.io/longblog/tags/code-reading/"/>
    
    <category term="nginx" scheme="https://iamlongalong.github.io/longblog/tags/nginx/"/>
    
    <category term="nginx ingress" scheme="https://iamlongalong.github.io/longblog/tags/nginx-ingress/"/>
    
    <category term="ingress" scheme="https://iamlongalong.github.io/longblog/tags/ingress/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在团队内的k8s分享</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_03_05_23_01_a_record_of_sharing_of_k8s.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_03_05_23_01_a_record_of_sharing_of_k8s.html</id>
    <published>2023-03-05T15:51:00.000Z</published>
    <updated>2023-03-06T17:05:16.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天在后端团队中分享了一下 k8s ，之前也有过好几次 k8s 的专题分享，例如 用 devspace 优化开发环境、k8s pod 的生命周期、抓包看看 k8s 网络实现原理…… 都可以算得上是对 k8s 的 「现状」 做的分享。</p><p>这一次换个视角，从 k8s 的 「前世」做分享，企图从 k8s 诞生的历史使命角度，认识 k8s 设计的背景以及原因。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>整个分享分成了 2 part，前半部分从理论上对 k8s 产生的背景 以及 建模设计 做了分享，后半部分分享了用 client-go 实现一个高可扩展的游戏服务器，有几个有意思的技术点。</p><p>分享的视频就先不放了，分享的 PPT 可以通过👇🏻 这个查看，不过光看 ppt 确实有点跳跃，之后时间空点了再把分享的文字稿弄一下。</p><h3 id="part1-站在女娲的视角看-k8s"><a href="#part1-站在女娲的视角看-k8s" class="headerlink" title="part1: 站在女娲的视角看 k8s"></a>part1: 站在女娲的视角看 k8s</h3><iframe src="https://blog.longalong.cn/slides/learn_k8s_on_the_view_of_nvwa/index.html#/" width="100%" height="800px"> 一次 k8s 的分享</iframe><h3 id="part2-如何用-operator-玩点有意思的事"><a href="#part2-如何用-operator-玩点有意思的事" class="headerlink" title="part2: 如何用 operator 玩点有意思的事"></a>part2: 如何用 operator 玩点有意思的事</h3><p>之后玩了一下周末做的游戏 (服务端开发 + 前端接口重新适配)</p><iframe src="https://blog.longalong.cn/slides/play_something_interesting_with_k8s/index.html#/" width="100%" height="800px"> 一次 k8s 的分享</iframe><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整体氛围还是不错的，实践部分的游戏环节也为整个无聊的分享增加了一些趣味 😂 </p><p>另外，上面这个 ppt 是用 <a href="https://github.com/MSzturc/obsidian-advanced-slides">slides</a> 制作的，用 markdown 写的内容，很简洁，可以让我们把精力聚焦到 内容本身 上，值得推荐。 (和以前的 webppt 类似)</p><hr><blockquote><p>Sometimes being a friend means mastering the art of timing. There is a time for silence. A time to let go and allow people to hurl themselves into their own destiny. And a time to prepare to pick up the pieces when it’s all over.<br>— <cite>Octavia E. Butler</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前几天在后端团队中分享了一下 k8s ，之前也有过好几次 k8s 的专题分享，例如 用 devspace 优化开发环境、k8s pod 的生</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://iamlongalong.github.io/longblog/tags/k8s/"/>
    
    <category term="share" scheme="https://iamlongalong.github.io/longblog/tags/share/"/>
    
    <category term="团队分享" scheme="https://iamlongalong.github.io/longblog/tags/%E5%9B%A2%E9%98%9F%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>prometheus代码走读</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:23:57.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>prometheus 还是很牛逼的，作为云原生监控系统的事实标准，值得一读。</p><p>生态中对应的还有  AlertManager、pushgateway、operator，之前已经走读过 alertManager 的代码，详见 <a href="/longblog/posts/23_02_09_15_15_code_reading_of_alert_manager.html" name="alertmanager等监控项目源码走读" >alertmanager等监控项目源码走读</a>， 这里，走读一下 pushgateway 和 prometheus 的代码。</p><h2 id="代码走读"><a href="#代码走读" class="headerlink" title="代码走读"></a>代码走读</h2><h3 id="pushgateway"><a href="#pushgateway" class="headerlink" title="pushgateway"></a>pushgateway</h3><ul><li>main.go : 解析参数，启动 server。 http server 用的 promethues 包中的，这在 alertManager 中是一样的。</li><li>handler : 实现各种接口处理, 用闭包的方式，避免了一些全局变量的使用，例如 logger。<ul><li>支持 protobuf 的 encoding 方式，model 在 prometheus 的 client 中定义的 MetricFamily</li><li>使用 parser.TextToMetricFamilies 解析 prometheus 的值</li><li>status.go 中使用了 tempate，并注入了 func，这种方式在一些简单的场景下很好用，毕竟不是所有项目都适合上一套前端框架。</li></ul></li><li>storage : 存储的实现，用的 disk 做存储，存储格式直接用的 gob，在直接存储对象上，非常方便。</li><li>asset : 将 ui 打包到二进制中。</li></ul><p>这个项目的功能和结构虽然都非常简单，但却有很多值得参考的地方，尤其是 使用 gob 直接存对象的方式、直接在 http 接口中使用 protobuf 做解析、将 asset 直接打包到 二进制中、简单场景直接使用 template……</p><h3 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h3><ul><li>cmd : 入口文件，处理 config bind、validate、init，启动服务等。 promtool 提供了 cli 和 prometheus 交互的方式。</li><li>discovery : 抓取的 targets 管理<ul><li>targetGroup 代表一组 target endpoint，而在 scrape.target 中的 Target 则是一个具体的 endpoint。这里可能比较难理解 target 的 url 从哪里来，在 scrape.target.Target.URL() 中可以看到，host、metrics_path 都在 label 中，是特定的 label。</li><li>manager.go : manager 管理接收到的新的 endpoints (map[poolKey]map[string]*targetgroup.Group)，在 startProvider 中对接管道。 provider 是实际的 metrics 的提供者，他们关心 endpoints 的变化。discovery 是发现变化的，例如 file、k8s、zk、http 等。</li><li>registry.go : 使用注册方式，由 config 生成实际的 discovery，然后注册到中心的 hub 中。 类似于 builder 的方式，生成的 discovery 通过 Run() 方法启动。 这种做法很通用，在 grpc 的各种包里也有同样的操作。 </li><li>kubernetes.go<ul><li>使用 cache informer 可以减轻对 k8s api server 的压力，这里的代码参考有价值</li><li>使用 workqueue，把接收到的消息异步处理，避免 event 处理的时序错误。</li></ul></li><li>xds.go : 说是 xds，实际上是 kuma，因为 kuma 是基于 envoy 的，而 xds 则是 envoy 的 discoverys。 这块儿可以进一步看下 envoy 的东西。</li><li>在类似于 http、dns、docker 等方式中，因为没有<code>监听</code>的能力，因此抽象了一个 refresh 的 discovery wrapper。</li></ul></li><li>model : 在业务中使用的模型，包括处理方法。 核心模型定义在 prompb 中。<ul><li>rulefmt : 告警规则的模型</li><li>textparse : 有三种格式，text 格式、proto buffer、openmetrics。结合 go_client 可以拿到 metrics_family。 text 格式的代码是一个不错的词法解析器的参考，另外的参考可以看 go-zero 对 proto 文件的解析。 (当然 promql 也是)</li><li>histogram : 一个 histogram 的实现。</li></ul></li><li>prompb : 核心模型定义</li><li>notifier<ul><li>对 alertmanager 的管理，也有 discovery 的能力，具体在 discovery.legacymanager 中。</li><li>逻辑很简单，Send() 方法吧所有 alerts 存到 queue 中，然后触发 sendall() 。</li><li>接受来自 rule 包的 alerts。</li></ul></li><li>plugins : 目前是注册 discovery 的。</li><li>rules<ul><li>告警规则管理，连接 promql 和 alertmanager。</li><li>分组 (Group)，每个组有一系列具体的监控规则 (rule)，使用 interval 做周期控制，使用 promql 做判断。</li><li>recording.go : 具体的判断 rule (expr)</li><li>alerting.go : alert 的具体状态</li></ul></li><li>scrape<ul><li>抓取 metrics 的具体实现。分 scrape pool 进行抓取，具体的控制过程在 scrapeLoop.scrapeAndReport 中。</li><li>用了 buffer pool 做 bytes 复用。毕竟发起的请求数量很多，可以减少 gc 压力。 具体的 pool 实现在 util.pool 中，可以参考下，这个 pool 做了分 bucket。</li><li>用了 label cache 来保证同一个指标的 label 可以复用而不用重新初始化。</li><li>抓取到数据后的具体的处理逻辑在 scrape.scrapeLoop.append 中，主要是解析指标，并且给 appender 发送数据， appender 是从 scrape.Manager 中传进来的，具体实现在 storage.fanout 中。</li></ul></li><li>util : 一些常用的方法函数， treecache 用 zk 作为具体实现比较有意思。</li><li>web : 提供了 rest api 和 ui。<ul><li>alertmanager 和 pushgateway 都用了把静态资源打包的做法 (http.FS)，但 prometheus 却没有这么做，奇怪。 (更新，还是有的，只是和之前的代码写法有些不一样，用的是 go 的 //go:embed 注释)</li><li>对互联网后端开发而言，很多时候把写 api 作为工作的主体了，但实际上，web 的可能是最简单的部分……</li></ul></li></ul><blockquote><p>最重要的部分放在最后~~</p></blockquote><ul><li>promql : parse 和 query ，具体没怎么看细节。</li><li>storage : tsdb 的接口层，可以对接 remote ，也可以直接使用本地 tsdb。</li><li>tsdb<ul><li>db.go : 启动 tsdb 的入口</li><li>head.go : 插入数据的入口，series 的内存结构等。 是理解数据写入过程的最重要的文件。实际上，head 数据可以看做是 block 在内存中的展开状态，head 中的 chunk 写到一定阶段后就会由 compact 变成 block 存到磁盘中。</li><li>wal.go : 任何的数据操作，都会先写到 log 中，用于保证数据的安全，调用方为 head.Commit。使用 wal 和 checkpoint 是内存数据库非常通用的方法。 checkpoint 的逻辑 和 日志监听的逻辑 在 wlog 中。</li><li>record : 写入 wal 的具体事件的定义。</li><li>compact.go : 处理把数据写入 文件系统 成为一个 block 的过程，包括两类: 把内存中的 head 写入 block；把多个 block 合并，实际调用 index.Writer 和 chunks.Writer 等做实际写入操作。</li><li>block.go : 数据块的定义和操作，管理 读取、写入 block。一个数据块就是 一段时间内的所有数据的集合，包括 采集的指标值 和 指标本身的信息。 是数据最终的存在形态，数据通路是 db =&gt; head =&gt; chunk =&gt; block 。</li><li>chunks 和 chunkenc : chunk 的定义和操作。 chunkenc 中包含了几种 chunk 的序列化方法。</li><li>fileutil : 一些 file 的操作封装<ul><li>mmap : 文件内存映射。是读取 chunk 的方式，保证了低内存占用。</li></ul></li><li>index<ul><li>是理解 <code>持久化</code> 和 <code>查询</code> 最好的方式，分为 符号表 (用于压缩空间)、序列表(用于关联 chunks)、label表和posting表 (用于查询及关联 label 和 name) 以及 TOC (用于定位上述几张表)</li></ul></li><li>有几个重点：<ul><li>理解 series 的概念: 特定的 label 集合。 (series =&gt; labels.Labels)</li><li>理解 series 在内存中的状态 (stripeSeries =&gt; memSeries =&gt; headChunk =&gt; mmapchunk)</li><li>理解 block 的生成流程: series.headchunk =&gt; mmapchunk =&gt; compact/index/meta =&gt; block</li><li>理解一个数据写入的流程: labels+val =&gt; series + val =&gt; chunk</li></ul></li></ul></li></ul><p>设计上的想法:</p><ul><li>对于稍微复杂点的项目，一定会走上分层的道路，分层之后有逐渐会形成以 接口 为传递方式的调用 (而不是实例，否则要写 n 多类似的方法来兼容不同的type)。 接口化之后的好处是 单层内代码更简洁了；坏处是 想要跨层走一次流程会很懵，因为不知道具体的实现方是谁 (一般分层后每层都可能实现相同的方法)。</li></ul><h2 id="一些非常好的参考资料"><a href="#一些非常好的参考资料" class="headerlink" title="一些非常好的参考资料"></a>一些非常好的参考资料</h2><ul><li><a href="https://github.com/prometheus/prometheus/tree/main/tsdb/docs/format">官方文档 tsdb 的序列化结构</a> </li><li><a href="https://ganeshvernekar.com/blog/prometheus-tsdb-the-head-block">prometheus TSDB</a></li><li><a href="https://web.archive.org/web/20210622211933/https://fabxc.org/tsdb/">prometheus 发起人的博客</a></li></ul><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="你想要什么？"><a href="#你想要什么？" class="headerlink" title="你想要什么？"></a>你想要什么？</h3><ul><li>数据库具体究竟是怎么工作的？<ul><li>wal 的具体实现</li><li>block 的具体实现</li></ul></li><li>为什么我们现在脱离了数据库就没法写代码了一样？</li><li>一个这种级别的项目会花多少精力？<ul><li>prometheus 的发起人开始也是自己就发布了版本，而且还做了好多其他项目，这些牛逼的人为什么牛逼？</li></ul></li><li>项目成功的要素有哪些？<ul><li>能力、生态</li></ul></li><li>如何让读源码的收益最大化？<ul><li>通过: 阅读代码<ul><li>知道各自的职能是什么</li><li>知道各自是怎么实现的</li><li>知道相互是怎么连接的</li></ul></li><li>得到: 数据结构 + 过程演变</li><li>最好能: 临摹代码</li><li>如何把这件事做好?<ul><li>先可以大量实践一下，找到一些好的形态</li></ul></li><li>如何像一台机器一样阅读源码？<ul><li>主线流程跑一次</li><li>用 debug</li></ul></li></ul></li><li>LSM tree 和 其他数据库存储模型</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>找一个 LSM tree 的数据库实现看一下 <a href="/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html" name="golevelDB源码走读" >golevelDB源码走读</a></li><li>找一个 B+ tree 的数据库实现看一下 <a href="/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html" name="golevelDB源码走读" >golevelDB源码走读</a></li><li>对 k8s 的部分代码走读一下 <a href="/notpublish/index.html" name="k8s部分源码走读" >k8s部分源码走读</a></li></ul><hr><blockquote><p>We may encounter many defeats, but we must not be defeated.<br>— <cite>Maya Angelou</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;prometheus 还是很牛逼的，作为云原生监控系统的事实标准，值得一读。&lt;/p&gt;
&lt;p&gt;生态中对应的还有  AlertManager、p</summary>
      
    
    
    
    
    <category term="code reading" scheme="https://iamlongalong.github.io/longblog/tags/code-reading/"/>
    
    <category term="monitor" scheme="https://iamlongalong.github.io/longblog/tags/monitor/"/>
    
    <category term="prometheus" scheme="https://iamlongalong.github.io/longblog/tags/prometheus/"/>
    
    <category term="pushgateway" scheme="https://iamlongalong.github.io/longblog/tags/pushgateway/"/>
    
    <category term="代码走读" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BB%A3%E7%A0%81%E8%B5%B0%E8%AF%BB/"/>
    
  </entry>
  
</feed>
