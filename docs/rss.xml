<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Longbao</title>
  
  
  <link href="https://iamlongalong.github.io/longblog/rss.xml" rel="self"/>
  
  <link href="https://iamlongalong.github.io/longblog/"/>
  <updated>2023-03-05T13:43:26.658Z</updated>
  <id>https://iamlongalong.github.io/longblog/</id>
  
  <author>
    <name>longalong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个golang三方库的常规内容</title>
    <link href="https://iamlongalong.github.io/longblog/posts/2302161036.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/2302161036.html</id>
    <published>2023-03-05T15:47:00.000Z</published>
    <updated>2023-03-05T13:43:26.658Z</updated>
    
    <content type="html"><![CDATA[<p>当我们多写一些项目之后，会发现一些通用的方法或工具，于是希望把这些工具提取出来，成为一个独立的库。 例如 redis、kafka 等中间件，或者 ID 生成器、goroutine 等工具。</p><p>一个好的三方库有一些通用的特点，例如：</p><ol><li>用户友好，最好开箱即用</li><li>扩展性强，可自定义</li><li>文档清晰、齐全</li><li>有使用例子</li><li>单测齐全</li><li>接口稳定</li><li>支持调试</li></ol><p>在 golang 中，有一些通用的方式来保证上述的特点。</p><ol><li>提供构造方法，完成初始化</li><li>Options 模式，提供自定义修改，提供默认参数</li><li>提供 readme 文档，用于 github 等平台查看</li><li>提供 doc.go、代码注释，用于 golang 接口文档查看</li><li>部分组件可插拔，基于 接口 + 实现 的方式，提供扩展性</li><li>提供充足的单测</li><li>核心组件基于接口开发，保证接口稳定性</li><li>提供 example 目录</li><li>项目内文件结构清晰，职责分明</li><li>提供 plugin 或者 hook 模式，增强扩展性</li></ol><p>常见的扩展点包括：</p><ol><li>Options 扩展，使用 Options 模式，提供常见的一些 Options 操作</li><li>Logger 使用接口 + 实例化的方式</li><li>提供 Metrics plugin</li><li>提供 Tracing plugin</li><li>提供 多个 Backend (存储类)</li></ol><p>以下，分析几个项目的实践方式：</p><table><thead><tr><th>项目</th><th>初始化</th><th>扩展性</th><th>可调试</th><th>测试齐全</th><th>文档充足</th><th>例子</th><th>扩展点</th><th>项目结构清晰</th><th>接口稳定</th></tr></thead><tbody><tr><td>gorm</td><td>Config</td><td>hook</td><td>log 级别</td><td>√</td><td>doc.go + 代码注释</td><td>无</td><td>options + hook</td><td>√</td><td>×</td></tr><tr><td>go-redis</td><td>Config/Options</td><td>hook</td><td>×</td><td>√</td><td>代码注释</td><td>example_test.go</td><td>options + hook</td><td>√</td><td>√ (universal.Client)</td></tr><tr><td>go-kratos</td><td>Config</td><td>middleware / 接口化</td><td>-</td><td>√</td><td>docs + 代码注释</td><td>无</td><td>Config + middleware + 接口化</td><td>√</td><td>√</td></tr><tr><td>groupcache</td><td>组合</td><td>hook / 接口化</td><td>×</td><td>√</td><td>代码注释</td><td>无</td><td>-</td><td>√</td><td>√</td></tr><tr><td>grpc-go</td><td>Options</td><td>middleware / 接口化</td><td>log、metrics、管理后台</td><td>√</td><td>docs + 代码注释 + proposal</td><td>examples</td><td>Options + middleware + 接口化 + 外接组件</td><td>√</td><td>√</td></tr><tr><td>go-zero</td><td>Config</td><td>middleware</td><td>-</td><td>√</td><td>代码注释</td><td>无</td><td>Config + middleware</td><td>√</td><td>×</td></tr><tr><td>sarama</td><td>Config</td><td>hook</td><td>log 级别 / metrics</td><td>√</td><td>代码注释</td><td>examples</td><td>Config + hook</td><td>×</td><td>√</td></tr></tbody></table><hr><blockquote><p>Do not wait for leaders; do it alone, person to person.<br>— <cite>Mother Teresa</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我们多写一些项目之后，会发现一些通用的方法或工具，于是希望把这些工具提取出来，成为一个独立的库。 例如 redis、kafka 等中间件，或者 ID 生成器、goroutine 等工具。&lt;/p&gt;
&lt;p&gt;一个好的三方库有一些通用的特点，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户</summary>
      
    
    
    
    
    <category term="readingcodes" scheme="https://iamlongalong.github.io/longblog/tags/readingcodes/"/>
    
    <category term="library" scheme="https://iamlongalong.github.io/longblog/tags/library/"/>
    
    <category term="三方库" scheme="https://iamlongalong.github.io/longblog/tags/%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>prometheus代码走读</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:23:57.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>prometheus 还是很牛逼的，作为云原生监控系统的事实标准，值得一读。</p><p>生态中对应的还有  AlertManager、pushgateway、operator，之前已经走读过 alertManager 的代码，详见 <a href="/longblog/posts/23_02_09_15_15_code_reading_of_alert_manager.html" name="alertmanager等监控项目源码走读" >alertmanager等监控项目源码走读</a>， 这里，走读一下 pushgateway 和 prometheus 的代码。</p><h2 id="代码走读"><a href="#代码走读" class="headerlink" title="代码走读"></a>代码走读</h2><h3 id="pushgateway"><a href="#pushgateway" class="headerlink" title="pushgateway"></a>pushgateway</h3><ul><li>main.go : 解析参数，启动 server。 http server 用的 promethues 包中的，这在 alertManager 中是一样的。</li><li>handler : 实现各种接口处理, 用闭包的方式，避免了一些全局变量的使用，例如 logger。<ul><li>支持 protobuf 的 encoding 方式，model 在 prometheus 的 client 中定义的 MetricFamily</li><li>使用 parser.TextToMetricFamilies 解析 prometheus 的值</li><li>status.go 中使用了 tempate，并注入了 func，这种方式在一些简单的场景下很好用，毕竟不是所有项目都适合上一套前端框架。</li></ul></li><li>storage : 存储的实现，用的 disk 做存储，存储格式直接用的 gob，在直接存储对象上，非常方便。</li><li>asset : 将 ui 打包到二进制中。</li></ul><p>这个项目的功能和结构虽然都非常简单，但却有很多值得参考的地方，尤其是 使用 gob 直接存对象的方式、直接在 http 接口中使用 protobuf 做解析、将 asset 直接打包到 二进制中、简单场景直接使用 template……</p><h3 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h3><ul><li>cmd : 入口文件，处理 config bind、validate、init，启动服务等。 promtool 提供了 cli 和 prometheus 交互的方式。</li><li>discovery : 抓取的 targets 管理<ul><li>targetGroup 代表一组 target endpoint，而在 scrape.target 中的 Target 则是一个具体的 endpoint。这里可能比较难理解 target 的 url 从哪里来，在 scrape.target.Target.URL() 中可以看到，host、metrics_path 都在 label 中，是特定的 label。</li><li>manager.go : manager 管理接收到的新的 endpoints (map[poolKey]map[string]*targetgroup.Group)，在 startProvider 中对接管道。 provider 是实际的 metrics 的提供者，他们关心 endpoints 的变化。discovery 是发现变化的，例如 file、k8s、zk、http 等。</li><li>registry.go : 使用注册方式，由 config 生成实际的 discovery，然后注册到中心的 hub 中。 类似于 builder 的方式，生成的 discovery 通过 Run() 方法启动。 这种做法很通用，在 grpc 的各种包里也有同样的操作。 </li><li>kubernetes.go<ul><li>使用 cache informer 可以减轻对 k8s api server 的压力，这里的代码参考有价值</li><li>使用 workqueue，把接收到的消息异步处理，避免 event 处理的时序错误。</li></ul></li><li>xds.go : 说是 xds，实际上是 kuma，因为 kuma 是基于 envoy 的，而 xds 则是 envoy 的 discoverys。 这块儿可以进一步看下 envoy 的东西。</li><li>在类似于 http、dns、docker 等方式中，因为没有<code>监听</code>的能力，因此抽象了一个 refresh 的 discovery wrapper。</li></ul></li><li>model : 在业务中使用的模型，包括处理方法。 核心模型定义在 prompb 中。<ul><li>rulefmt : 告警规则的模型</li><li>textparse : 有三种格式，text 格式、proto buffer、openmetrics。结合 go_client 可以拿到 metrics_family。 text 格式的代码是一个不错的词法解析器的参考，另外的参考可以看 go-zero 对 proto 文件的解析。 (当然 promql 也是)</li><li>histogram : 一个 histogram 的实现。</li></ul></li><li>prompb : 核心模型定义</li><li>notifier<ul><li>对 alertmanager 的管理，也有 discovery 的能力，具体在 discovery.legacymanager 中。</li><li>逻辑很简单，Send() 方法吧所有 alerts 存到 queue 中，然后触发 sendall() 。</li><li>接受来自 rule 包的 alerts。</li></ul></li><li>plugins : 目前是注册 discovery 的。</li><li>rules<ul><li>告警规则管理，连接 promql 和 alertmanager。</li><li>分组 (Group)，每个组有一系列具体的监控规则 (rule)，使用 interval 做周期控制，使用 promql 做判断。</li><li>recording.go : 具体的判断 rule (expr)</li><li>alerting.go : alert 的具体状态</li></ul></li><li>scrape<ul><li>抓取 metrics 的具体实现。分 scrape pool 进行抓取，具体的控制过程在 scrapeLoop.scrapeAndReport 中。</li><li>用了 buffer pool 做 bytes 复用。毕竟发起的请求数量很多，可以减少 gc 压力。 具体的 pool 实现在 util.pool 中，可以参考下，这个 pool 做了分 bucket。</li><li>用了 label cache 来保证同一个指标的 label 可以复用而不用重新初始化。</li><li>抓取到数据后的具体的处理逻辑在 scrape.scrapeLoop.append 中，主要是解析指标，并且给 appender 发送数据， appender 是从 scrape.Manager 中传进来的，具体实现在 storage.fanout 中。</li></ul></li><li>util : 一些常用的方法函数， treecache 用 zk 作为具体实现比较有意思。</li><li>web : 提供了 rest api 和 ui。<ul><li>alertmanager 和 pushgateway 都用了把静态资源打包的做法 (http.FS)，但 prometheus 却没有这么做，奇怪。 (更新，还是有的，只是和之前的代码写法有些不一样，用的是 go 的 //go:embed 注释)</li><li>对互联网后端开发而言，很多时候把写 api 作为工作的主体了，但实际上，web 的可能是最简单的部分……</li></ul></li></ul><blockquote><p>最重要的部分放在最后~~</p></blockquote><ul><li>promql : parse 和 query ，具体没怎么看细节。</li><li>storage : tsdb 的接口层，可以对接 remote ，也可以直接使用本地 tsdb。</li><li>tsdb<ul><li>db.go : 启动 tsdb 的入口</li><li>head.go : 插入数据的入口，series 的内存结构等。 是理解数据写入过程的最重要的文件。实际上，head 数据可以看做是 block 在内存中的展开状态，head 中的 chunk 写到一定阶段后就会由 compact 变成 block 存到磁盘中。</li><li>wal.go : 任何的数据操作，都会先写到 log 中，用于保证数据的安全，调用方为 head.Commit。使用 wal 和 checkpoint 是内存数据库非常通用的方法。 checkpoint 的逻辑 和 日志监听的逻辑 在 wlog 中。</li><li>record : 写入 wal 的具体事件的定义。</li><li>compact.go : 处理把数据写入 文件系统 成为一个 block 的过程，包括两类: 把内存中的 head 写入 block；把多个 block 合并，实际调用 index.Writer 和 chunks.Writer 等做实际写入操作。</li><li>block.go : 数据块的定义和操作，管理 读取、写入 block。一个数据块就是 一段时间内的所有数据的集合，包括 采集的指标值 和 指标本身的信息。 是数据最终的存在形态，数据通路是 db =&gt; head =&gt; chunk =&gt; block 。</li><li>chunks 和 chunkenc : chunk 的定义和操作。 chunkenc 中包含了几种 chunk 的序列化方法。</li><li>fileutil : 一些 file 的操作封装<ul><li>mmap : 文件内存映射。是读取 chunk 的方式，保证了低内存占用。</li></ul></li><li>index<ul><li>是理解 <code>持久化</code> 和 <code>查询</code> 最好的方式，分为 符号表 (用于压缩空间)、序列表(用于关联 chunks)、label表和posting表 (用于查询及关联 label 和 name) 以及 TOC (用于定位上述几张表)</li></ul></li><li>有几个重点：<ul><li>理解 series 的概念: 特定的 label 集合。 (series =&gt; labels.Labels)</li><li>理解 series 在内存中的状态 (stripeSeries =&gt; memSeries =&gt; headChunk =&gt; mmapchunk)</li><li>理解 block 的生成流程: series.headchunk =&gt; mmapchunk =&gt; compact/index/meta =&gt; block</li><li>理解一个数据写入的流程: labels+val =&gt; series + val =&gt; chunk</li></ul></li></ul></li></ul><p>设计上的想法:</p><ul><li>对于稍微复杂点的项目，一定会走上分层的道路，分层之后有逐渐会形成以 接口 为传递方式的调用 (而不是实例，否则要写 n 多类似的方法来兼容不同的type)。 接口化之后的好处是 单层内代码更简洁了；坏处是 想要跨层走一次流程会很懵，因为不知道具体的实现方是谁 (一般分层后每层都可能实现相同的方法)。</li></ul><h2 id="一些非常好的参考资料"><a href="#一些非常好的参考资料" class="headerlink" title="一些非常好的参考资料"></a>一些非常好的参考资料</h2><ul><li><a href="https://github.com/prometheus/prometheus/tree/main/tsdb/docs/format">官方文档 tsdb 的序列化结构</a> </li><li><a href="https://ganeshvernekar.com/blog/prometheus-tsdb-the-head-block">prometheus TSDB</a></li><li><a href="https://web.archive.org/web/20210622211933/https://fabxc.org/tsdb/">prometheus 发起人的博客</a></li></ul><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="你想要什么？"><a href="#你想要什么？" class="headerlink" title="你想要什么？"></a>你想要什么？</h3><ul><li>数据库具体究竟是怎么工作的？<ul><li>wal 的具体实现</li><li>block 的具体实现</li></ul></li><li>为什么我们现在脱离了数据库就没法写代码了一样？</li><li>一个这种级别的项目会花多少精力？<ul><li>prometheus 的发起人开始也是自己就发布了版本，而且还做了好多其他项目，这些牛逼的人为什么牛逼？</li></ul></li><li>项目成功的要素有哪些？<ul><li>能力、生态</li></ul></li><li>如何让读源码的收益最大化？<ul><li>通过: 阅读代码<ul><li>知道各自的职能是什么</li><li>知道各自是怎么实现的</li><li>知道相互是怎么连接的</li></ul></li><li>得到: 数据结构 + 过程演变</li><li>最好能: 临摹代码</li><li>如何把这件事做好?<ul><li>先可以大量实践一下，找到一些好的形态</li></ul></li><li>如何像一台机器一样阅读源码？<ul><li>主线流程跑一次</li><li>用 debug</li></ul></li></ul></li><li>LSM tree 和 其他数据库存储模型</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>找一个 LSM tree 的数据库实现看一下 <a href="/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html" name="golevelDB源码走读" >golevelDB源码走读</a></li><li>找一个 B+ tree 的数据库实现看一下 <a href="/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html" name="golevelDB源码走读" >golevelDB源码走读</a></li><li>对 k8s 的部分代码走读一下 <a href="/notpublish/index.html" name="k8s部分源码走读" >k8s部分源码走读</a></li></ul><hr><blockquote><p>We may encounter many defeats, but we must not be defeated.<br>— <cite>Maya Angelou</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;prometheus 还是很牛逼的，作为云原生监控系统的事实标准，值得一读。&lt;/p&gt;
&lt;p&gt;生态中对应的还有  AlertManager、p</summary>
      
    
    
    
    
    <category term="code reading" scheme="https://iamlongalong.github.io/longblog/tags/code-reading/"/>
    
    <category term="monitor" scheme="https://iamlongalong.github.io/longblog/tags/monitor/"/>
    
    <category term="prometheus" scheme="https://iamlongalong.github.io/longblog/tags/prometheus/"/>
    
    <category term="pushgateway" scheme="https://iamlongalong.github.io/longblog/tags/pushgateway/"/>
    
    <category term="代码走读" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BB%A3%E7%A0%81%E8%B5%B0%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于磁盘和网络的性能的问题</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_11_23_23_02_disk_performance_and_network.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_11_23_23_02_disk_performance_and_network.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:25:25.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一般我们在两种场景下关心磁盘的性能：</p><ul><li>pc 机拷贝文件时</li><li>服务器运行有磁盘 io 的服务时</li></ul><p>在 pc 机上，windows 下有各种磁盘跑分工具，一搜就有。</p><p>在服务器上，也有一系列工具。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>iops</li><li>throughput</li><li>latency</li><li>capacity</li><li>块存储和文件系统</li></ul><p>关于 iops、throughput、latency 之间的关系，可以直接认为 throughput = iops * 块大小。 latency 是另一个方面的参数。</p><p>关于一些概念的基本认识，可以参考 <a href="https://louwrentius.com/understanding-storage-performance-iops-and-latency.html">这篇文章</a></p><blockquote><p>还可以参考文章：<br><a href="https://www.brentozar.com/archive/2021/12/how-do-you-test-iops-latency-and-throughput/">参考1</a> 、<a href="https://www.site24x7.com/learn/linux/iops-throughput.html">参考2</a></p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>块存储的测试可以使用 fio，使用方式可以参考 <a href="https://help.aliyun.com/document_detail/147897.html">aliyun 磁盘性能测试</a></p><p>其他测试工具可以使用 dd、sysbench 等，可以参考 <a href="https://linuxhint.com/benchmark_hard_disks_linux/">How to Benchmark Hard Disks in Linux</a></p><p>可以使用 iostat、iotop 等方式进行磁盘 io 观测</p><p>之前用 sysbench 做了阿里云 ECS 自带的磁盘，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs text">sysbench 1.0.18 (using system LuaJIT 2.1.0-beta3)<br><br>Running the test with following options:<br>Number of threads: 1<br>Initializing random number generator from current time<br><br><br>Extra file open flags: (none)<br>128 files, 16MiB each<br>2GiB total file size<br>Block size 16KiB<br>Number of IO requests: 0<br>Read/Write ratio for combined random IO test: 1.50<br>Periodic FSYNC enabled, calling fsync() each 100 requests.<br>Calling fsync() at the end of test, Enabled.<br>Using synchronous I/O mode<br>Doing random r/w test<br>Initializing worker threads...<br><br>Threads started!<br><br><br>File operations:<br>    reads/s:                      2897.98<br>    writes/s:                     1931.98<br>    fsyncs/s:                     6182.45<br><br>Throughput:<br>    read, MiB/s:                  45.28<br>    written, MiB/s:               30.19<br><br>General statistics:<br>    total time:                          10.0192s<br>    total number of events:              110225<br><br>Latency (ms):<br>         min:                                    0.00<br>         avg:                                    0.09<br>         max:                                   25.22<br>         95th percentile:                        0.45<br>         sum:                                 9979.91<br><br>Threads fairness:<br>    events (avg/stddev):           110225.0000/0.00<br>    execution time (avg/stddev):   9.9799/0.00<br></code></pre></td></tr></table></figure><blockquote><p>还可以参考的文章<br><a href="https://fio.readthedocs.io/en/latest/index.html">fio 官方文档</a><br><a href="https://cloud.tencent.com/developer/article/1500430">一个腾讯用户的fio使用记录</a></p></blockquote><h2 id="感性数据"><a href="#感性数据" class="headerlink" title="感性数据"></a>感性数据</h2><p>对于 hdd 而言，延迟大约为 10ms，throughput 在 100MB ~ 500MB<br>对于 ssd 而言，延迟大约为 1ms，throughput 可达到 500MB ~ 2000MB</p><p>容量上<br>常见的 hdd 目前基本都在 1TB 以上，高的可达到 10TB<br>常见的 ssd 容量有 128GB、256GB、512GB、1TGB</p><h2 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h2><p>提升 ssd 性能的好方式是： 换更高性能的设备<br>提升 hdd 性能的好方式是： 组 raid ，可以参考 <a href="/longblog/posts/21_12_02_operation_of_raid_with_lvm.html" name="使用lvm实现raid能力" >使用lvm实现raid能力</a></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>磁盘性能的监控，可以使用 prometheus 的 node exporter ，可以参考 <a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html" name="简单的集群监控方案" >简单的集群监控方案</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>关于网络 io 的性能，可以使用 <a href="https://github.com/esnet/iperf">iperf</a><ul><li>另外，百度的 <a href="https://github.com/baidu/dperf/blob/main/README-CN.md">dperf</a> 也可以参考下</li></ul></li><li>cpu 的性能测试比较复杂，可以参考 <a href="https://www.cpubenchmark.net/cpu_test_info.html">这个文档</a></li></ul><h2 id="iperf-测试"><a href="#iperf-测试" class="headerlink" title="iperf 测试"></a>iperf 测试</h2><ul><li><p>centos安装 iperf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ih ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/fedora/linux/updates/24/x86_64/i/iperf3-3.1.3-1.fc24.x86_64.rpm<br></code></pre></td></tr></table></figure></li><li><p>一台机器上跑server端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -s -p 8800<br></code></pre></td></tr></table></figure></li><li><p>另一台机器跑 client 端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -c 172.24.33.3 -p 8800<br></code></pre></td></tr></table></figure></li><li><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">[  4] local 172.24.33.4 port 39594 connected to 172.24.33.3 port 8800<br>[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd<br>[  4]   0.00-1.00   sec   236 MBytes  1.98 Gbits/sec  1315    543 KBytes<br>[  4]   1.00-2.00   sec  96.9 MBytes   813 Mbits/sec  1471    549 KBytes<br>[  4]   2.00-3.00   sec   117 MBytes   981 Mbits/sec  1845    168 KBytes<br>[  4]   3.00-4.00   sec   139 MBytes  1.16 Gbits/sec  2251    433 KBytes<br>[  4]   4.00-5.00   sec   111 MBytes   931 Mbits/sec  1891    298 KBytes<br>[  4]   5.00-6.00   sec   123 MBytes  1.03 Gbits/sec  1370    414 KBytes<br>[  4]   6.00-7.00   sec   117 MBytes   979 Mbits/sec  1860   93.3 KBytes<br>[  4]   7.00-8.00   sec   108 MBytes   905 Mbits/sec  1766    614 KBytes<br>[  4]   8.00-9.00   sec   109 MBytes   917 Mbits/sec  1141    614 KBytes<br>[  4]   9.00-10.00  sec   111 MBytes   927 Mbits/sec  1782   1.41 KBytes<br>- - - - - - - - - - - - - - - - - - - - - - - - -<br>[ ID] Interval           Transfer     Bandwidth       Retr<br>[  4]   0.00-10.00  sec  1.24 GBytes  1.06 Gbits/sec  16692             sender<br>[  4]   0.00-10.00  sec  1.23 GBytes  1.06 Gbits/sec                  receiver<br><br>iperf Done.<br></code></pre></td></tr></table></figure><p>这是阿里云下某规格机器的内网带宽，大概 1Gbits/s</p></li><li><p>测试一下 udp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -c 172.24.33.3 -p 8800 -u<br></code></pre></td></tr></table></figure></li><li><p>额 结果不大懂了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">Accepted connection from 172.24.33.3, port 50166<br>[  5] local 172.24.33.4 port 8800 connected to 172.24.33.3 port 48329<br>[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams<br>[  5]   0.00-1.00   sec   116 KBytes   950 Kbits/sec  0.006 ms  0/116 (0%)<br>[  5]   1.00-2.00   sec   128 KBytes  1.05 Mbits/sec  0.007 ms  0/128 (0%)<br>[  5]   2.00-3.00   sec   128 KBytes  1.05 Mbits/sec  0.003 ms  0/128 (0%)<br>[  5]   3.00-4.00   sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]   4.00-5.00   sec   128 KBytes  1.05 Mbits/sec  0.004 ms  0/128 (0%)<br>[  5]   5.00-6.00   sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]   6.00-7.00   sec   128 KBytes  1.05 Mbits/sec  0.004 ms  0/128 (0%)<br>[  5]   7.00-8.00   sec   128 KBytes  1.05 Mbits/sec  0.006 ms  0/128 (0%)<br>[  5]   8.00-9.00   sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]   9.00-10.00  sec   128 KBytes  1.05 Mbits/sec  0.005 ms  0/128 (0%)<br>[  5]  10.00-10.04  sec  0.00 Bytes  0.00 bits/sec  0.005 ms  0/0 (0%)<br>- - - - - - - - - - - - - - - - - - - - - - - - -<br>[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams<br>[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec  0.005 ms  0/1268 (0%)<br></code></pre></td></tr></table></figure></li><li><p>抓了下 udp 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump <span class="hljs-string">&quot;udp port 8800&quot;</span> -vv<br></code></pre></td></tr></table></figure></li><li><p>发现全是报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">00:22:50.287602 IP (tos 0x0, ttl 64, id 38886, offset 0, flags [+], proto UDP (17), length 1500)<br>    172.24.33.3.35427 &gt; iZj6c50uwswovavwjj5dqoZ.sunwebadmin: UDP, bad length 8192 &gt; 1472<br>00:22:50.287677 IP (tos 0x0, ttl 64, id 38887, offset 0, flags [+], proto UDP (17), length 1500)<br>    172.24.33.3.35427 &gt; iZj6c50uwswovavwjj5dqoZ.sunwebadmin: UDP, <br></code></pre></td></tr></table></figure></li><li><p>查了下，发现是包大小限制了，<a href="https://iota.stackexchange.com/questions/756/possible-udp-mtu-problems-udp-bad-length-1650-1368-in-tcpdump">可以参考这个</a></p></li><li><p>iperf 默认的 udp 包大小是 8k， 可以通过 <code>-l</code> 修改</p></li><li><p>修改大小为 1k</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf3 -c 172.24.33.3 -p 8800 -u -l 1024<br></code></pre></td></tr></table></figure></li><li><p>虽然抓包没问题了，但是结果还是不大行，原因未知，回头再看吧</p><ul><li>似乎只能看 udp 的丢包率</li></ul></li></ul><h3 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h3><ul><li><a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html" name="WIP-kafka的高吞吐原因" >WIP-kafka的高吞吐原因</a></li><li><a href="/longblog/posts/22_11_06_01_47_some_thought_of_performance.html" name="压测的一些思考" >压测的一些思考</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/longblog/posts/21_12_02_how_to_do_load_test.html" name="如何做好压测" >如何做好压测</a></li><li><a href="/longblog/posts/22_11_06_01_49_some_thought_about_performance.html" name="关于压测本身的梳理" >关于压测本身的梳理</a></li><li><a href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html" name="记一次服务性能的调优排查" >记一次服务性能的调优排查</a></li></ul><hr><blockquote><p>Love is the only force capable of transforming an enemy into a friend.<br>— <cite>Martin Luther King Jr.</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一般我们在两种场景下关心磁盘的性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pc 机拷贝文件时&lt;/li&gt;
&lt;li&gt;服务器运行有磁盘 io 的服务时&lt;/l</summary>
      
    
    
    
    
    <category term="devops" scheme="https://iamlongalong.github.io/longblog/tags/devops/"/>
    
    <category term="disk" scheme="https://iamlongalong.github.io/longblog/tags/disk/"/>
    
    <category term="磁盘" scheme="https://iamlongalong.github.io/longblog/tags/%E7%A3%81%E7%9B%98/"/>
    
    <category term="performance" scheme="https://iamlongalong.github.io/longblog/tags/performance/"/>
    
    <category term="fio" scheme="https://iamlongalong.github.io/longblog/tags/fio/"/>
    
    <category term="sysbench" scheme="https://iamlongalong.github.io/longblog/tags/sysbench/"/>
    
    <category term="iperf" scheme="https://iamlongalong.github.io/longblog/tags/iperf/"/>
    
    <category term="iperf3" scheme="https://iamlongalong.github.io/longblog/tags/iperf3/"/>
    
  </entry>
  
  <entry>
    <title>批任务处理工具</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_11_23_01_26_batch_job_tools.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_11_23_01_26_batch_job_tools.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:25:04.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>shell 是一个用于和 linux 内核交互的工具，通常用来编写各种自动化脚本。</p><p>shell 有两种模式，交互式 和 脚本式，我们主要谈论脚本式。</p><p>shell 很强大，我认为强大来源于三方面：</p><ul><li>脚本语言，开发方便</li><li>环境适应性非常非常广</li><li>能够粘合各类工具</li></ul><p>shell 也有一些问题，我认为主要在这两方面：</p><ul><li>编程范式和现代高级语言有较大差异 (几乎是纯命令式编程，且语言风格与其他语言差别较大)</li><li>语言本身的功能较弱，工程能力较差 (缺乏统一标准库、模块管理能力弱)</li></ul><p>现在大多数机器中都集成了 python，因此基于 python 在很多场景下是可以替代 shell 的，尤其是在十分需要 <code>工程化</code> 的项目中。</p><p>但由于 shell 和 linux 系统有着天生的兼容性，因此 shell 一定会大量运用于 linux 中的各个方面，甚至可以认为: **linux 不灭，shell 永存 **。</p><h3 id="shell-主要难理解的地方"><a href="#shell-主要难理解的地方" class="headerlink" title="shell 主要难理解的地方"></a>shell 主要难理解的地方</h3><h4 id="变量的差异"><a href="#变量的差异" class="headerlink" title="变量的差异"></a>变量的差异</h4><h5 id="类型系统是非常非常弱的！！"><a href="#类型系统是非常非常弱的！！" class="headerlink" title="类型系统是非常非常弱的！！"></a>类型系统是非常非常弱的！！</h5><p>在 shell 中，字面量默认都是 字符串 ！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=hello<br>var3=<span class="hljs-string">&quot;hello_quote&quot;</span><br>var4=<span class="hljs-string">&#x27;semi_quote&#x27;</span><br>var5=<span class="hljs-string">&quot;hello world 123&quot;</span><br><br><span class="hljs-built_in">echo</span> hello   <span class="hljs-comment"># hello</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你好&quot;</span>   <span class="hljs-comment"># 你好</span><br><span class="hljs-built_in">echo</span> var2    <span class="hljs-comment"># var2</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var2</span>   <span class="hljs-comment"># hello</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var3</span>   <span class="hljs-comment"># hello_quote</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$var4</span>&quot;</span> <span class="hljs-comment"># semi_quote</span><br></code></pre></td></tr></table></figure><h5 id="带空格的字符串也可以类似数组迭代"><a href="#带空格的字符串也可以类似数组迭代" class="headerlink" title="带空格的字符串也可以类似数组迭代"></a>带空格的字符串也可以类似数组迭代</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">arr=<span class="hljs-string">&quot;hello world arr&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$arr</span>; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h5 id="拼字符串的时候会看起来很奇怪"><a href="#拼字符串的时候会看起来很奇怪" class="headerlink" title="拼字符串的时候会看起来很奇怪"></a>拼字符串的时候会看起来很奇怪</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">var=nihao<br><span class="hljs-built_in">echo</span> \&quot;hello world\&quot; and <span class="hljs-variable">$var</span> are equal<br></code></pre></td></tr></table></figure><h5 id="数组的操作和其他语言不大一样"><a href="#数组的操作和其他语言不大一样" class="headerlink" title="数组的操作和其他语言不大一样"></a>数组的操作和其他语言不大一样</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">long=(longalong 18 <span class="hljs-string">&quot;handsome&quot;</span>)<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;long[0]&#125;</span>  <span class="hljs-variable">$&#123;long[2]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;long[*]&#125;</span> <span class="hljs-comment"># 全部</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#long[*]&#125;</span>  <span class="hljs-comment"># 数组长度！！</span><br></code></pre></td></tr></table></figure><p>数组也可以这么赋值 <code>ages=([3]=24 [5]=19 [10]=12)</code></p><p>数组拼接方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">array1=(23 56)<br>array2=(99 <span class="hljs-string">&quot;hello world&quot;</span>)<br>array_new=(<span class="hljs-variable">$&#123;array1[@]&#125;</span> <span class="hljs-variable">$&#123;array2[*]&#125;</span>)<br></code></pre></td></tr></table></figure><p>删除数组一个值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">arr=(23 56 99 <span class="hljs-string">&quot;hello world&quot;</span>)<br><span class="hljs-built_in">unset</span> arr[1]<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span><br></code></pre></td></tr></table></figure><h5 id="map-关联数组-需要申明，其他可申可不申"><a href="#map-关联数组-需要申明，其他可申可不申" class="headerlink" title="map (关联数组) 需要申明，其他可申可不申"></a>map (关联数组) 需要申明，其他可申可不申</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -A testmap<br><br>testmap[name]=longsang<br>testmap[age]=18<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;testmap[age]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;testmap[*]&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">-f [name]列出之前由用户在脚本中定义的函数名称和函数体。<br>-F [name]仅列出自定义函数名称。<br>-g name在 Shell 函数内部创建全局变量。<br>-p [name]显示指定变量的属性和值。<br>-a name声明变量为普通数组。<br>-A name声明变量为关联数组（支持索引下标为字符串）。<br>-i name 将变量定义为整数型。<br>-r name[=value] 将变量定义为只读（不可修改和删除），等价于 readonly name。<br>-x name[=value]将变量设置为环境变量，等价于 export name[=value]。<br></code></pre></td></tr></table></figure><h5 id="true-和-false-有时候是-bool-，有时候又是-字符串"><a href="#true-和-false-有时候是-bool-，有时候又是-字符串" class="headerlink" title="true 和 false 有时候是 bool ，有时候又是 字符串"></a>true 和 false 有时候是 bool ，有时候又是 字符串</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">vart=<span class="hljs-literal">true</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$vart</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-variable">$vart</span>; <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> hello; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h5 id="所有变量的直接使用都得用-xxx"><a href="#所有变量的直接使用都得用-xxx" class="headerlink" title="所有变量的直接使用都得用 $xxx"></a>所有变量的直接使用都得用 $xxx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=longalong<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span><br></code></pre></td></tr></table></figure><h5 id="直接命名的变量都是全局变量-包括-function-中！！"><a href="#直接命名的变量都是全局变量-包括-function-中！！" class="headerlink" title="直接命名的变量都是全局变量 (包括 function 中！！)"></a>直接命名的变量都是全局变量 (包括 function 中！！)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=long<br><br><span class="hljs-function"><span class="hljs-title">changename</span></span>() &#123;<br>name=longalong<br>&#125;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br>changename<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># longalong</span><br><br><br><span class="hljs-comment"># 函数内可以使用 local name 重新申明</span><br>name=long<br><br><span class="hljs-function"><span class="hljs-title">changename</span></span>() &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br><span class="hljs-built_in">local</span> name  <br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># &quot;&quot;</span><br>name=longalong<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># longalong</span><br>&#125;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br>changename<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># long</span><br></code></pre></td></tr></table></figure><h5 id="大量使用子命令"><a href="#大量使用子命令" class="headerlink" title="大量使用子命令"></a>大量使用子命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">now=`date`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$now</span><br><br>now=$(date)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$now</span><br></code></pre></td></tr></table></figure><h5 id="类型很弱，也就别期待-结构体、类型、对象-这类东西了"><a href="#类型很弱，也就别期待-结构体、类型、对象-这类东西了" class="headerlink" title="类型很弱，也就别期待 结构体、类型、对象 这类东西了"></a>类型很弱，也就别期待 结构体、类型、对象 这类东西了</h5><h4 id="运算符差异"><a href="#运算符差异" class="headerlink" title="运算符差异"></a>运算符差异</h4><h5 id="语言层没有算数运算符！！！"><a href="#语言层没有算数运算符！！！" class="headerlink" title="语言层没有算数运算符！！！"></a>语言层没有算数运算符！！！</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=321<br>var3=123+321<br>var4=<span class="hljs-variable">$var1</span>+<span class="hljs-variable">$var2</span><br><br><span class="hljs-built_in">echo</span> var3 : <span class="hljs-variable">$var3</span>  <span class="hljs-comment"># var3 : 123+321</span><br><span class="hljs-built_in">echo</span> var4 : <span class="hljs-variable">$var4</span>  <span class="hljs-comment"># var4 : 123+321</span><br></code></pre></td></tr></table></figure><p>要使用指令进行计算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=321<br><br><span class="hljs-comment"># 用 let 做运算</span><br><span class="hljs-built_in">let</span> var3=<span class="hljs-variable">$var1</span>+<span class="hljs-variable">$var2</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var3</span> <span class="hljs-comment"># 444</span><br><br><span class="hljs-comment"># 用 $(()) 做运算</span><br>var4=$((<span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>))<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var4</span> <span class="hljs-comment"># 444</span><br></code></pre></td></tr></table></figure><p>或者使用单独的命令来实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var1=123<br>var2=321<br><br>var3=`expr <span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var3</span><br></code></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><p>以上方法都仅适用于 <code>整数运算</code> ，要想做浮点运算，需要用  <code>bc</code>  或者 <code>awk</code> ！</p><h5 id="关系运算符-比较运算符-的样式很怪异"><a href="#关系运算符-比较运算符-的样式很怪异" class="headerlink" title="关系运算符(比较运算符) 的样式很怪异"></a>关系运算符(比较运算符) 的样式很怪异</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=123<br>b=123<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> : a 等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span>: a 不等于 b&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>当然也可以用 &gt; 、&lt; 、 &gt;= 这种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=124<br>b=123<br><br><span class="hljs-keyword">if</span> (( <span class="hljs-variable">$a</span> &gt;= <span class="hljs-variable">$b</span> ))<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> &gt;= <span class="hljs-variable">$b</span> : a 大于等于 b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> &lt; <span class="hljs-variable">$b</span>: a 小于 b&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>需要注意的是， = 这个符号，在比较中，代表的是 “等于”，而不是赋值。</p><h5 id="逻辑运算-amp-amp-和布尔运算含义是一样的，但布尔运算形式和关系运算符类似"><a href="#逻辑运算-amp-amp-和布尔运算含义是一样的，但布尔运算形式和关系运算符类似" class="headerlink" title="逻辑运算 &amp;&amp; || 和布尔运算含义是一样的，但布尔运算形式和关系运算符类似"></a>逻辑运算 &amp;&amp; || 和布尔运算含义是一样的，但布尔运算形式和关系运算符类似</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=<span class="hljs-literal">false</span><br>b=<span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -o <span class="hljs-variable">$b</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> a or b<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h5 id="看起来很不习惯的字符串运算符"><a href="#看起来很不习惯的字符串运算符" class="headerlink" title="看起来很不习惯的字符串运算符"></a>看起来很不习惯的字符串运算符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">假设  a=abc  b=def<br><br>=检测两个字符串是否相等，相等返回 true。[ $a = $b ] 返回 false。<br>!=检测两个字符串是否不相等，不相等返回 true。[ $a != $b ] 返回 true。<br>-z检测字符串长度是否为0，为0返回 true。[ -z $a ] 返回 false。<br>-n检测字符串长度是否不为 0，不为 0 返回 true。[ -n &quot;$a&quot; ] 返回 true。<br>$检测字符串是否不为空，不为空返回 true。[ $a ] 返回 true。<br></code></pre></td></tr></table></figure><h5 id="有文件运算符这种东西"><a href="#有文件运算符这种东西" class="headerlink" title="有文件运算符这种东西"></a>有文件运算符这种东西</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text">文件类型判断<br>-b filename判断文件是否存在，并且是否为块设备文件。<br>-c filename判断文件是否存在，并且是否为字符设备文件。<br>-d filename判断文件是否存在，并且是否为目录文件。<br>-e filename判断文件是否存在。<br>-f filename判断文件是否存在，井且是否为普通文件。<br>-L filename判断文件是否存在，并且是否为符号链接文件。<br>-p filename判断文件是否存在，并且是否为管道文件。<br>-s filename判断文件是否存在，并且是否为非空。<br>-S filename判断该文件是否存在，并且是否为套接字文件。<br><br>文件权限判断<br>-r filename判断文件是否存在，并且是否拥有读权限。<br>-w filename判断文件是否存在，并且是否拥有写权限。<br>-x filename判断文件是否存在，并且是否拥有执行权限。<br>-u filename判断文件是否存在，并且是否拥有 SUID 权限。<br>-g filename判断文件是否存在，并且是否拥有 SGID 权限。<br>-k filename判断该文件是否存在，并且是否拥有 SBIT 权限。<br><br>文件比较<br>filename1 -nt filename2判断 filename1 的修改时间是否比 filename2 的新。<br>filename -ot filename2判断 filename1 的修改时间是否比 filename2 的旧。<br>filename1 -ef filename2判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法<br></code></pre></td></tr></table></figure><h4 id="作用域分隔符的差异"><a href="#作用域分隔符的差异" class="headerlink" title="作用域分隔符的差异"></a>作用域分隔符的差异</h4><p>使用反过来的方式表示结束，和大多数用 <code>&#123;&#125;</code> 或者用 缩进 做区分的方式不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if 和 fi<br>do 和 done<br>case 和 esac<br></code></pre></td></tr></table></figure><h4 id="函数调用方法的差异"><a href="#函数调用方法的差异" class="headerlink" title="函数调用方法的差异"></a>函数调用方法的差异</h4><ul><li>调用不用加小括号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">sayhello</span></span>() &#123;<br><span class="hljs-built_in">echo</span> hello<br>&#125;<br><br>sayhello<br></code></pre></td></tr></table></figure><ul><li>参数直接跟在调用的后面</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">greet</span></span>() &#123;<br><span class="hljs-built_in">echo</span> hello <span class="hljs-variable">$1</span>, welcome<br>&#125;<br><br>greet longalong<br></code></pre></td></tr></table></figure><ul><li>没有形参进行接收，全部用位置表示，且从 1 开始计数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">sayit</span></span>() &#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> <span class="hljs-variable">$3</span> <span class="hljs-variable">$4</span> <span class="hljs-variable">$5</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;11&#125;</span> <span class="hljs-comment"># 超过 10 以上</span><br><span class="hljs-built_in">echo</span> 参数总数为 : <span class="hljs-variable">$#</span><br><span class="hljs-built_in">echo</span> 所有参数为 : $*<br>&#125;<br><br>sayit longalong IS VERY HANDSOME<br></code></pre></td></tr></table></figure><ul><li>return 仅返回 0-255 的数字，一般表示运行情况，而真正想要被变量接收的，则用 echo 实现</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">whatisreturn</span></span>() &#123;<br><span class="hljs-built_in">echo</span> hello<br><span class="hljs-built_in">echo</span> world<br><span class="hljs-built_in">return</span><br>&#125;<br><br>re=`whatisreturn`<br><br><span class="hljs-built_in">echo</span> $?   <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$re</span>  <span class="hljs-comment"># hello world</span><br></code></pre></td></tr></table></figure><h4 id="for-循环的差异"><a href="#for-循环的差异" class="headerlink" title="for 循环的差异"></a>for 循环的差异</h4><p>有一些和其他语言不一样的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> (( i=0;i&lt;=5;i++ )); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;0..5&#125;; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `seq 0 5`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `cat xxx`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">int=1<br><span class="hljs-keyword">while</span>(( <span class="hljs-variable">$int</span>&lt;=5 ))<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$int</span><br>    <span class="hljs-built_in">let</span> <span class="hljs-string">&quot;int++&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=0<br><br>until [ ! <span class="hljs-variable">$a</span> -lt 10 ]<br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span><br>   a=`expr <span class="hljs-variable">$a</span> + 1`<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> *.sh<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$filename</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="分支语句的差异"><a href="#分支语句的差异" class="headerlink" title="分支语句的差异"></a>分支语句的差异</h4><ul><li><p>if 语句的差别主要在关系运算符上</p></li><li><p>多分支语句</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">num=<span class="hljs-variable">$1</span><br><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>    1)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你输入了 1&#x27;</span><br>    ;;<br>    2)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你输入了 2&#x27;</span><br>    ;;<br>    *)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你没有输入 1 和 2&#x27;</span><br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><h4 id="文本处理的差异"><a href="#文本处理的差异" class="headerlink" title="文本处理的差异"></a>文本处理的差异</h4><ul><li>字符串操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">str=<span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#str&#125;</span>  <span class="hljs-comment"># 井号取长度，和 arr 一样，大多数语言会用函数如 len() 或者属性如 .length </span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;str:2:-2&#125;</span> <span class="hljs-comment"># 冒号为截取子串，大多数语言会用中括号加冒号，如 str[2:-2]</span><br></code></pre></td></tr></table></figure><ul><li>更多不好记的处理方式可以参考 <a href="http://c.biancheng.net/view/1120.html">C语言网教程</a></li></ul><h4 id="其他难理解的地方"><a href="#其他难理解的地方" class="headerlink" title="其他难理解的地方"></a>其他难理解的地方</h4><ul><li><p>在 shell 交互式命令行中经常需要转义，有些转义很难理解</p></li><li><p>有很多内建命令，具体参考 <a href="http://c.biancheng.net/view/1136.html">C语言网教程</a></p></li><li><p>一些场景下不允许空格，一些场景下又必须空格</p></li><li><p>多种重定向易蒙圈</p></li><li><p>几乎没有模块系统</p></li></ul><p>可以过一遍<a href="https://www.runoob.com/linux/linux-shell-process-control.html">菜鸟</a><br>可以看下<a href="https://zhuanlan.zhihu.com/p/102176365/">一个同事写的</a><br><a href="http://c.biancheng.net/view/942.html">C语言网教程</a> 的高级部分还是值得看一下，但要付费，姑且按照相关话题，在网上搜搜资料。</p><h2 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h2><p>先把 <a href="https://docs.ansible.com/">官方文档</a> 看一遍<br>然后把 <a href="https://github.com/geerlingguy/ansible-for-devops">ansible-for-devops</a> 里面的案例看一遍，这个项目的作者专门在搞 ansible，可以看 <a href="https://github.com/geerlingguy?tab=repositories">他的主页</a></p><h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><ul><li><p>ansible 是一个 linux 批处理任务工具，通过提供 分类、批量、顺序、选择、触发 等编排能力，实现远程任务管理能力。</p></li><li><p>ansible 主要用来做  基础设施准备 (配置管理+置备)、 服务CICD (部署自动化)、任务编排 (构建存储系统、构建集群等等)。</p></li><li><p>ansible 命令方式执行，类似于在多台机器上执行命令。(和 iterm 中使用 cmd + alt + i 类似)</p></li><li><p>最强大的地方在于其生态，可以从 <a href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a> 找到大量别人写好的 roles 、plugins 等等，可以很简便就集成使用。 实际上，和使用 docker-compose 起服务、使用 helm charts 起服务 一样，都可以在他人成果的基础上使用。</p></li></ul><h3 id="官方文档阅读笔记"><a href="#官方文档阅读笔记" class="headerlink" title="官方文档阅读笔记"></a>官方文档阅读笔记</h3><ul><li><p>ansible 使用 ini 文件 或者 yaml 文件 作为配置文件格式</p></li><li><p>inventory ： 用来标识要管理的机器，对机器进行  分组、配置连接方式(user、jump等)、动态监控云上机器并自动修改要管理的机器实例等。 <a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html">官方文档</a></p></li><li><p>playbook： 用来描述一系列任务的方式，分为  角色(role: 不同的系列任务)、任务(tasks: 一系列任务)，这是大多数项目使用 ansible 的方式。 <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.html">roles</a> <a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html">主要概念</a></p></li><li><p>templates:  用来动态生成 yaml/ini 配置文件的模板，使用 jinja2 (python)。<a href="https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters">jinja文档</a>  <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#playbooks-variables">ansible 中的变量</a>  <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_vars_facts.html#vars-and-facts">ansible 中特定的变量</a> [重要]</p></li><li><p>module： 模块，ansible 的要执行的各种功能是以模块呈现的，例如 copy、创建文件 等等，不同的模块有不同的参数，ansible 的各种 tasks (实际执行的任务)，都是用  模块 + 参数 的方式构成的。 <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html#description">ansible 的默认模块</a>  [重要]</p></li><li><p>ansible 的概念结构可以参考 <a href="https://docs.ansible.com/ansible/latest/dev_guide/overview_architecture.html#modules">ansible architecture</a> [重要]</p></li><li><p>playbook 是一个 任务编排 工具，抽象来看，市面上有非常多的任务编排系统，他们所面对的问题域基本都是一样的，可以以此为例子对任务编排进行梳理。</p><ul><li><input disabled="" type="checkbox"> 调研多种任务编排系统，找到他们的共性问题</li></ul></li></ul><h3 id="简单试用"><a href="#简单试用" class="headerlink" title="简单试用"></a>简单试用</h3><ul><li><p>安装 ansible</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y ansible<br></code></pre></td></tr></table></figure></li><li><p>设置要管理的机器 (inventory)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">vim /etc/ansible/hosts<br><br>[chaos]<br>172.17.5.245<br>172.17.5.246<br>172.17.5.247<br></code></pre></td></tr></table></figure></li><li><p>使用 shell 查看信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">ansible chaos -m shell -a &quot;uname -a&quot;<br><br>172.17.5.245 | CHANGED | rc=0 &gt;&gt;<br>Linux prichaos003 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux<br>172.17.5.247 | CHANGED | rc=0 &gt;&gt;<br>Linux prichaos002 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux<br>172.17.5.246 | CHANGED | rc=0 &gt;&gt;<br>Linux prichaos001 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></table></figure></li></ul><h3 id="mac-下的使用"><a href="#mac-下的使用" class="headerlink" title="mac 下的使用"></a>mac 下的使用</h3><h4 id="安装-ansible"><a href="#安装-ansible" class="headerlink" title="安装 ansible"></a>安装 ansible</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果报错 No such file or directory @ xxx, </span><br><span class="hljs-comment"># 大概率是因为设置了国内源，这是由于国内源没有同步某些包，要不再换个源，要不就：</span><br><span class="hljs-comment"># export HOMEBREW_BOTTLE_DOMAIN=&#x27;&#x27;</span><br><br>brew install ansible<br><br><span class="hljs-comment"># pip install ansible</span><br></code></pre></td></tr></table></figure><h4 id="基本文件"><a href="#基本文件" class="headerlink" title="基本文件"></a>基本文件</h4><h5 id="config-file"><a href="#config-file" class="headerlink" title="config file"></a>config file</h5><p>这是 ansible 的配置文件，会按照 $ANSIBLE_CFG、./ansible.cfg、~/.ansible.cfg、/etc/ansible/ansible.cfg 几个路径搜寻。</p><p>用来配置 ansible 的默认行为。常用的配置说明可以参考 <a href="https://blog.csdn.net/vipygd/article/details/101868144">ansible.cfg常用配置</a></p><p>也可以查看 <a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html">官方文档</a></p><p>我的一个简单的配置长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">[defaults]<br>remote_port = 22<br>remote_user = root<br>forks = 10<br>retry_files_save_path = /tmp/.ansible-retry<br><br>host_key_checking = False<br>deprecation_warnings = False<br>command_warnings = False<br>gathering = smart<br><br>inventory = inventory/hosts<br></code></pre></td></tr></table></figure><h5 id="inventory"><a href="#inventory" class="headerlink" title="inventory"></a>inventory</h5><p>这是要被管理的机器的配置，主要是 host 和连接方式的配置。<br>文件大概长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">[nfs]<br>10.10.10.4<br><br>[server_init]<br><br>[server]<br>10.10.10.5 ansible_ssh_user=root<br><br>[agent]<br>10.10.10.6<br>10.10.10.7<br><br>[remove_server]<br>10.10.10.5<br><br>[remove_agent]<br>10.10.10.6<br>10.10.10.7<br><br>[k3s:children]<br>server_init<br>server<br>agent<br><br></code></pre></td></tr></table></figure><p>更多用法可以查看 <a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html">官方文档</a></p><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><ul><li><p>执行一个简单的 shell 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible nfs  -m shell -a <span class="hljs-string">&#x27;uptime&#x27;</span><br><span class="hljs-comment"># 10.10.10.4 | CHANGED | rc=0 &gt;&gt;</span><br><span class="hljs-comment"># 11:57:12 up 418 days, 13:03,  1 user,  load average: 0.04, 0.04,  0.05</span><br></code></pre></td></tr></table></figure></li><li><p>打开调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 调试常用 debug 模块，可以定向打印出一些信息，自己学习的时候可以看更多的信息，用 -v 或 -vvv 打开 ansible 的日志。</span><br><br>ansible all  -m shell -a <span class="hljs-string">&#x27;uptime&#x27;</span> -vvv<br><br><span class="hljs-comment"># 一大堆信息，可以用于帮助理解 ansible 究竟干了啥</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="调试一下-template"><a href="#调试一下-template" class="headerlink" title="调试一下 template"></a>调试一下 template</h4><p>ansible 的 template 在 playbook 下使用，极大扩展了 ansible 的灵活性，有啥是一个模板解决不了的呢？毕竟模板意味着编程能力。</p><p>tempalte 使用的是 python 的 jinja2 作为模板语言。就开发而言，用模板生成内容有两种模式，通过编程拼接模板 和 在模板中编程，毫无疑问，ansible 是 在模板中编程 的路子。</p><p>template 需要两个主题： 模板、变量。</p><p>变量的来源在 ansible 中比较多，主要分为两类： 内置变量、用户生成变量。<br>变量的使用主要有两个方面： tempalte 中， task 的逻辑语句中。</p><ul><li><a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html">特殊变量官方文档</a></li><li><a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html">普通变量使用官方文档</a></li></ul><p>用户生成变量的地方主要有这么几个： <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#understanding-variable-precedence">参考官方文档</a></p><ul><li>在特定文件中生成，例如 inventory 文件、playbook文件、role文件等。</li><li>在命令行中传入 <code>--extra-vars xx=xxx xx2=xxxx</code> (简写为 <code>-e</code>)</li></ul><p>具体可以查看 <a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#where-to-set-variables">变量使用官方文档</a></p><p>写 ansible 的 playbook 需要两方面的核心知识：</p><ul><li>理解具体的业务逻辑，这样才能抽象出合适的 role </li><li>理解 ansible 的运行逻辑，主要包括 各配置文件及字段含义 ( <a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html">config字段</a> 、<a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html">palybook的字段</a>、 <a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html">inventory字段</a>)、<a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html">变量</a>、<a href="https://docs.ansible.com/ansible/latest/collections/all_plugins.html">plugin</a> (plugin极其重要，以后写配置时经常去里面查询各种字段含义)</li></ul><p>需要注意的是，ansible 新版本在 plugin/module 的使用上和之前 2.9 的版本有一些差别，主要是没有命名空间的概念，例如，都是使用 file 模块(管理远端文件及文件夹)，现在的版本是<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/file_module.html#ansible-collections-ansible-builtin-file-module">这样写</a>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">a</span> <span class="hljs-string">directory</span> <span class="hljs-string">if</span> <span class="hljs-string">it</span> <span class="hljs-string">does</span> <span class="hljs-string">not</span> <span class="hljs-string">exist</span><br>  <span class="hljs-attr">ansible.builtin.file:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/some_directory</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">directory</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">&#x27;0755&#x27;</span><br></code></pre></td></tr></table></figure><p>而 2.9 的版本是<a href="https://docs.ansible.com/ansible/2.9/modules/file_module.html#examples">这样写</a>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">a</span> <span class="hljs-string">directory</span> <span class="hljs-string">if</span> <span class="hljs-string">it</span> <span class="hljs-string">does</span> <span class="hljs-string">not</span> <span class="hljs-string">exist</span><br>  <span class="hljs-attr">file:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/some_directory</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">directory</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">&#x27;0755&#x27;</span><br></code></pre></td></tr></table></figure><p>看到这样的写法，找不到对应的字段说明先不要慌张，说明是 2.9 之前的版本，具体可以查看 <a href="https://docs.ansible.com/ansible/2.9/modules/list_of_files_modules.html">module index</a></p><p>为了简单调试，我们直接使用 命令行传入。;</p><p>使用了 <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#ansible-collections-ansible-builtin-template-module">template</a>、 <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/copy_module.html#examples">copy</a>、<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#examples">shell</a> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">send</span> <span class="hljs-string">files</span><br>  <span class="hljs-attr">ansible.builtin.copy:</span><br>    <span class="hljs-attr">src:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.src &#125;&#125;</span>&quot;</span><br>    <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.dest &#125;&#125;</span>&quot;</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.mode &#125;&#125;</span>&quot;</span><br>  <span class="hljs-attr">with_items:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">src:</span> <span class="hljs-string">&quot;test.sh&quot;</span>, <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;/tmp/longtest/test.sh&quot;</span> ,<span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;0755&quot;</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">src:</span> <span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;/tmp/longtest/hello.txt&quot;</span> ,<span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;0644&quot;</span> &#125;<br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">cat</span> <span class="hljs-string">run</span><br>  <span class="hljs-attr">ansible.builtin.shell:</span><br>    <span class="hljs-attr">cmd:</span> <span class="hljs-string">cat</span> <span class="hljs-string">/tmp/longtest/hello.txt</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">sh</span> <span class="hljs-string">run</span><br>  <span class="hljs-attr">ansible.builtin.shell:</span><br>    <span class="hljs-attr">cmd:</span> <span class="hljs-string">sh</span> <span class="hljs-string">/tmp/longtest/test.sh</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ping</span> <span class="hljs-string">test</span> <span class="hljs-string">template</span> <span class="hljs-string">send</span> <span class="hljs-string">files</span><br>  <span class="hljs-attr">ansible.builtin.template:</span><br>    <span class="hljs-attr">src:</span> <span class="hljs-string">pingpong.yaml.j2</span><br>    <span class="hljs-attr">dest:</span> <span class="hljs-string">&quot;/tmp/longtest/pingpong.yaml&quot;</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-number">0640</span><br></code></pre></td></tr></table></figure><p>以下是 templates/pingpong.yaml.j2 的一部分内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pingpong</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">config.yaml:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    app_name: &quot;pingpong&quot;</span><br><span class="hljs-string">    server:</span><br><span class="hljs-string">      port: 8080</span><br><span class="hljs-string">    log:</span><br><span class="hljs-string">      level: &quot;info&quot;</span><br><span class="hljs-string">    companyName: &quot;longtest&quot;</span><br><span class="hljs-string">    ping:</span><br><span class="hljs-string">      Enable: &#123;&#123;EXT_PINGPONG_ENABLE&#125;&#125;</span><br><span class="hljs-string">      CronPattern: &quot;0 */2 * * * *&quot;</span><br><span class="hljs-string">      Host: &quot;&quot;</span><br><span class="hljs-string">      Auth:</span><br><span class="hljs-string">        Enable: false</span><br></code></pre></td></tr></table></figure><p>运行以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible-playbook -e <span class="hljs-string">&#x27;EXT_GLOBAL_DOMAIN=https://longalong.cn EXT_PINGPONG_ENABLE=true&#x27;</span> ping.yaml  -vv<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs text">PLAYBOOK: ping.yaml **************************************************************************************************************************************************************************<br>1 plays in ping.yaml<br><br>PLAY [server] ********************************************************************************************************************************************************************************<br><br>TASK [Gathering Facts] ***********************************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/ping.yaml:2<br>ok: [101.42.240.235]<br><br>TASK [ping : ping test send files] ***********************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:2<br>ok: [101.42.240.235] =&gt; (item=&#123;&#x27;src&#x27;: &#x27;test.sh&#x27;, &#x27;dest&#x27;: &#x27;/tmp/longtest/test.sh&#x27;, &#x27;mode&#x27;: &#x27;0755&#x27;&#125;) =&gt; &#123;&quot;ansible_loop_var&quot;: &quot;item&quot;, &quot;changed&quot;: false, &quot;checksum&quot;: &quot;fd4ef272800af37c1e5a82235c4f1fdf35d10cfb&quot;, &quot;dest&quot;: &quot;/tmp/longtest/test.sh&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;item&quot;: &#123;&quot;dest&quot;: &quot;/tmp/longtest/test.sh&quot;, &quot;mode&quot;: &quot;0755&quot;, &quot;src&quot;: &quot;test.sh&quot;&#125;, &quot;mode&quot;: &quot;0755&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;path&quot;: &quot;/tmp/longtest/test.sh&quot;, &quot;size&quot;: 71, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;<br><br><br>ok: [101.42.240.235] =&gt; (item=&#123;&#x27;src&#x27;: &#x27;hello.txt&#x27;, &#x27;dest&#x27;: &#x27;/tmp/longtest/hello.txt&#x27;, &#x27;mode&#x27;: &#x27;0644&#x27;&#125;) =&gt; &#123;&quot;ansible_loop_var&quot;: &quot;item&quot;, &quot;changed&quot;: false, &quot;checksum&quot;: &quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;, &quot;dest&quot;: &quot;/tmp/longtest/hello.txt&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;item&quot;: &#123;&quot;dest&quot;: &quot;/tmp/longtest/hello.txt&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;src&quot;: &quot;hello.txt&quot;&#125;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;path&quot;: &quot;/tmp/longtest/hello.txt&quot;, &quot;size&quot;: 11, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;<br><br>TASK [ping : ping test cat run] **************************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:11<br><br><br>changed: [101.42.240.235] =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;cat /tmp/longtest/hello.txt&quot;, &quot;delta&quot;: &quot;0:00:00.053376&quot;, &quot;end&quot;: &quot;2023-02-15 15:01:48.824142&quot;, &quot;msg&quot;: &quot;&quot;, &quot;rc&quot;: 0, &quot;start&quot;: &quot;2023-02-15 15:01:48.770766&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;hello world&quot;, &quot;stdout_lines&quot;: [&quot;hello world&quot;]&#125;<br><br>TASK [ping : ping test sh run] ***************************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:15<br>changed: [101.42.240.235] =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;sh /tmp/longtest/test.sh&quot;, &quot;delta&quot;: &quot;0:00:00.055170&quot;, &quot;end&quot;: &quot;2023-02-15 15:01:51.329984&quot;, &quot;msg&quot;: &quot;&quot;, &quot;rc&quot;: 0, &quot;start&quot;: &quot;2023-02-15 15:01:51.274814&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;hi there, i am an ansible test now is 2023年 02月 15日 星期三 15:01:51 CST&quot;, &quot;stdout_lines&quot;: [&quot;hi there, i am an ansible test now is 2023年 02月 15日 星期三 15:01:51 CST&quot;]&#125;<br><br>TASK [ping : ping test template send files] **************************************************************************************************************************************************<br>task path: /Users/andyhu/code/mastergo-deployer/dockerfile/roles/ping/tasks/main.yaml:19<br>changed: [101.42.240.235] =&gt; &#123;&quot;changed&quot;: true, &quot;checksum&quot;: &quot;c6f37e5b898f9bcd1033afe74751741eee722ab0&quot;, &quot;dest&quot;: &quot;/tmp/longtest/pingpong.yaml&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;50ad443f786f2ff265c5f967710a1103&quot;, &quot;mode&quot;: &quot;0640&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;size&quot;: 2755, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1676444511.604792-82491-153536252047673/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;<br><br>PLAY RECAP ***********************************************************************************************************************************************************************************<br>101.42.240.235             : ok=5    changed=3    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 <br></code></pre></td></tr></table></figure><h3 id="可视化管理工具-awx"><a href="#可视化管理工具-awx" class="headerlink" title="可视化管理工具 awx"></a>可视化管理工具 awx</h3><p>awx 是 ansible 的可视化管理工具，是 tower 的开源版。</p><p>不得不说，awx 的文档真的是有点……</p><p>还没跑通，回头再看下吧</p><p><a href="https://github.com/ansible/awx">awx github 地址</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>这篇文章可以看一下： <a href="https://docs.ansible.com/ansible/latest/tips_tricks/ansible_tips_tricks.html#playbook-tips">playbook-tips</a></li></ul><hr><blockquote><p>Don’t turn away from possible futures before you’re certain you don’t have anything to learn from them.<br>— <cite>Richard Bach</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;shell&quot;&gt;&lt;a href=&quot;#shell&quot; class=&quot;headerlink&quot; title=&quot;shell&quot;&gt;&lt;/a&gt;shell&lt;/h2&gt;&lt;h3 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;</summary>
      
    
    
    
    
    <category term="linux" scheme="https://iamlongalong.github.io/longblog/tags/linux/"/>
    
    <category term="shell" scheme="https://iamlongalong.github.io/longblog/tags/shell/"/>
    
    <category term="batch" scheme="https://iamlongalong.github.io/longblog/tags/batch/"/>
    
    <category term="ansible" scheme="https://iamlongalong.github.io/longblog/tags/ansible/"/>
    
    <category term="批任务" scheme="https://iamlongalong.github.io/longblog/tags/%E6%89%B9%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="批处理" scheme="https://iamlongalong.github.io/longblog/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>聊聊心力</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_08_08_16_20_thoughts_of_heart_strength.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_08_08_16_20_thoughts_of_heart_strength.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:26:16.145Z</updated>
    
    <content type="html"><![CDATA[<p>当我们后知后觉地找到了一个自认为 “有价值” 的目标后，就开始了漫长的征途，朝着目标前行。就像长跑一样，知道了自己是参加的 10km 跑后，就沿着跑道一步步前行。</p><p>当人有了目标之后，就会产生一系列的精神活动。</p><p>有一种精神活动，是通过想象自己已经达到了目标，产生一些快乐，可以认为是提前享受成功喜悦的快乐。这种快乐很有价值，能激励我们继续向着目标前行，但同样，也容易产生一种错觉，觉得自己很快就能达到目标。</p><p>另一种精神活动是，会经常去对标这个目标，看看自己距离目标还有多远。这种活动的价值，在于认清现状，找到真正该做的事。但也容易产生 心理落差，预期的前进速度和现实的前进速度的差距，就是落差，当一个人的期待越高，落差就会越大，认清现实后，摔下来也就越疼。</p><p>有时候，当我们遭受一些挫折，会有 无力、身心疲惫、累觉不爱 等等感受。我们会本能地选择逃避，只想躺在沙发上，随便刷刷手机；或躺在床上，闷头大睡；或玩游戏、或看肥皂剧；只要能不让自己去想那些烦心事儿，做什么都无所谓……</p><p>走向目标的路上有着种种 挫折，这些都会让我们产生 <code>挫败感</code>。 挫折 是每个人都在每个目标上，都一定会遇到的，但这些挫折会成为你成长道路上的 垫脚石 还是 绊脚石，对不同的人却是不同的，这取决于我们看待问题的 态度。</p><p>趋利避害，是人的天性。但天性很多时候只能解决 眼前的 问题，却无法解决长远的问题，持续的逃避，只能让我们止步不前，无法继续通往期待的彼岸。</p><p>有很多概念都在描述人在处理挫折时的能力，比如 <code>心力</code> 、<code>逆商</code>、<code>钝感力</code> 等等，基本都只有一些感性上的解释，不过不阻碍我们找到一些好的方法，让我们保持持续的活力。</p><p><a href="https://wiki.mbalib.com/wiki/%E9%92%9D%E6%84%9F%E5%8A%9B">钝感力</a>，大概是指 <code>迟钝的力量，能从容面对生活中的挫折和伤痛，坚定地朝着自己的方向前进</code>，是在面对困难时，还能厚着脸皮对抗外界的能力，是一种积极向上的人生态度。</p><p><a href="https://wiki.mbalib.com/wiki/%E9%80%86%E5%95%86">逆商</a>，通常和 智商、情商 并称为 3Q，是指人们在面对挫折、摆脱困境和超越困难的能力。</p><p>心力，我们大致可以用来表示自己当前的精神储备，心力会被消耗，也会被累积。我们可以通过 远离消耗心力的事 来避免心力被消耗殆尽，例如和一些负能量的人保持距离、避免一些没必要的争论、不开无效的会议、少看自己改变不了的社会负面信息 等等。也可以做一些增加心力的事，例如 向正能量的人靠近、和爱的人聊聊开心的事、做自己感兴趣的事、运动、沐浴清风 等等。</p><p>周末心力降到 0 ，没有心思写文章、学算法，甚至不想吃饭。于是我打开了 B 站， 看了下之前一直没看的 《从零开始的异世界生活》，看的过程不细聊了。</p><p>现在回想起来，486 就是一个 心力管理 的典型案例啊。他的心力来源于两个方面： 内在的善良 以及 外在的友人的鼓励。他持续地受到现实的各种打击，也痛苦过，也崩溃过，但在一次一次的痛苦后，又一次一次地爬起来，继续朝着目标前进。</p><p>当我去思考，我们更底层的能量究竟来自于哪里？我发现这和思考 “人生的意义是什么” 一样得不到答案。</p><p>不敢太深究，但在两个维度上，可以用这两个词来解释:  信念、习惯。</p><p>习惯，是日常生活中，保证个人状态的，例如 当你看到散乱的桌面，你是习惯与心烦意乱，还是顺手收拾，还是选择性无视？ 当你受到他人的质疑，你是开始自我怀疑，还是据理力争，还是无力力争，还是自我反思后总结优劣？</p><p>习惯是日常的，也是影响深远的，同时也是我们比较好改变的，改变的关键在于: 识别消耗心力的不良习惯。 </p><p>信念，包含浅层次的 观念，以及深层次的信念。众多的观念构成了一个人价值观的一部分，让他能对遇到的事形成自己的解释，当形成了体系性的解释时，就相当于有了信念。有些人的信念来自于他人，比如追随一个偶像；有些人的信念来自于更抽象的愿景，比如实现共产主义；也有些人的信念来源于一些更靠近每个人的，比如亲情、爱情等。</p><p>当我们看到 一个人很乐观，就不禁去想，他为什么那么乐观？比如前段时间火了的 二舅。当你去问一个乐观的人，你觉得自己不幸吗？你很可能会得到一些共同的回答，比如 我现在健健康康，家人也很和睦，虽然没有太多积蓄，但都在工作，都有收入，跟很多人相比，我已经是很幸运的了。</p><ul><li>佛说，人生有三大苦，怨憎会，爱别离，求不得。</li><li>佛还说，放下，便是拥有。</li><li>道德经中也说，知足者常乐。</li></ul><p>我们可以看到，乐还是苦，有时候是你对自己 所求的 和 所拥有的 之间的比较，当你所求降低，再多关注自己所拥有的，或许会感到更多的幸福。</p><p>有时候我也在想，人活这一生要追求什么？<br>之前看 《凡人》，看到师傅说：活得久了，就愈发觉得，这世上有些东西，比自己的性命还重要。又说：我所修的道，是念头通达。画面内是师傅为了自己所求的道慨然赴死，屏幕前是我内心激动不已，泪光闪动。</p><p>或许，长远来看，我们所追求的是内心的平静，为了守护这份平静，即使拼上一切，即使身死道消，也在所不惜。</p><p>追求内心的平静，并不是 避世 也不是 摆烂，因为内心总有一个声音，虽时强时弱，但你仔细聆听，就一定能听到，它在说着：去做吧，去做你热爱的事，不要害怕，不要胆怯！</p><p>有时候又在想，人活着，不总得拼一拼嘛？才不枉来这世上走了一遭。没拼过，有如何能在夜半十分安然入睡？没拼过，又如何能在垂暮之年笑谈人生？谋事在人，成事在天，不去试一试，谁能知道结果如何？追求自己所热爱的，投入自己的时间、精力、生命，又有何可惜？时间，不总得花在什么事情上吗？</p><p>回看前面几句话，我又有了新的认识。</p><ul><li>求不得，并非让我们 不再求，而是 求，得与不得，得之我幸，不得我命。</li><li>放下的，是执着于结果的心，拥有的，是内心的平静与享受过程的乐趣。</li><li>知足者，对我们不能掌控的事知足，对我们能掌控的事，永不知足！永不停歇！</li></ul><p>究竟要怎么把上面说的这些和当前的状态联系起来，还需要探索，或者说，这是一件需要持续探索的事。</p><hr><blockquote><p>You are the only person on earth who can use your ability.<br>— <cite>Zig Ziglar</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我们后知后觉地找到了一个自认为 “有价值” 的目标后，就开始了漫长的征途，朝着目标前行。就像长跑一样，知道了自己是参加的 10km 跑后，就沿着跑道一步步前行。&lt;/p&gt;
&lt;p&gt;当人有了目标之后，就会产生一系列的精神活动。&lt;/p&gt;
&lt;p&gt;有一种精神活动，是通过想象自己已经达</summary>
      
    
    
    
    
    <category term="心力" scheme="https://iamlongalong.github.io/longblog/tags/%E5%BF%83%E5%8A%9B/"/>
    
    <category term="价值观" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"/>
    
    <category term="信念" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BF%A1%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>grpc的源码走读</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_07_26_17_34_reading_grpc_codes.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_07_26_17_34_reading_grpc_codes.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:26:04.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各包的作用"><a href="#各包的作用" class="headerlink" title="各包的作用"></a>各包的作用</h2><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><ol><li>初始化了默认的 channelz 监控，详见 channelz</li><li>对外暴露了注册监控 server 的方法</li></ol><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>提供了一个简单封装的 immutable kv store 。</p><h3 id="authz"><a href="#authz" class="headerlink" title="authz"></a>authz</h3><p>认证拦截器，提供了 rbac。<br>rbac 模型，使用的是 “github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3” 这个包，这是 envoy 的模块。</p><p>提供了基于文件的拦截器。<br>可以预见，这部分内容，和 envoy 结合会比较紧密。</p><h3 id="backoff"><a href="#backoff" class="headerlink" title="backoff"></a>backoff</h3><p>提供了失败处理的默认 Config，被全局各处引用。重试延迟配置。</p><h3 id="balancer"><a href="#balancer" class="headerlink" title="balancer"></a>balancer</h3><p>使用 注册 的方式，采用 builder 的模式。<br>balancer 包含两个部分，其一 balancer ， 其二 picker。<br>balancer、picker、resolver 均会被 warpper 包裹，用来保证 grpc 内部新增能力。<br>internal 包中的 balancer ，实现了 优雅切换 的功能，是 wapper 中的重要能力。</p><p>k8s 的 resolver 部分，可以参考 <a href="/notpublish/index.html" name="grpc的负载均衡" >grpc的负载均衡</a> </p><h3 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h3><p>提供了一系列用于做基准测试的程序。</p><h3 id="binarylog"><a href="#binarylog" class="headerlink" title="binarylog"></a>binarylog</h3><p>提供了类似于 mysql 的 binlog 机制。提供了方法过滤机制 (config中)。可以把 binlog 写到一个远端地址 (sink)。</p><p>具体实现在 internal 的 binarylog 中。</p><h3 id="channelz"><a href="#channelz" class="headerlink" title="channelz"></a>channelz</h3><p>对外提供 grpc 服务状态指标，和 metrics 的目标一样，本身也是一个 service (和自己写的 grpc service 一样)，提供了几个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ChannelzServer <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Gets all root channels (i.e. channels the application has directly</span><br><span class="hljs-comment">// created). This does not include subchannels nor non-top level channels.</span><br>GetTopChannels(context.Context, *GetTopChannelsRequest) (*GetTopChannelsResponse, error)<br><span class="hljs-comment">// Gets all servers that exist in the process.</span><br>GetServers(context.Context, *GetServersRequest) (*GetServersResponse, error)<br><span class="hljs-comment">// Returns a single Server, or else a NOT_FOUND code.</span><br>GetServer(context.Context, *GetServerRequest) (*GetServerResponse, error)<br><span class="hljs-comment">// Gets all server sockets that exist in the process.</span><br>GetServerSockets(context.Context, *GetServerSocketsRequest) (*GetServerSocketsResponse, error)<br><span class="hljs-comment">// Returns a single Channel, or else a NOT_FOUND code.</span><br>GetChannel(context.Context, *GetChannelRequest) (*GetChannelResponse, error)<br><span class="hljs-comment">// Returns a single Subchannel, or else a NOT_FOUND code.</span><br>GetSubchannel(context.Context, *GetSubchannelRequest) (*GetSubchannelResponse, error)<br><span class="hljs-comment">// Returns a single Socket or else a NOT_FOUND code.</span><br>GetSocket(context.Context, *GetSocketRequest) (*GetSocketResponse, error)<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的实现在 internal 的 channelz 中。</p><p>有一个 <code>Identifier</code> 的封装，还比较有意思，可以用 数值、字符串、类型 做标识，提供了比较的方法，关键是有 <code>集成关系</code> ，可以用于标识类似于 进程关系 。</p><p>一般用于 监控 和 问题排查 和 调试环节，为了更加直观方便，官方提供了 <a href="https://github.com/grpc/grpc-experiments/tree/master/gdebug">ui 工具</a>。关于 channelz 的设计初衷，可以查看 <a href="https://github.com/grpc/proposal/blob/master/A14-channelz.md">proposal</a></p><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>提供了一个简单的 生成 grpc 代码的工具 – protoc-gen-go-grpc  (核心代码在 google.golang.org/protobuf/compiler/protogen 中)</p><h3 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h3><p>类似于 http 的 200、400、401 等等状态码，提供了 grpc 中的状态码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> strToCode = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]Code&#123;<br><span class="hljs-string">`&quot;OK&quot;`</span>: OK,<br><span class="hljs-string">`&quot;CANCELLED&quot;`</span>:<span class="hljs-comment">/* [sic] */</span> Canceled,<br><span class="hljs-string">`&quot;UNKNOWN&quot;`</span>: Unknown,<br><span class="hljs-string">`&quot;INVALID_ARGUMENT&quot;`</span>: InvalidArgument,<br><span class="hljs-string">`&quot;DEADLINE_EXCEEDED&quot;`</span>: DeadlineExceeded,<br><span class="hljs-string">`&quot;NOT_FOUND&quot;`</span>: NotFound,<br><span class="hljs-string">`&quot;ALREADY_EXISTS&quot;`</span>: AlreadyExists,<br><span class="hljs-string">`&quot;PERMISSION_DENIED&quot;`</span>: PermissionDenied,<br><span class="hljs-string">`&quot;RESOURCE_EXHAUSTED&quot;`</span>: ResourceExhausted,<br><span class="hljs-string">`&quot;FAILED_PRECONDITION&quot;`</span>: FailedPrecondition,<br><span class="hljs-string">`&quot;ABORTED&quot;`</span>: Aborted,<br><span class="hljs-string">`&quot;OUT_OF_RANGE&quot;`</span>: OutOfRange,<br><span class="hljs-string">`&quot;UNIMPLEMENTED&quot;`</span>: Unimplemented,<br><span class="hljs-string">`&quot;INTERNAL&quot;`</span>: Internal,<br><span class="hljs-string">`&quot;UNAVAILABLE&quot;`</span>: Unavailable,<br><span class="hljs-string">`&quot;DATA_LOSS&quot;`</span>: DataLoss,<br><span class="hljs-string">`&quot;UNAUTHENTICATED&quot;`</span>: Unauthenticated,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="connectivity"><a href="#connectivity" class="headerlink" title="connectivity"></a>connectivity</h3><p>连接状态的定义，详见 state 包。</p><h3 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a>credentials</h3><p>提供 grpc 的认证能力。<br>默认有:  tls、<a href="https://www.servicemesher.com/blog/envoy-xds-protocol/">xds</a>、<a href="https://datatracker.ietf.org/doc/html/rfc8693">sts</a>、oauth、<a href="https://cloud.google.com/docs/security/encryption-in-transit/application-layer-transport-security">alts</a>、local、insecure、google cloud 的方式。</p><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>序列化方法 和 压缩方法。 提供了基于 proto 的序列化方法  和  基于 gzip 的压缩方法。</p><h3 id="gcp"><a href="#gcp" class="headerlink" title="gcp"></a>gcp</h3><p>希望提供 OpenCensus 的能力，目前还在测试阶段。</p><h3 id="grpclog"><a href="#grpclog" class="headerlink" title="grpclog"></a>grpclog</h3><p>logger 的使用为在一个包中，这个包初始化一个带 tag 的 logger 实例 (有缓存)。</p><p>其他方面设计中规中矩，使用的 github.com.golang/glog 作为底层 log 包</p><h3 id="health"><a href="#health" class="headerlink" title="health"></a>health</h3><p>提供客户端的健康检查接口，为了解决服务假死的情况。</p><h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h3><p>各种功能的具体实现 以及 一些工具库。</p><h3 id="interop"><a href="#interop" class="headerlink" title="interop"></a>interop</h3><p>一些用于测试的程序</p><h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>保持连接的配置。</p><h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>类似于 http 的 header，一个 <code>map[string][]string</code> ，用来传递元信息，例如 requestID 等。<br>提供注入 ctx 和 从 ctx 提取的方法。</p><h3 id="peer"><a href="#peer" class="headerlink" title="peer"></a>peer</h3><p>用来表示对端的连接信息。用来做认证的信息传输，具体信息可以查看 credentials 部分。</p><h3 id="profiling"><a href="#profiling" class="headerlink" title="profiling"></a>profiling</h3><p>性能工具，和上面的 channelz 类似，也是一个提供接口的 service，可以记录每个接口的时长等。<br>提供了 json 转义工具。<br>目前使用较少。</p><p>提供了一个 buffer.go 的文件，主要实现了一个 ring buffer，使用 atomic 实现的无锁 buffer ，值得参考 。[TODO]</p><h3 id="reflection"><a href="#reflection" class="headerlink" title="reflection"></a>reflection</h3><p>提供各 service 的反射，也是一个提供接口的 service，能够获取到每个 service 的入参与出参的格式。<br>一个最常规的用法是用于 <a href="https://github.com/fullstorydev/grpcurl">grpcurl</a></p><h3 id="resolver"><a href="#resolver" class="headerlink" title="resolver"></a>resolver</h3><p>用于处理 <code>service name 解析</code>  ，默认不做解析 (由更底层的 net 包做解析)，除非自己指定 resolver 方法。<br>关于 name 的定义详情，可以参考 <a href="https://github.com/grpc/grpc/blob/master/doc/naming.md">grpc 官方文档</a>，URI 规范用的 <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a></p><p>从代码模式上看，使用了 建造者 模式，接口为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Builder <span class="hljs-keyword">interface</span> &#123;<br>Build(xxx, xxx, opts BuildOptions) (Resolver, error)<br>Scheme() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>resovler 从预期看，应该只需要一次调用，然后给 resolver 提供回调的能力 ( <code>ClientConn.UpdateState()</code> )。</p><p>建造者模式 相比于直接实例化，提供了 需要时再实例化 的能力。</p><h3 id="security"><a href="#security" class="headerlink" title="security"></a>security</h3><ol><li>提供了基于 rbac 的授权工具。</li><li>提供了 tls 工具，验证证书。</li></ol><p>具体可以参考 credentials</p><p>使用了 <a href="https://github.com/google/cel-go">cel-go</a> 这个规则引擎。值得进一步看下。可以参考<a href="https://cloud.tencent.com/developer/article/2025423">这篇文章</a> 。规则引擎的语言定义可以查看<a href="https://github.com/google/cel-spec/blob/master/doc/langdef.md">官方文档</a></p><h3 id="serviceconfig"><a href="#serviceconfig" class="headerlink" title="serviceconfig"></a>serviceconfig</h3><p>config 的类型接口定义。不知道用作什么目的。</p><h3 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h3><p>用于统计请求信息，类似于 tracing 和 metrics，在初始化 server 时，通过 options 注入。</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>和 http 的状态码相似，不过支持自定义的 msg 信息，通过 error 传递。</p><h3 id="stress"><a href="#stress" class="headerlink" title="stress"></a>stress</h3><p>压测脚本</p><h3 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h3><p>xxx</p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>大量集中性单元测试</p><h3 id="xds"><a href="#xds" class="headerlink" title="xds"></a>xds</h3><p><a href="https://www.servicemesher.com/blog/envoy-xds-protocol/">xds的介绍</a> 、 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol">envoy 官方文档</a> 、<a href="https://github.com/grpc/proposal/blob/master/A40-csds-support.md">grpc proposal</a><br>这是一系列资源发现服务的接口集合。<br>这个包是一套庞大的 xds 工具集，包括 client 和 server 。</p><p>因为还庞大的一套体系，没细读，之后找时间和 envoy 等一起阅读。【TODO】</p><h2 id="整体的一些感受"><a href="#整体的一些感受" class="headerlink" title="整体的一些感受"></a>整体的一些感受</h2><p>grpc  是一个很大的体系，对于 grpc 的使用也有很多的技巧，初始使用时，会觉得很简单，尤其是以后加接口做维护啥的。 但实际上，grpc 也有很多细节，甚至很多同学都不知道。<br>例如， grpc 有自己的一套 error code 方式、grpc 的 resolver 可以实现多种类型的 uri 、grpc 默认使用 pickfirst 的 lb 策略、grpc 有很多认证方式、grpc 可以用 admin 做调试、stats 做 metrics 监控 等等。</p><p>后续需要去看一下别人都是怎么使用 grpc 的，看看一些最佳实践。</p><h2 id="对于代码走读"><a href="#对于代码走读" class="headerlink" title="对于代码走读"></a>对于代码走读</h2><p>#readingcodes </p><p>代码的走读有 3 个层次：</p><ol><li>理解项目的整体模型</li><li>理解各个包解决了什么问题，大致怎么实现的</li><li>分析一些包的设计，找其亮点，想想如果自己写，会怎么写</li></ol><p>从产出的角度看，可以有：</p><ol><li>走读记录 (包的作用、设计好的地方)</li><li>代码结构图 ( 包结构、类关系、时序 )  </li></ol><p>如果能把 类关系图 和 时序图 画出来，那就很不错了。</p><hr><blockquote><p>My best friend is the one who brings out the best in me.<br>— <cite>Henry Ford</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;各包的作用&quot;&gt;&lt;a href=&quot;#各包的作用&quot; class=&quot;headerlink&quot; title=&quot;各包的作用&quot;&gt;&lt;/a&gt;各包的作用&lt;/h2&gt;&lt;h3 id=&quot;admin&quot;&gt;&lt;a href=&quot;#admin&quot; class=&quot;headerlink&quot; title=&quot;adm</summary>
      
    
    
    
    
    <category term="readingcodes" scheme="https://iamlongalong.github.io/longblog/tags/readingcodes/"/>
    
    <category term="grpc" scheme="https://iamlongalong.github.io/longblog/tags/grpc/"/>
    
    <category term="xds" scheme="https://iamlongalong.github.io/longblog/tags/xds/"/>
    
  </entry>
  
  <entry>
    <title>serverless_究竟是何方神圣？</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_07_11_what_is_serverless.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_07_11_what_is_serverless.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:27:49.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-serverless"><a href="#什么是-serverless" class="headerlink" title="什么是 serverless"></a>什么是 serverless</h2><p>顾名思义，<code>serverless</code> 就是 <code>server-less</code>，也就是 <code>别话时间去搞服务器</code> =&gt; <code>把精力全都放到业务开发上</code> !</p><p>在传统的开发流程中，一个团队的标准配置是： 前端工程师 * x + 后端工程师 * y + 运维工程师 * z 。 前端写交互，后端写数据逻辑与存储，运维就搞服务部署、灰度、日志、监控等等。每个岗位各司其职，看起来十分完美。</p><p>但有时候也没有那么完美，人越多、职责分的越细，岗位间的鸿沟就越大，沟通的成本在组织内就会急剧增加。 通常的表现就是 会越来越多、参会的人也越拉越多，有时候可能一个简单的 <code>上新服务进行调试</code> 的工作，都需要大动干戈搞十来个人拉会各种同步和对齐。</p><p>这种时候我们可能就会想： 能不能不要这么多麻烦的服务器的问题？由一个统一的平台去解决 网关配置、服务发现、服务调用、日志、告警、数据库、中间件、CICD、负载均衡、动态扩缩容 等等……</p><p>实际上，不论是传统的各种 cmdb，还是各种微服务框架，还是各种服务引擎，都是在为了解决上面列出的这个问题，只是他们选择的方案不同而已。 其中 serverless，是最晚出现的一种方案，是在 微服务架构之后出现的另一种架构风格。</p><p>有一种论调是 serverless = faas + baas。其中 faas 是主计算的，而 baas 是主存储的。实际上我们对服务器的需求本质上就这两类： 计算 + 存储。</p><p>而泛 IT 领域内，大家常说起 serverless 的时候，总喜欢把 AWS 的 lambda 计算作为例子，或者把 阿里云 的 函数计算 作为例子。容易让人误以为 serverless 就是 <code>函数计算</code> 。</p><p>而我认为 serverless ，除了包括 机器视角下 的 faas 以及 baas 外，还包括 开发流 视角下的 serverless 开发工具链 + 管理平台 + 编排系统 + 监控系统。 这是站在 serverless 的终极目标上得出的结论。</p><p>云服务上更关心 机器视角，例如 baas 要包含哪些产品？kv？文档存储？对象存储？table存储？ 例如 faas 有哪些形式的延伸？微服务场景？任务触发场景？</p><p>开发者更关心 开发流视角，例如 如何部署一段程序？如何管理一段程序？如何监控程序运行？</p><h2 id="serverless-解决了什么问题？"><a href="#serverless-解决了什么问题？" class="headerlink" title="serverless 解决了什么问题？"></a>serverless 解决了什么问题？</h2><ol><li>开发和部署工具链</li><li>弹性扩缩容 (按量付费)</li></ol><h2 id="使用-serverless-的场景是什么？"><a href="#使用-serverless-的场景是什么？" class="headerlink" title="使用 serverless 的场景是什么？"></a>使用 serverless 的场景是什么？</h2><ol><li>异步 (事件触发)</li><li>无状态 (少依赖)</li><li>突发性</li></ol><h2 id="serverless-的技术点有哪些？"><a href="#serverless-的技术点有哪些？" class="headerlink" title="serverless 的技术点有哪些？"></a>serverless 的技术点有哪些？</h2><ol><li>如何触发 serverless？(events)</li><li>如何解决弹性扩缩容？<ol><li>基于 kubernetes</li></ol></li><li>如何解决路由绑定？(负载均衡)</li><li>如何解决快速启动？</li><li>如何解决程序运行？(build 过程)</li><li>如何解决服务编排？</li></ol><h2 id="serverless-比较难搞定什么？"><a href="#serverless-比较难搞定什么？" class="headerlink" title="serverless 比较难搞定什么？"></a>serverless 比较难搞定什么？</h2><ol><li><p>状态保持 (本地缓存、长连接)</p></li><li><p>事务</p></li><li><p>编排</p></li><li><p>冷启动</p></li><li><p>黑盒排查问题</p></li><li><p>服务商绑定</p></li></ol><h2 id="阿里云的几款-serverless-产品的异同"><a href="#阿里云的几款-serverless-产品的异同" class="headerlink" title="阿里云的几款 serverless 产品的异同"></a>阿里云的几款 serverless 产品的异同</h2><ol><li>FC</li><li>SAE</li><li>MSE</li><li>ASK</li></ol><p>当我们纵眼观察 阿里云 提供了几类和 serverless 有关的产品时，往往容易犯迷糊。<br>FC 是函数计算，主要目的是提供计算能力，运行的资源粒度可以非常小 (128MB * 0.08 C)，可以运行任意你想要的程序。在使用场景上，类似于 <code>任务</code> 的概念。(当然你也可以把他用于 http server)</p><p>SAE 是 serverless 应用引擎，提供的能力和 FC 类似，都是计算能力。在场景上，类似于 <code>service</code> 的概念，例如启动一个 auth 服务。 相比于传统的自己部署一个服务，SAE 提供了 网关、弹性伸缩、监控 等能力。(其实，MSE 有逐渐替代 SAE 的倾向，毕竟他们的重合度太高了)</p><p>MSE 是 微服务引擎，提供的是 服务治理 的能力。是 注册/配置中心、网关、分布式事务、流量治理、开发测试 的集合体。实际就是把原来 阿里云 提供的各类单个的产品，在 微服务 的应用场景下进行了组合。</p><p>ASK 是 弹性 k8s 集群，也就是 k8s 集群的按量付费版本，提供的是 k8s 基础设施。</p><h2 id="我们对-serverless-抱有什么样的期待？"><a href="#我们对-serverless-抱有什么样的期待？" class="headerlink" title="我们对 serverless 抱有什么样的期待？"></a>我们对 serverless 抱有什么样的期待？</h2><ol><li>完全无运维 <ul><li>一套完善的开发和部署平台</li></ul></li><li>友好一致的开发体验<ul><li>开发者无需关注除 业务需求 之外的一切 (比如 k8s、注册中心、服务发现、CICD 等等)</li></ul></li><li>省钱<ul><li>按需付费，不用为每个不怎么使用的应用都花着钱</li></ul></li></ol><h2 id="一些常见的-serverless-应用"><a href="#一些常见的-serverless-应用" class="headerlink" title="一些常见的 serverless 应用"></a>一些常见的 serverless 应用</h2><ul><li><input disabled="" type="checkbox"> 举一些具体的例子</li></ul><ol><li>音视频行业的转码需求</li><li>设计、图形等领域相关的渲染需求</li><li>推荐系统相关的机器学习需求</li></ol><p>分为 2 类：</p><ol><li>微服务场景</li><li>弹性任务场景</li></ol><h2 id="serverless-平台有哪些？"><a href="#serverless-平台有哪些？" class="headerlink" title="serverless 平台有哪些？"></a>serverless 平台有哪些？</h2><ul><li><input disabled="" type="checkbox"> 对比各家的产品，看看他们都在解决什么问题？</li></ul><ol><li>openfaas</li><li>knative</li><li>kubeless</li><li>阿里云相关产品</li><li>腾讯云相关产品</li><li>AWS 相关产品</li></ol><h2 id="我会怎么选？"><a href="#我会怎么选？" class="headerlink" title="我会怎么选？"></a>我会怎么选？</h2><ul><li><input disabled="" type="checkbox"> 列举一些场景，分别在这些场景下我会如何决策？</li></ul><p>如果我是团队 TL，我会如何选择？</p><h2 id="可以参考的文档"><a href="#可以参考的文档" class="headerlink" title="可以参考的文档"></a>可以参考的文档</h2><ol><li><a href="https://www.aliyun.com/product/aliware/fnf">阿里云 serverless 工作流</a></li><li><a href="https://help.aliyun.com/document_detail/97792.html">阿里云 serverless 应用引擎</a></li><li><a href="https://www.aliyun.com/product/fc">阿里云 FC 函数计算</a></li><li><a href="https://www.aliyun.com/product/cs/ask">阿里云 ASK 容器服务</a></li><li><a href="https://cloud.tencent.com/document/product/583/9199">腾讯云函数</a></li><li><a href="https://cloud.tencent.com/document/product/1154">腾讯云 serverless 应用中心</a></li><li><a href="https://cloud.tencent.com/document/product/1371">腾讯云 弹性微服务</a></li><li><a href="https://firebase.google.com/">firebase</a></li></ol><hr><blockquote><p>Through meditation and by giving full attention to one thing at a time, we can learn to direct attention where we choose.<br>— <cite>Eknath Easwaran</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-serverless&quot;&gt;&lt;a href=&quot;#什么是-serverless&quot; class=&quot;headerlink&quot; title=&quot;什么是 serverless&quot;&gt;&lt;/a&gt;什么是 serverless&lt;/h2&gt;&lt;p&gt;顾名思义，&lt;code&gt;serverless&lt;</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://iamlongalong.github.io/longblog/tags/k8s/"/>
    
    <category term="serverless" scheme="https://iamlongalong.github.io/longblog/tags/serverless/"/>
    
    <category term="faas" scheme="https://iamlongalong.github.io/longblog/tags/faas/"/>
    
    <category term="baas" scheme="https://iamlongalong.github.io/longblog/tags/baas/"/>
    
    <category term="cloud native" scheme="https://iamlongalong.github.io/longblog/tags/cloud-native/"/>
    
  </entry>
  
  <entry>
    <title>几种后端通信方式的杂谈</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_3_25_some_kinds_of_communication_in_backends.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_3_25_some_kinds_of_communication_in_backends.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:24:31.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机的几种通信方式"><a href="#计算机的几种通信方式" class="headerlink" title="计算机的几种通信方式"></a>计算机的几种通信方式</h2><p>对于计算机而言，通信 是一件永远不可能被忽视的事情。通信 基本可以分为 进程内通信 和 进程间通信。 进程内通信的方式大致有： <code>① 共享内存</code>  <code>② 变量传递</code>。进程间通信又需要分为 在同一操作系统上 和 在不同操作系统上，同一操作系统上的进程间通信主要有 <code>① 共享内存</code>  <code>② 共享存储</code> <code>③ 管道(命名)</code> <code>④ 信号量</code> <code>⑤ 消息队列</code> <code>⑥ socket</code> 通信。不同操作系统上，则只能使用 <code>socket</code> 通信。</p><p>实际上，从上面可以看出，除了 <code>信号量</code> 的通信方式比较独特外，其他的通信方式都是基于 <code>共享</code> 或 <code>传递</code> 的进行。只是 共享的方式 和 传递的方式 有所差别。</p><h3 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h3><p>在 进程内通信时，共享内存 是可以被特定编程语言直接使用的内存格式，因此效率非常高；在进程间的共享内存上，内存是最底层的共享方式，因此内存格式需要自己约定，也就意味着所有传递的值 需要经过一定的格式转换，也就是 序列化的过程。</p><p>在 进程内通信时，变量传递可以分为 值传递 和 引用传递 ，所有的操作都是编程语言做的，我们只管使用即可。但在 进程间的消息传递时，我们则需要自己处理 消息格式 的问题，也即是 序列化和反序列化 的过程。</p><p>上述的这些通信方式，实际上是很通用的模型，不仅在操作系统层被使用，在应用层，我们基于这些模型造了很多工具或软件系统。例如，共享内存 我们有 <code>redis</code> 、<code>memcache</code> 等，共享存储 我们有 <code>mysql</code>、<code>etcd</code>、<code>mongodb</code> 等等，管道 我们有 <code>redis</code> ，消息队列 我们有 <code>kafka</code>、<code>zeroMQ</code> 、<code>rabbitMQ</code> 等等，甚至有一些 消息队列的通用协议，例如 <code>MQTT</code>、<code>AMQP</code> 等等。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>最繁荣的进程间通信方式，实际上还是 <code>socket</code> 通信，socket 本身只是一个接口定义，不过这个接口定义太通用了，任何消息传递几乎都可以套用这个接口，无论是 <code>文件</code>、<code>网络</code> 还是 <code>内存</code> 。</p><h2 id="服务端的常见通信方式"><a href="#服务端的常见通信方式" class="headerlink" title="服务端的常见通信方式"></a>服务端的常见通信方式</h2><p>对于服务端开发而言，最常用的还是基于 网络 的 socket 编程，最底层自然都依赖 TCP/UDP，在应用层上，我们有非常多的协议，例如 <code>http</code> 、<code>http2</code> 、 <code>http3</code> 、<code>websocket</code>、 <code>MQTT</code> 以及各种小领域的协议，其实，所有的协议，都是对特定领域的通信内容的通用抽象，例如，http 是一个很常用的互联网请求协议，包含 请求行 、请求头 、请求体 ，一般认为 http 是一个 文本协议，实际上这指的是其 序列化方式，文本内容直接通过 ascll [待验证] 进行传输，背景是 http 协议出生在 文本内容共享浏览 的互联网初始定位 的时代。</p><p>后来发现 http 的传输效率不高，于是 http2 做了 压缩消息头 、二进制分帧传输、连接复用 的优化。在后来，认为基于 tcp 的传输效率还是有点低，而现代基础设施整体是比较好的，因此基于 udp 在应用层做了一些消息质量保证的操作，用于提升传输效率。</p><p>其实 http 系列协议，都可以看做是在 http1.1 的协议约定基础上，在传输层做优化。 那么，是否有其他通过优化协议本身内容的方式呢？其实其他协议都是在做这件事。例如，<code>websocket</code>，建立在 tcp 之上，使用非常简洁的控制帧，通信消息全在消息体当中。还有一些追求极致性能的协议，甚至直接建立在 TCP 上做应用层消息传输，例如 kafka 的通信协议。</p><p>从 自定义消息结构 这个看待协议的角度出发，我们甚至可以认为 rpc 才是真正的一切协议的源头，可以想象曾经有各类自定义的 rpc 格式，例如 <code>samba</code>、<code>nfs</code>、<code>ssh</code> 等等，当他们具有一定的名气后，大家就把他们从 自定义 rpc 协议 的认识中拎出来，直接用他们的名字代替。也就是说，我们现在所自定义的各种 rpc 协议，当他们具有一定名气后，就可以拥有自己的 名字 。</p><p>阐述完各类协议的基本情况后，我们来聚焦一下 <code>http</code>、<code>http2</code>、<code>grpc</code>、 <code>ws</code> ，看一下他们的关系。</p><h3 id="几种协议的区别认识"><a href="#几种协议的区别认识" class="headerlink" title="几种协议的区别认识"></a>几种协议的区别认识</h3><p>Http 的全名叫 超文本传输协议，是互联网最常用的协议，分为 请求行 (method + path)、请求头 (header) 、请求体 (body)，请求体可以是二进制数据(经过编码传输)。</p><p>http2 是 http 的升级版，所有请求格式延续了 http 的格式，对上层应用来说整体没啥差别(如果仅当做http来用)，但是也提供了 服务端推送、stream 等功能。一定程度上，我们可以认为，http2 是 http 的 传输层封装 (充当 transport 层)。</p><p>grpc 是把 http2 当做传输层 (transport 层)。其他特性是自行实现的，例如 <code>interceptor</code>、<code>resolver</code>、<code>balancer</code>、<code>auth</code>、<code>log</code>、<code>status</code>(状态码)、<code>stats</code>(监控)。实际上，我们不能把 grpc 当做一种协议，而是一种 rpc 框架 (类似于 http 框架)，协议 有特定格式 或 接口约定，而 grpc 是用于生成特定 server 和 client 的一整套工具。</p><p>ws 是直接在 tcp 之上的一层通信协议，特点是 轻量、连接保持，ws的想象空间很大，实际上，如果你愿意，甚至可以使用 ws 作为 http 的 transport 层，也可以把 ws 作为 mqtt 的 transport 层，也可以把 ws 作为 grpc 的传输层。</p><p>一些情况下，我们可以认为，一个协议 或者 一个框架，为什么选择了某项技术 而并不是 其他技术，是由于 生态 决定的，例如为什么 grpc 选用了 http2 而不是直接的 tcp 连接？为什么后端服务调用大家使用 grpc 而不是 手写 http？为什么后端不用 ws 通信？</p><h3 id="ws的特点"><a href="#ws的特点" class="headerlink" title="ws的特点"></a>ws的特点</h3><p>ws 现在的主要场景在前后端的即时消息上，这得益于 ws 的 状态保持 的特性，那么，我们是否可以基于这个特性，做更多的事情？</p><p>比如，① 基于 ws 的 http 协议转换、② 基于 ws 的 grpc 协议转换、③ 基于 ws 的自定义 rpc 框架、④ 基于 ws 的自定义框架。</p><p>对于 ①，应用场景较少，如果是为了传输性能，那么使用 http2 就能解决，而且 http2 的生态更好。<br>对于 ②，可以，但目前已经有了基于 http 的 grpc 协议转换，使用 http2 的情况下，性能也没啥问题。<br>对于 ③，可以，但要考虑生态问题，这基本意味着重新实现整套 grpc 的各模块。<br>对于 ④，可以，但目前已经有一些 ws 框架，例如 socket.io，要考虑清楚为什么需要一套新的框架。</p><h3 id="我对于当前-http-、http2、grpc、ws-方式的基本判断"><a href="#我对于当前-http-、http2、grpc、ws-方式的基本判断" class="headerlink" title="我对于当前 http 、http2、grpc、ws 方式的基本判断"></a>我对于当前 http 、http2、grpc、ws 方式的基本判断</h3><ol><li>http 有完善的接口定义方式 (<code>openapi</code>)，http2 甚至 http3 在性能上和将来的生态上也非常不错。目前没有看到好的基于 http 接口定义 方式自动生产 server 和 client 的工具。</li><li>grpc 有完善的接口定义方式，性能上和生态上很不错，有自动生成代码的工具链。前端调用不支持直接通信，需要经过 http 协议再转一次(浏览器端 或 proxy 端)。</li><li>ws 有一定的生态支持，ws 的状态保持在一些场景下是非常不错的特性。ws 没有自动生成代码的工具。</li></ol><h3 id="ws有什么特殊的价值？"><a href="#ws有什么特殊的价值？" class="headerlink" title="ws有什么特殊的价值？"></a>ws有什么特殊的价值？</h3><p>ws 有两个特性： ① 连接保持  ② 协议轻量 。另外，ws 的生态不错 (主要指浏览器的特殊支持)。<br>ws 在一些需要长链接的场景下，非常有价值，比如： ① 协商缓存内容，② 服务端缓存内容(eg: 权限)</p><p>如果解决 ws 的 ① 重连状态保持  ② http 降级  ③ 代码自动生成  ④ 开发模式  ⑤ 测试工具包 问题，那么 ws 不失为一个很好的通信工具。</p><h2 id="代码生成的思考"><a href="#代码生成的思考" class="headerlink" title="代码生成的思考"></a>代码生成的思考</h2><p>代码生成是一个非常好的思路，可以保证代码的统一性，减少不规范的地方，可维护性更高。现在可以看到，在 client 和 server 代码生成上，grpc 做的是最好的，生态也比较开放，在这个基础上可以开发一些自己需要的功能。</p><p>Go-zero 框架是自己实现的一套语法解析并形成特定代码，提供了模板化的方法生成代码，也和 grpc 一样提供了自定义插件的方式，看上去野心不小。</p><p>Go-kratos 则是接入 grpc 的生态，通过扩展生成代码的方式，接入了自己的 http 和 rpc。</p><p>Go-frame 在接口自动化代码生产上没有动作，只是在 脚手架工具 中简化了 对 grpc 代码生成的命令。</p><p>除了上面说到的 基于接口文档 自动化生成 server 及 client 代码外，还有一些其他常用的可生成的代码：</p><ol><li>基于 数据库表 生成 结构体、orm、基本 crud 代码。</li><li>基于 接口定义，生成前端 client 代码。</li><li>生成部署侧的脚本或包 (docker、k8s、devspace等)</li></ol><p>第 1 点中的 model 生成，go-frame 和 go-zero 都有做。 第 2 点目前只有 go-zero 做了一些，grpc 也有一些。 第 3 点都有动作。</p><p>另外 ，补充一嘴，数据库的结构体生成 是可以 正反使用的，例如，通过 orm，生成数据库表，同样也可以通过 数据库表，生成 orm，这点可以参考 <a href="https://blog.longalong.cn/posts/22_03_21_%E5%85%B3%E4%BA%8E%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81.html">关于基于接口定义的开发流</a> 最后的链接。</p><h3 id="一个疑惑"><a href="#一个疑惑" class="headerlink" title="一个疑惑"></a>一个疑惑</h3><p>按理，http 才是互联网下的王者，那么，为什么很少见到基于 http 的 接口定义文档 自动生成代码的工具呢？</p><p>实际上，相比于 protobuff 的 proto3 这种新的 DSL ，我们使用已有语言的成本可能更低，例如 基于 yaml 或者 基于 json 的，比如使用 openapi 的接口定义。甚至，使用一门我们熟悉的语言做接口描述，例如 js，然后代码生成则直接使用 js 进行拼接 ( 或模板渲染 )。</p><p>这个可以找找是否有相关的工具，如果没有，可以自己实现一个。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>杂七杂八写了一些自己的想法，很多表述不一定很精准，但思路确实还是有可参考性的，可以经常回味一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机的几种通信方式&quot;&gt;&lt;a href=&quot;#计算机的几种通信方式&quot; class=&quot;headerlink&quot; title=&quot;计算机的几种通信方式&quot;&gt;&lt;/a&gt;计算机的几种通信方式&lt;/h2&gt;&lt;p&gt;对于计算机而言，通信 是一件永远不可能被忽视的事情。通信 基本可以分为 进程</summary>
      
    
    
    
    
    <category term="communication" scheme="https://iamlongalong.github.io/longblog/tags/communication/"/>
    
    <category term="backend" scheme="https://iamlongalong.github.io/longblog/tags/backend/"/>
    
  </entry>
  
  <entry>
    <title>服务化演进的一些问题探讨</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_07_19_21_44_some_discuss_about_microservice.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_07_19_21_44_some_discuss_about_microservice.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:24:42.108Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在 go-krotas 的微信群里，看到一哥们儿提问: </p><blockquote><p>在 k8s 中，不理解为啥还需要 registry ? 直接用 service 不就行了吗？</p></blockquote><p>我回答道:</p><blockquote><p>我觉得直接用 service 主要的问题是 扩展性问题。业务上会有各种对服务分组的需求，比如版本、地域等等。 但是四层的负载均衡比较难做到。所以基于注册中心 + subset 的方式就有了生存空间。<br>不过，如果是比较简单的场景，直接用 service 也是够了的。</p></blockquote><p>之后，一哥们儿回到：</p><blockquote><p>把这些需求沉到 istio 运维层，如果你用 registry，那就是开发者自己管了</p></blockquote><p>这个问题其实很多人都会问到，之前和文浩也讨论过这个话题，当时我的想法大概是，把很多东西下沉到 运维层 当然没问题，但实际上这是一个需要看 成本 和 公司阶段 的问题。</p><p>对于一个初期的项目来说，使用最原始的 <code>单体结构</code> 实际上是成本最低的，毕竟一个项目能发展到什么阶段，对于绝大多数项目而言，都是玄学，难以参透，所以 <code>保持软件架构的简洁</code> 是非常重要的。进，可以按模块拆分；退，可以推倒重来；大不了项目一黄，扔掉完事儿。</p><p>当产品流量不错，服务逻辑也开始逐渐膨胀，就该有所规划地进行 模块的解耦设计，表现在代码侧，就是把不同 类型的<code>接口 区分前缀</code>、把实现逻辑<code>独立成包</code>、把 model <code>内联查询拆开</code>等等。</p><p>回到上面的问题，我们又该如何抉择 使用 registry 还是 使用 istio 呢？<br>我认为还是应当比较成本。 isito 等一系列服务治理的体系，在运维上的成本是不低的，如果要用其去替换 registry ，至少需要考虑以下几点：</p><ol><li>我们是否有人才能够做好 istio 的维护 甚至开发？</li><li>假设我们能维护好，那么这套体系是否真的能够降低 业务开发同学的心智负担？<ul><li>使用 registry 的时候，他们需要花多少精力去关注 服务治理 的东西？</li><li>他们是否真的能够做到不用再关心  服务分组(负载均衡)、认证、限流 等等？</li><li>这些价值，是否能 cover 住有专人去维护另一套复杂的体系带来的成本？</li></ul></li></ol><p>不得不说，当我们重新审视完上面几点，就会发现实际上两者很难说谁优谁劣，对小点的公司而言，几乎毫不犹豫选择使用 <code>registry</code> ( 当然，如果业务简单，会毫不犹豫地使用 service  )； 对于很大的公司而言，可能会考虑使用 <code>side car</code> 的流量治理模式；对于中等大小的公司，可能就处于摇摆状态了……</p><p>一个很实际的例子，如果一家原来是用的 dubbo 或者 <code>spring cloud</code> 这一套的公司，他们已经有非常完善的生态了，不论是 服务注册发现 还是 降级限流熔断，或者是 负载均衡策略 等等，本就是业务开发同学应当知道的，成本也没有很高。 和上面说的这一套 ( side car ) 相比，他们又有什么动力转到这个方向上去呢？</p><p>毛剑老师 之前在一场直播中也简要回答过这个问题:  B站几乎是统一语言的(golang)，用的统一的框架( go-kratos )，任何服务治理上的问题，都只需要在框架层改动即可，几乎都是一次性工作，一劳永逸的事。</p><p>总结一下，技术的发展日新月异，<code>云原生</code>、<code>service mesh</code>、<code>side car</code>、<code>istio</code>、<code>服务运行时</code> 等等概念如日中天，甚至于有些年轻人生来就在 微服务 + 云原生 的环境中，认为 <code>单体架构</code> 甚至 <code>SOA</code> 已经是上个时代的产物了。</p><p>诚然，技术的发展给 社会生产力 带来了更高的效率，因此我们应当崇敬技术，应当拥抱新技术，甚至推动新技术的发展。但在工程上时，也需要考虑新技术的场景适用性，对比成本和收益，姑且压制住  技术人对于新技术的好奇和冲动，用更理性的思维去做抉择。</p><p>我实际上也是一个比较有技术人普标性格的人，<code>好奇</code>、<code>爱折腾</code>、<code>喜欢尝试新技术</code>、<code>较真</code>……，之所以会有上面的想法，可能也和一些经历有关。</p><p>公司有一个前端的项目，做的是官网，用的是 nuxt 框架，为的是用 <code>服务端渲染(SSR)</code> 。之后我们有一波比较大型的推广活动，就需要组织各端同学做压测，以保证容量和服务稳定性。这个服务没有太引起我的关注，因为按以往对官网的理解，就是一个静态页，只要资源往 CDN 一扔，啥事儿都不会有。</p><p>但出乎意料的是，组织压测的各小组汇报情况，官网的 qps 到 5k 左右时怎么都上不去了，各 pod 资源利用率也不高，就是不知道啥情况。搞了很久，踩了很多坑，最后还是没解决。</p><p>主要的坑有： </p><ul><li>① 前端同学对压测的工具和流程不熟悉，花费较多时间学习相关操作  </li><li>② 前端同学对在 linux 容器中如何排查问题不熟悉  </li><li>③ 前端同学对服务间调用的网络链路等不熟悉</li><li>④ 基于 vue3 的 nuxt 会有 .mjs 文件格式，这在一些网关或者浏览器中会有坑( 需要设置特定的 mime type )</li><li>⑤ 没有同学能够 hold 住 ssr 的常见问题。</li></ul><p>倒不是在踩前端同学有多菜，我也是从前端转过来的，我明白从日常工作的技能上来看，熟练掌握 linux 操作能进行问题排查 以及 提前预测方案问题 的同学毕竟是更少的。</p><p>后来勉强过了这次活动，总结复盘时，有同学也提出了，官网的场景 似乎 用 全站静态化 + 懒加载 的方式更加合适。 后面听说要改成静态化的方式，不过我也没继续跟了。</p><p>再举一个后端这边的例子。</p><p>我们有一个业务场景，是把 cavas 画布内的各项操作，进行合并，并转发给协同者。这条链路上，我们原来是  一个 <code>消息服务</code>  + 一个 <code>合并服务</code> ，前者处理 <code>客户端连接</code>、<code>鉴权</code>、<code>消息分发</code> 等功能，后者承担 <code>画布数据合并</code> 的功能。</p><p>画布的合并实际上有两个步骤，一个是 索引，用来校验操作的合法性以及落盘，另一个是 合并，用来做真实的数据合并操作。 某一次规划索引的功能时，这个服务被拆成了两个服务，把 索引 和 数据合并 分开了。</p><p>由于我不是直接负责这块儿的，也没有怎么太关注具体的内容。</p><p>后来做压测，我负责这条链路的性能测试 以及 调优工作，才细致地去看了里面的设计与实现，之后也通过压测去验证一些想法，大致的情况是这样的：</p><p>服务被拆分成两个，他们之间通过 <code>kafka</code> 进行异步通信，由于 kafka 消息大小的限制，他们之间使用了 <code>mongodb</code> 做大消息存储；由于 <code>版本的强约束</code>，两个服务之间又用了 mysql 做统一版本管理；由于 <code>索引服务</code> 在一些情况下，需要使用 <code>全量数据</code>，他们之间又提供了 <code>rpc 调用</code>，以获取数据。</p><p>当我去询问这样的价值时，得到的回答是 <code>解耦</code> 、<code>错误隔离</code>、<code>异步提升性能</code> 、<code>定向优化</code> 等等理由…… </p><p>当我表明我的想法，认为他们合在一个进程中更合理时，得到的回答是： 你要更 open 一些、大家都在做微服务，合在一起是<code>反模式的</code>、他们现在运行得很好…… </p><p>可能由于应对这种场景的经验比较欠缺，我一时也不知道该怎么说这事儿。 但我心里非常清楚，合在一起对 <code>性能</code>、<code>稳定性</code>、<code>成本</code>、<code>开发负担</code> 等各方面都有非常大的价值。然后也不管一些反对的声音，花了几个周末的时间，在独立的环境中，对两个服务做合并，做优化，然后做压测…… ，最后的结果是 我所预期的 和 压测的结果 几乎一样，性能提升超过 10 倍，代码删减了接近一半，数据库调用从 4 次 降到 1 次，同样 qps 下，资源占用降低到原来的 40% ……</p><p>后来一次会议上我提出，<code>微服务</code> 是需要遵循一些原则的，我们对微服务的理解不能仅停留在 “微服务” 这个 名词 上，不是所有能拆的服务都该被拆分，至少要基于 <code>DDD</code> 的一些基本原则。</p><p>后来，看到一个架构的设计原则，认为： </p><blockquote><p>我们做系统架构设计，宗旨就是 <code>降低服务复杂性</code> ，复杂性是万恶之源！</p></blockquote><p>这和 istio 从原来的微服务模型 回归到 单体服务时，<a href="https://docs.google.com/document/d/1v8BxI07u-mby5f5rCruwF7odSXgb9G8-C9W5hQtSIAg/edit#heading=h.ra1vuew9eiv1">官方设计文档</a>的第一句话不谋而和</p><blockquote><p><strong>Complexity is the root of all evil or: How I Learned to Stop Worrying and Love the Monolith</strong><br>复杂性是万恶之源，不然我怎么会爱上单体，并且从此不再焦虑呢？</p></blockquote><blockquote><p>更多信息可以参考 <a href="https://blog.christianposta.com/microservices/istio-as-an-example-of-when-not-to-do-microservices/">istio-as-an-example-of-when-not-to-do-microservices</a><br>中文翻译可以参考 <a href="https://www.infoq.cn/article/VtfJLLvqDIOzglwBpqPk">istio 为什么不再使用微服务</a></p></blockquote><p>用一句很让人警醒的话来结束这篇文章，希望我们能以此共勉: </p><blockquote><p>真正的大佬，都是能把复杂问题简单化的人</p></blockquote><hr><blockquote><p>Wisdom begins at the end.<br>— <cite>Daniel Webster</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前两天在 go-krotas 的微信群里，看到一哥们儿提问: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 k8s 中，不理解为啥还需要 registry ? 直接用 service 不就行了吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我回答道:&lt;/p&gt;
&lt;blockq</summary>
      
    
    
    
    
    <category term="devops" scheme="https://iamlongalong.github.io/longblog/tags/devops/"/>
    
    <category term="云原生" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="微服务" scheme="https://iamlongalong.github.io/longblog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="istio" scheme="https://iamlongalong.github.io/longblog/tags/istio/"/>
    
    <category term="服务治理" scheme="https://iamlongalong.github.io/longblog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    <category term="反微服务" scheme="https://iamlongalong.github.io/longblog/tags/%E5%8F%8D%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="microservice" scheme="https://iamlongalong.github.io/longblog/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>记一次有状态服务的负载均衡方案探索</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_3_23_a_record_of_balancing_stateful_service_explore.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:24:54.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的服务是有状态服务，服务在提供对外访问时，需要负载到特定节点。</p><h2 id="基本方案"><a href="#基本方案" class="headerlink" title="基本方案"></a>基本方案</h2><p>一般来说，这种特定节点的负载均衡有两种基本方案：</p><ol><li>重定向</li><li>代理模式</li></ol><p>一起来看一下几个有状态服务的集群处理方式：</p><ul><li>Redis 在 6.0 以前是直接的采用 重定向 的方式，6.0 也提供了集群内代理的模式。 </li><li>Redis 的 codis 版集群，采用的是 代理模式。</li><li>Mycat 数据库代理采用的是 代理模式。</li><li>Mongodb cluster 采用的是 mongos 代理。</li><li>Kafka 采用的是客户端自定义的负载均衡方式，整体来看是 重定向方式 (根据 partition 的位置决定地址)。</li></ul><p>基本可以认为，负载均衡的这两种策略没有太大的优劣之分，只要实现好 client，对业务方来说，区别不大。</p><p>由于代理模式对机器资源的消耗更多，并且将来维护更加复杂，于是我选择先采用 重定向 的策略，这需要有两方面改动：</p><ol><li>所有节点均知道特定的 key 应该到哪一个具体的 节点。</li><li>返回的重定向数据，能够达到正确的节点。</li></ol><p>下面分别解决这两个问题。</p><h2 id="解决负载信息同步问题"><a href="#解决负载信息同步问题" class="headerlink" title="解决负载信息同步问题"></a>解决负载信息同步问题</h2><p>在业务侧，需要通过类似于 注册中心的机制，用于确定不同的 key 对应的 节点地址。这个注册中心有两种可供参考的模式： ① 无状态的包，所有状态通过中央存储( eg: redis/etcd ) 进行共享。② 状态交由特定的服务进行维护，其他 client 通过调用这个服务的接口获取信息。</p><p>第一种方案，类似于 k8s 的设计，所有源信息全在 etcd 中，各模块均通过监听 etcd 中的元信息变化做出自己的动作，这样做的好处是 轻量化，仅需要约定好数据结构即可，不用维护单独的服务，但为避免误用，需要提供 SDK。</p><p>第二种方案，类似于 mongodb 中的 config-server ，所有元信息交由 config-server 维护，其他节点 (mongos)通过本地缓存的方式提升性能。 这种方式的好处在于 权责分明，在没有太多精力维护 sdk 的情况下，这种方式更不容易出错。</p><p>其实，也可以认为还有第三种方案： 去中心化方案。类似于 redis 的集群通信方式，每个节点都存着一份整个集群的信息，并且通过一定的方式保证集群内数据一致性。但这种方式的实现更加复杂，也没有看到有什么更大的价值，暂不考虑。</p><p>在我的基本实现中，采用 抢占式 的模式，用 redis 做状态同步，整个流程类似于 “分布式锁” 的过程，可以达到负载到特定节点的目的，但整体比较粗糙，将来的可扩展性也不是很好。</p><p>不过值得参考的是，该实现中，采用了 redis 的 watch 机制，可以在各节点做本地缓存，有更新后也能更新缓存。这是一个很不错的技术点。</p><p>在将来要实现的版本中，应当是由一个服务来做负载均衡的策略，包括收集节点状态、新节点启动、老节点清理、数据迁移 等操作。 这部分可以更多参考 mongodb 的 config-server 相关设计。</p><p>在保证了注册中心机制后，就是网络路由问题了。</p><h2 id="解决-nginx-定向路由问题"><a href="#解决-nginx-定向路由问题" class="headerlink" title="解决 nginx 定向路由问题"></a>解决 nginx 定向路由问题</h2><p>由于服务是在内网中，也不能将内网服务的 ip 直接暴露在公网上，因此，要有从公网路由到内网特定节点的能力。</p><p>我们目前采用的是 k8s 的部署方式，网关处使用 nginx-ingress 进行路由 和 负载均衡。nginx-ingress 默认提供了 轮询、加权、hash、一致性hash 的负载均衡策略，且 hash 函数不是我们能指定的。因此，这些策略无法满足我们的需求。</p><p>不过 nginx-ingress 提供了自定义负载均衡策略的方式(通过 lua 脚本)，也就意味着我们能够自定义负载均衡策略。</p><p>以下是基本实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- file longbalancer.lua</span><br><span class="hljs-keyword">local</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>)<br><br><span class="hljs-keyword">local</span> string_format = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span><br><span class="hljs-keyword">local</span> ngx_log = ngx.<span class="hljs-built_in">log</span><br><span class="hljs-keyword">local</span> INFO = ngx.INFO<br><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.new</span><span class="hljs-params">(self, backend)</span></span><br>  <span class="hljs-keyword">local</span> o = &#123;<br>    name = <span class="hljs-string">&quot;longbalance&quot;</span><br>  &#125;<br>  o.addrs, o.addrList, o.nums = util.get_addrs(backend.endpoints)<br>  o.eps = util.get_nodes(backend.endpoints)<br>  o.nowLen = <span class="hljs-number">0</span><br><br>  <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br><br>  <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>  <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.sync</span><span class="hljs-params">(self, backend)</span></span><br><br>  <span class="hljs-keyword">local</span> eps = util.get_nodes(backend.endpoints)<br>  <span class="hljs-keyword">local</span> changed = <span class="hljs-keyword">not</span> util.deep_compare(<span class="hljs-built_in">self</span>.eps, eps)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> changed <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  ngx_log(INFO, string_format(<span class="hljs-string">&quot;nodes have changed for backend %s&quot;</span>, backend.name))<br><br>  <span class="hljs-built_in">self</span>.addrs, <span class="hljs-built_in">self</span>.addrList, <span class="hljs-built_in">self</span>.nums= util.get_addrs(backend.endpoints)<br>  <span class="hljs-built_in">self</span>.eps = eps<br>  <span class="hljs-built_in">self</span>.nowLen = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.balance</span><span class="hljs-params">(self)</span></span><br>  <span class="hljs-keyword">local</span> balance_by = ngx.var[<span class="hljs-string">&quot;balance_by&quot;</span>]<br>  <span class="hljs-keyword">if</span> balance_by == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>    balance_by = <span class="hljs-string">&quot;$docdoc&quot;</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> balance_val = util.lua_ngx_var(balance_by)<br><br>  ngx_log(INFO, string_format(<span class="hljs-string">&quot;balance key is : %s, val is : %s&quot;</span>, balance_by,balance_val))<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">self</span>, balance_val)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.getnext</span><span class="hljs-params">(self)</span></span> <br>    <span class="hljs-keyword">local</span> addr = <span class="hljs-built_in">self</span>.addrList[<span class="hljs-built_in">self</span>.nowLen]<br><br>    <span class="hljs-built_in">self</span>.nowLen = <span class="hljs-built_in">self</span>.nowLen + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.nowLen == <span class="hljs-built_in">self</span>.nums <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">self</span>.nowLen = <span class="hljs-number">0</span>    <br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> addr<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.find</span><span class="hljs-params">(self, balance_val)</span></span><br>  <span class="hljs-keyword">local</span> addr<br><br>  <span class="hljs-keyword">if</span> balance_val == <span class="hljs-literal">nil</span> <span class="hljs-keyword">or</span> balance_val == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">or</span> balance_val == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    addr = <span class="hljs-built_in">self</span>.getnext(<span class="hljs-built_in">self</span>)  <br>    <span class="hljs-keyword">return</span> addr<br>  <span class="hljs-keyword">end</span><br><br>  addr = <span class="hljs-built_in">self</span>.addrs[balance_val]<br>  <span class="hljs-keyword">if</span> addr == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>    addr = <span class="hljs-built_in">self</span>.getnext(<span class="hljs-built_in">self</span>)  <br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">return</span> addr<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br><br><span class="hljs-comment">-- file util.lua</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.get_addrs</span><span class="hljs-params">(endpoints)</span></span><br>  <span class="hljs-keyword">local</span> addrs = &#123;&#125;<br>  <span class="hljs-keyword">local</span> addrList = &#123;&#125;<br>  <span class="hljs-keyword">local</span> nums = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">for</span> _, endpoint <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(endpoints) <span class="hljs-keyword">do</span><br>    addrs[endpoint.address] = endpoint.address .. <span class="hljs-string">&quot;:&quot;</span> .. endpoint.port<br>    addrList[nums] = endpoint.address .. <span class="hljs-string">&quot;:&quot;</span> .. endpoint.port<br>    nums = nums + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">return</span> addrs, addrList, nums<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>然后在 balancer.lua 文件中导入 longbalancer 即可。</p><p>另外，为了服务能够使用正确的负载均衡策略，需要在 服务的 ingress 中添加如下注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">nginx.ingress.kubernetes.io/configuration-snippet: |<br>      set $docdoc $arg_insip; # 设置负载均衡参数<br>nginx.ingress.kubernetes.io/load-balance: longbalance  # 选择负载均衡策略<br></code></pre></td></tr></table></figure><p>自此，nginx 拥有了根据特定的参数进行定向路由的能力。<br>[鼓掌 ！ 👏]</p><p>这里实际上是有优化空间的，有两个方向：</p><ol><li>添加 缓存 =&gt; documentID : insip 在nginx进行缓存，没有传 insip 的参数时，先通过缓存判断，没有再走轮询。</li><li>直接接入向 config-server 访问的能力，在网关层直接定位到确定的节点，而不是靠重定向。</li></ol><p>各有优劣，之后再做分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们的服务是有状态服务，服务在提供对外访问时，需要负载到特定节点。&lt;/p&gt;
&lt;h2 id=&quot;基本方案&quot;&gt;&lt;a href=&quot;#基本方案&quot; cl</summary>
      
    
    
    
    
    <category term="load balance" scheme="https://iamlongalong.github.io/longblog/tags/load-balance/"/>
    
    <category term="stateful" scheme="https://iamlongalong.github.io/longblog/tags/stateful/"/>
    
  </entry>
  
  <entry>
    <title>质量保证梳理</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_07_16_20_02_some_thing_about_qa.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_07_16_20_02_some_thing_about_qa.html</id>
    <published>2023-03-05T15:45:00.000Z</published>
    <updated>2023-03-05T13:28:20.439Z</updated>
    
    <content type="html"><![CDATA[<p>对于一些需求的实现，使用checklist的方式，回答清楚每一个跟质量相关的问题，帮助开发人员梳理清楚对于质量保证而言最重要的事是什么，做到质量保证“能落地”。</p><h3 id="问题列表："><a href="#问题列表：" class="headerlink" title="问题列表："></a>问题列表：</h3><h4 id="如何保证质量？"><a href="#如何保证质量？" class="headerlink" title="如何保证质量？"></a>如何保证质量？</h4><p>首先得定义质量，要能对质量进行衡量</p><p>对于一个软件项目而言，质量意味着什么</p><h5 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h5><ul><li>以当前的资源部署下，在业务上，能支撑多少业务量 (tps/qps)？</li><li>最早遇到性能瓶颈的模块是什么 ？</li><li>最简单能解决该性能瓶颈的方法是什么，解决成本怎么样？</li><li>从设计上，需要达到20-100倍的设计标准，当前的方案能否达到目标？</li><li>扩容/缩容的成本如何？</li></ul><h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><ul><li>当前设计是否存在单点故障？</li><li>极端情况下，是否能够正常提供共服务(流量突增、恶意刷接口)？</li><li>节点故障是否会影响到正常使用(部分节点宕机)？</li><li>功能是否具备 feature toggle？</li><li>功能是否具备回滚能力？</li><li>若发生错误，是否能第一时间得到通知？</li><li>若发生错误，是否任何人都能快速定位到问题？</li></ul><h5 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h5><ul><li>预计可能的功能拓展有些什么？可能的功能需要增加哪些内容？</li><li>是否是插件化设计，组件的替换成本如何？</li><li>对于较大的功能模块，是否有比较明显的设计模式说明？</li><li>功能是否具有两个以上的人熟悉，做到维护人员冗余？</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>是否有详细的说明文档、设计文档、沟通文档、项目过程文档？</li><li>是否有针对于项目结构/模块设计/代码风格与他人进行沟通讨论？</li><li>是否有完善的单元测试及集成测试？</li><li>是否进行过技术探讨与反思？例如当前项目的主要问题是什么？解决的优先级是怎样的？当前的解决方案是否具有通用性？能否有所沉淀以成为通用组件？等</li></ul><h4 id="如何用测试来保障质量？"><a href="#如何用测试来保障质量？" class="headerlink" title="如何用测试来保障质量？"></a>如何用测试来保障质量？</h4><p>测试 是更接近实际的一种质量保证手段。</p><h5 id="2-1-如何保证功能的正确性？"><a href="#2-1-如何保证功能的正确性？" class="headerlink" title="2.1 如何保证功能的正确性？"></a>2.1 如何保证功能的正确性？</h5><h6 id="单元测试-集成测试"><a href="#单元测试-集成测试" class="headerlink" title="单元测试/集成测试"></a>单元测试/集成测试</h6><ul><li><p>如何保证(自动化)单元测试的覆盖率</p></li><li><p>学习QA如何写测试用例</p></li><li><p>做测试的代码覆盖率检查</p><h6 id="如何能快速管理集成测试"><a href="#如何能快速管理集成测试" class="headerlink" title="如何能快速管理集成测试"></a>如何能快速管理集成测试</h6></li><li><p>super_test 项目</p></li></ul><h6 id="如何保证集成测试的场景覆盖率"><a href="#如何保证集成测试的场景覆盖率" class="headerlink" title="如何保证集成测试的场景覆盖率"></a>如何保证集成测试的场景覆盖率</h6><ul><li>学习 QA 如何写测试用例</li><li>先以一系列场景为例，实际写一堆用例再来回答这个问题</li></ul><h5 id="2-2-如何保证性能和可扩展性？"><a href="#2-2-如何保证性能和可扩展性？" class="headerlink" title="2.2 如何保证性能和可扩展性？"></a>2.2 如何保证性能和可扩展性？</h5><h6 id="性能测试、故障演练-性能瓶颈"><a href="#性能测试、故障演练-性能瓶颈" class="headerlink" title="性能测试、故障演练(性能瓶颈)"></a>性能测试、故障演练(性能瓶颈)</h6><p>性能测试主要为 <code>单模块性能测试</code> 和 <code>链路集成测试</code></p><p>对于模块的测试，可以先站在基础架构的角度，考虑模块的可扩展性，再站在实际使用的角度，从业务角度测试性能。</p><p>例如，对于messenger的压测，可以先考虑当前使用的 redis、mongo、kafka 的本身的拓展能力，得到在不同流量级别下这些模块的性能。</p><p>然后，考虑 messenger 目前提供的服务内容，针对每个业务内容，进行单独的测试，类似于单接口测试。然后对多接口进行测试，考虑不同接口之间的相互影响因素。</p><p>对于链路压测，需要考虑 1. 链路范围界定 2. mock 服务。(ps: 可以考虑 mock 为正常服务的一个切面)</p><h5 id="2-3-自动化性能测试平台的构想"><a href="#2-3-自动化性能测试平台的构想" class="headerlink" title="2.3 自动化性能测试平台的构想"></a>2.3 自动化性能测试平台的构想</h5><p>对于业务的性能测试，压测的情况越接近于真实业务情况的压测约具有说服力。因此，性能测试是要尽量模拟真实的业务场景。</p><p>但对于一个变化较快的业务，或者一个新的业务，是很难准确估计真实的业务流量模型的。</p><p>这种时候最好的方式是对多个可能的变量进行笛卡尔积，然后对每种情况进行压测。</p><p>举个例子，messenger 可能面临的业务流量模型有很多，其中 总连接数、单个房间人数、房间个数、首页关注人数、changeset 发送频率、changeset 大小、广播消息类型/频率 等都是可能的变量</p><p>例如，平均一个房间10个人，单实例上 100 个房间，总连接 5000 时，用户以 6帧/s 的速度发送 800 byte 大小的 changeset，那么，对于资源的耗用情况如何？</p><p>如果要对每一种情况进行手工压测，那么其成本是巨大的。</p><p>从 do not repeat yourself 的角度出发，这应该是一个可以自动化的流程。</p><p>对于压测人员，需要做的是： 1. 找出约束的变量，配置关注的变量值。 2. 对结果进行分析并做近一步的确认。</p><p>自动化性能测试平台最好是一个可以适应多种场景的通用化平台，支持自定义的压测脚本、自定义的压测报告、自定义的压测策略，</p><p>应该支持多种消息格式，例如 http、https、ws、wss、grpc、mqtt 等。</p><p>对于这个平台的搭建，一定要仔细去分析 jmeter、metersphere 这两个平台的逻辑以及设计。</p><h5 id="2-4-如何保证可靠性？"><a href="#2-4-如何保证可靠性？" class="headerlink" title="2.4 如何保证可靠性？"></a>2.4 如何保证可靠性？</h5><ul><li>  边界测试、极端测试、混沌测试、故障演练(错误故障)</li></ul><h6 id="可以考虑以下内容："><a href="#可以考虑以下内容：" class="headerlink" title="可以考虑以下内容："></a>可以考虑以下内容：</h6><ul><li>  api的边界测试交给中间件来进行。</li><li>  梳理可能的错误点，并考虑故障注入的方式。</li><li>  跳出代码逻辑去考虑错误故障，目标是得到尽可能全的故障类型，并针对每个可能的故障进行故障排查及恢复演练。</li></ul><h6 id="当前最紧要的事："><a href="#当前最紧要的事：" class="headerlink" title="当前最紧要的事："></a>当前最紧要的事：</h6><ul><li>  故障演练的规范化。</li></ul><h5 id="2-5-如何保证用户角度的正确性？"><a href="#2-5-如何保证用户角度的正确性？" class="headerlink" title="2.5 如何保证用户角度的正确性？"></a>2.5 如何保证用户角度的正确性？</h5><ul><li>  视觉感知测试/e2e测试</li></ul><p>e2e测试的成本相对较高，需要测试人员写相应的代码，且每当业务逻辑产生变化，则需要维护这些用例代码。</p><p>视觉感知测试是另一种和e2e测试类似的测试，一般来说不需要写代码，但由于测试是基于“图片对比”的，因此灵活性不如 e2e。</p><p>视觉感知测试的优点是“直观”，在考虑操作录制的情况下，测试人员仅需要对“用例场景”进行定义即可，要求相对较低。</p><h4 id="视觉感知测试怎么做？"><a href="#视觉感知测试怎么做？" class="headerlink" title="视觉感知测试怎么做？"></a>视觉感知测试怎么做？</h4><p>最基础的方式，是进行图片对比，有一系列的操作逻辑，每一步操作后，都有一个截图，用于展示当前操作状态。</p><p>只要一个功能的逻辑没有改动，则特定操作会产生特定的结果。</p><p>只要重复这样的操作逻辑，并对每次的图片进行比对，就能得出特定的结论。</p><p>划分应当以 功能 区分开。</p><p>在某一个功能下，有一些具体的场景。</p><p>每个场景都有特定的操作与逻辑。</p><p>很多场景是相关联的，这些场景应当可以进行参数化配置。</p><p>场景中的很多流程是相似的，这些流程应当可以复用。</p><p>由于运行与截图需要对测试人员透明，因此需要提供录制场景的方法。</p><p>考虑到功能可能频繁变更，因此要增加快速处理比对失败的场景的能力。</p><p>考虑到测试的后台运行属性，因此需要具备报警与通知的功能。</p><p>考虑到素材的可变更性，需要标注可变素材块。</p><p>考虑到h5的布局对内容的影响，可以考虑对于布局的视觉感知测试。</p><h6 id="当前最紧要的事：-1"><a href="#当前最紧要的事：-1" class="headerlink" title="当前最紧要的事："></a>当前最紧要的事：</h6><p>以一个功能需求为实际场景，进行MVP实验</p><h4 id="考虑当前-master-项目的整体质量保证措施"><a href="#考虑当前-master-项目的整体质量保证措施" class="headerlink" title="考虑当前 master 项目的整体质量保证措施"></a>考虑当前 master 项目的整体质量保证措施</h4><ul><li>  以瑞阳牵头的发布流程的保证</li><li>  各小组进行的code review</li><li>  写轮眼项目</li><li>  前端项目的e2e模块</li><li>  后端的api接口自动化测试</li><li>  监控报警</li><li>  基于用户反馈的 oncall 机制</li></ul><p>文档直通车：</p><p><a href="/longblog/posts/22_07_16_20_00_something_about_qa.html" name="关于质量保证的探讨" >关于质量保证的探讨</a></p><hr><blockquote><p>The greatest achievement of humanity is not its works of art, science, or technology, but the recognition of its own dysfunction.<br>— <cite>Eckhart Tolle</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于一些需求的实现，使用checklist的方式，回答清楚每一个跟质量相关的问题，帮助开发人员梳理清楚对于质量保证而言最重要的事是什么，做到质量保证“能落地”。&lt;/p&gt;
&lt;h3 id=&quot;问题列表：&quot;&gt;&lt;a href=&quot;#问题列表：&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="质量保证" scheme="https://iamlongalong.github.io/longblog/tags/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/"/>
    
    <category term="qa" scheme="https://iamlongalong.github.io/longblog/tags/qa/"/>
    
    <category term="quality" scheme="https://iamlongalong.github.io/longblog/tags/quality/"/>
    
    <category term="项目工程" scheme="https://iamlongalong.github.io/longblog/tags/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="质量" scheme="https://iamlongalong.github.io/longblog/tags/%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何搞定一个基础的私有部署环境</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_11_21_21_12_how_to_prepare_a_private_deploy_env.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_11_21_21_12_how_to_prepare_a_private_deploy_env.html</id>
    <published>2023-03-05T05:45:00.000Z</published>
    <updated>2023-03-05T13:44:08.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>私有部署在一些 TOB 的工具型企业中很常见，例如 神策、gitlab 、jira 、飞书 等等。</p><p>要私有部署服务，首先要解决运行环境的问题。</p><p>各企业的情况不同，能提供的环境也不一样。例如，有些企业只能提供物理机，系统随你装；有些企业只能提供特定操作系统的机器；有些企业希望提供 k8s 集群；有些企业提供的硬盘很拉胯；有些网络安全限制得特别严……</p><p>如果我们希望自己的实施同学轻松点，最好是提供一种统一的、不选择平台的部署方案。</p><p>简单场景下，我们可能会想到 docker； 如果有简单的编排需求，我们可能会想到 docker-compose。</p><p>在大多数场景下，我们通过一台硬件条件不错的机器，使用 docker-compose 几乎都能满足需求。</p><p>但如果，客户希望你的服务保证高可用、希望服务具有扩展性、希望…… 好吧，如果你的服务确实很复杂，又不是很稳定(资源抢占……)，确实需要横向扩机器的话……</p><p>那么可以考虑 k8s 集群。</p><h2 id="部署一套-k8s-集群"><a href="#部署一套-k8s-集群" class="headerlink" title="部署一套 k8s 集群"></a>部署一套 k8s 集群</h2><h3 id="简单的集群部署"><a href="#简单的集群部署" class="headerlink" title="简单的集群部署"></a>简单的集群部署</h3><p>之前在 <a href="/longblog/posts/22_07_21_12_45_install_k3s_in_air_gap_air.html" name="网络受限环境k3s安装记录" >网络受限环境k3s安装记录</a> 中记录过离线环境的 k3s 的安装，这只是简单的单个机器的 k3s server 安装，如果要安装集群，还需要在其他节点也做同样的操作，只是最后的命令需要改成 join。</p><p>这种场景，使用 <a href="https://docs.rancher.cn/docs/k3s/autok3s/_index/">autok3s</a> 还是很有优势的。</p><h3 id="稍微复杂一点的集群部署"><a href="#稍微复杂一点的集群部署" class="headerlink" title="稍微复杂一点的集群部署"></a>稍微复杂一点的集群部署</h3><p>当创建的集群节点比较多，且部署必须为离线部署时，则会遇到镜像多处拷贝的问题。解决的思路有两个： </p><ol><li>使用 ansible 工具，将 copy 的过程自动化</li><li>使用 docker-registry 的方式</li></ol><p>这里推荐使用 <a href="https://docs.docker.com/registry/">docker-registry</a>，因为更容易理解。在使用时，先把 docker-registry 的镜像放到 containerd 默认的镜像目录，再把 docker-registry 的 manifest 放到默认的 manifest 下。 </p><p>这样就能解决镜像一处更新的问题了。</p><p>将部署分成两个步骤： ① 创建基础集群  ② 部署业务应用</p><p><a href="http://sealer.cool/zh/">sealer</a> 的理念还是不错的，把集群进行打包，处处运行。 整体类似于 kubeadm 和 helm charts 的集合，以及做了镜像的管理。在一些场景下也是不错的方式。但目前来看，稍微有点 <code>黑盒</code> 了，没有直接使用 helm charts 来得清晰，或者说对实施同学而言，掌控感 略微不足。 对于一些希望使用自由 k8s 集群等情况时，就显得灵活性不足。</p><p>在部署了集群之后，就需要解决 集群管理、应用基础设施、应用部署 的问题。</p><h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><p>集群的管理主要是指：</p><ol><li>节点增删</li><li>集群资源修改</li><li>集群基本信息查看</li></ol><p>这类问题，可以通过一系列的 dashboard 解决，参考 <a href="/longblog/posts/21_12_26_a_record_of_k3s_run_up.html#解决面板及管理工具 和 [[网络受限环境k3s安装记录" name="记一次k3s环境搭建记录" >记一次k3s环境搭建记录</a></p><h2 id="应用基础设施"><a href="#应用基础设施" class="headerlink" title="应用基础设施"></a>应用基础设施</h2><p>应用基础设施，主要指 存储、监控、日志。<br>存储可以参考 <a href="/longblog/posts/22_11_11_20_48_k8s_nfs_storage_class.html" name="nfs、localpath作为k8s-storage-class" >nfs、localpath作为k8s-storage-class</a></p><p>监控的方案主要有两类， promethues 类 和 elastic 类，可以参考 <a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html" name="简单的集群监控方案" >简单的集群监控方案</a></p><p>日志的方案，主要有 ELK 和 EFK 两种常用的 ( logki 体系也可)，我选择 fluentbit，更多信息可以参考 <a href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html" name="简单的集群日志采集方案" >简单的集群日志采集方案</a></p><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><p>终于到了业务应用的部署环节。如果业务是无状态服务，那么很简单，直接找个业务低峰时进行镜像更新即可。如果为有状态服务，没有版本兼容问题还好处理，如果遇到版本不兼容就比较麻烦一点了，需要进行状态清洗或转换的操作。</p><p>私有部署中，针对不同的企业一般有一些独特的配置项，这些配置项需要独立出来。<br>一个常规的 helm charts 编写方式可以参考 <a href="/longblog/posts/22_11_22_00_15_normal_helm_charts.html" name="常规的charts编写方式" >常规的charts编写方式</a></p><p>对于 helm 的操作，可以参考 <a href="/longblog/posts/22_11_03_15_06_simple_usage_of_helm.html" name="helm的一些简单使用" >helm的一些简单使用</a></p><hr><blockquote><p>Don’t settle for a relationship that won’t let you be yourself.<br>— <cite>Oprah Winfrey</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;私有部署在一些 TOB 的工具型企业中很常见，例如 神策、gitlab 、jira 、飞书 等等。&lt;/p&gt;
&lt;p&gt;要私有部署服务，首先要解决</summary>
      
    
    
    
    
    <category term="私有部署" scheme="https://iamlongalong.github.io/longblog/tags/%E7%A7%81%E6%9C%89%E9%83%A8%E7%BD%B2/"/>
    
    <category term="privazation" scheme="https://iamlongalong.github.io/longblog/tags/privazation/"/>
    
  </entry>
  
  <entry>
    <title>如何做好压测</title>
    <link href="https://iamlongalong.github.io/longblog/posts/21_12_02_how_to_do_load_test.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/21_12_02_how_to_do_load_test.html</id>
    <published>2023-03-05T05:45:00.000Z</published>
    <updated>2023-03-05T13:43:49.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压测的目标是什么？"><a href="#压测的目标是什么？" class="headerlink" title="压测的目标是什么？"></a>压测的目标是什么？</h3><p>压测的目标有两个：</p><ol><li>通过对模块的压测，找到模块的性能瓶颈，分析其资源耗用合理性、架构可扩展性，找到优化方向。</li><li>通过对链路的压测，找到链路的性能瓶颈，回答线上资源容量。</li></ol><h3 id="压测的技能栈有什么？"><a href="#压测的技能栈有什么？" class="headerlink" title="压测的技能栈有什么？"></a>压测的技能栈有什么？</h3><p>压测的技能栈要求非常广泛，整体来说，需要具备这些技能：</p><ol><li>测试人员的思维习惯和方法论。找到合适的测试模型，并准备好/管理好这些数据。</li><li>运维人员的对系统的认识。能够根据需要配置合适的系统资源，能够一定程度上进行系统问题排查。</li><li>开发人员的开发能力。往往在数据准备过程、测试过程中，需要有较多的工具类开发。</li><li>数据分析人员的分析能力。在数据准备和压测过程中，需要提前预规划各类指标与数据，用于分析系统状态，有时需要比较强的数据分析能力。</li><li>对业务系统熟悉。能够在一定程度上进行问题排查。</li><li>对常用的中间件熟悉。能够进行常规中间件的性能评估与异常分析，例如 <code>kafka</code>、<code>mongodb</code>、<code>mysql</code>、<code>redis</code> 等。</li></ol><p>具体的技能，需要根据业务情况而定。但也有一些通用的技能：</p><ol><li>工作规划能力。由于压测的工作往往十分庞杂，因此要能规划好工作内容，各个阶段的安排要合理。</li><li>文档书写能力。压测的过程十分庞杂，因此每个阶段的工作都应该有比较好的记录和分析，用于指导下一环节的工作。常写的文档包括： 1.  压测规划书  2. 压测结果记录   3. 压测分析报告  4. 系统结构分析图。</li><li>沟通能力。由于压测涉及到的范围很广，尤其是一个比较大的链路压测时，压测人员基本无法对整个系统有较强的掌控能力，需要 1. 市场/运营人员  2. 模块开发负责人员  3. 运维人员  的参与，因此协调这些人员的工作就会十分重要。</li></ol><h3 id="压测的形态是怎样的？"><a href="#压测的形态是怎样的？" class="headerlink" title="压测的形态是怎样的？"></a>压测的形态是怎样的？</h3><ol><li>压测可以分为基准测试和链路测试。基准测试是对单个模块的压测。链路压测是对一条业务流程的压测。</li><li>对于一个常规的压测流程，应当先对模块进行基准测试，在得到每个模块的性能指标后，再进行链路压测。</li></ol><h3 id="压测的结论有哪些？"><a href="#压测的结论有哪些？" class="headerlink" title="压测的结论有哪些？"></a>压测的结论有哪些？</h3><ol><li>回答压测的模型是怎样的，说明为什么选择这样的压测模型</li><li>回答在目标QPS下，当前的系统瓶颈是什么</li><li>给出压测过程中发现的不合理之处</li></ol><h3 id="压测的流程是怎样的？"><a href="#压测的流程是怎样的？" class="headerlink" title="压测的流程是怎样的？"></a>压测的流程是怎样的？</h3><ol><li>分析业务形态，系统形态</li><li>根据业务需求，确定合适的压测模型</li><li>准备压测环境</li><li>准备压测数据、压测工具</li><li>确定系统可观测性，确定测试终止条件</li><li>压测执行，处理过程中的问题</li><li>根据压测过程，形成压测报告</li><li>根据压测报告进行分析，形成分析报告</li></ol><h3 id="压测的工程化实践"><a href="#压测的工程化实践" class="headerlink" title="压测的工程化实践"></a>压测的工程化实践</h3><p>业务系统的压测(从链路来看)，往往可以分为这两类：</p><ol><li>http 请求</li><li>其他类 TCP 请求</li></ol><p>由于业务系统主要面向用户，因此对于 http 请求的压测是最多的，这也是市场上生态最好的类型。常规的例如 <code>jmeter</code>、<code>locust</code>、<code>k6</code>、<code>PTS</code>、<code>loadrunner</code> ，这是用于系统性压测的工具。另外，在开发人员保障的性能测试中，<code>ab</code> 、<code>wrk</code> 、<code>go-stress-testing</code>  这几个工具被经常使用，用于快速验证。</p><p>其他类的请求相对较少，例如 <code>rpc</code>、<code>websocket</code> 这类。即使有一些实现，但真正结合到业务中时，会发现各种不满足需求。实际上，这类测试最好还是自己根据业务情况写项目实现。</p><p>压测项目是一个比较具有通用性的项目，因此可以考虑将其平台化，但目前来看，在最通用的 http 压测上，是比较容易平台化的，市场上也有很多，例如上面提到的 <code>jmeter</code>、<code>loadrunner</code> 等。不过，市面上的这类工具基本都是用来进行 压力管理 的，而测试计划、测试脚本、测试报告 等方面的管理是比较弱的，因此，也有企业在开始做云端化的压测管理平台，比如 <code>metersphere</code>，现在做得也基本可用了。</p><p>对于接口类的测试，通用性是非常强的，例如和 接口管理 结合，可以实现类似于：<code>自动化生成测试用例</code>、<code>流量录制</code>、<code>测试跟踪(bug管理等)</code>、<code>基于接口测试的性能测试</code>等等。实际上，这些功能 <code>metersphere</code> 也支持了，不过有部分是企业版的(如项目管理平台集成)。</p><p>对于接口类测试，我们当前使用的是自己开发的一个项目 <code>super-apitest</code> ，这个项目的最大亮点在于 基于json的模板化用例 ，这点可以认为和 jmeter 的 jmx 格式类比，不过基于 json 的格式，对开发者更加友好。</p><p>现在这个项目仅有一些简单的功能，例如适配了简单的触发界面、结果报告、结果通知，但想要真正做到平台化，还有非常长的路要走。</p><p>当前来看，这个项目可以在一定程度上进行平台化，主要的功能点有 3 个：</p><ol><li>支持所有用例使用数据库管理 =&gt; 一切演进的前提</li><li>支持测试用例录制 =&gt; 极大简化用例生成方式</li><li>支持测试用例通过率统计 =&gt; 极大增强测试跟踪</li></ol><p>如果做到这 3 点，这个接口测试平台已经基本可用了。</p><p>对于其他类型的功能测试，主要包括</p><ol><li>工具库的单测和覆盖度测试</li><li>模块的功能测试</li><li>非 http 类的接口测试 (例如 rpc、ws、异步消息)</li></ol><p>这些测试基本不具备很好的通用性，平台化的效率比较低，对于这类测试，平台的作用其实主要有:</p><ol><li>测试触发</li><li>测试用例元信息管理</li><li>测试结果展示</li></ol><p>基于此，可以认为，平台仅需要提供特定的接口，由各测试项目自行实现测试触发、测试结果反馈即可。</p><p>对于性能测试，如果全为 http 类接口，则平台化的效率较高，可以直接和 接口测试 模块相结合，由接口测试提供用例，由性能测试模块提供压测控制。</p><p>同样，对于非 http 类接口而言，性能测试的通用性就比较弱了，比如各个项目的性能。那么平台依然可以提供测试管理接口，由平台来做触发和结果采集，实际的测试执行由各业务项目自行处理。</p><h3 id="功能测试和性能测试的关系"><a href="#功能测试和性能测试的关系" class="headerlink" title="功能测试和性能测试的关系"></a>功能测试和性能测试的关系</h3><p>功能测试的目的在于保证功能的正确性，有时会有比较复杂的校验逻辑，测试用例集的组织形式经常为一个功能。</p><p>性能测试的目的在于摸清一些功能或场景的最大(合适)并发度，用于排查性能瓶颈和做线上资源容量规划，校验逻辑往往比较轻量，着重在压力 ，测试用例集的组织形式尝尝是一系列场景，并且十分关注各场景的比例，目的模拟真实用户的请求。</p><h3 id="压测项目的价值有多大"><a href="#压测项目的价值有多大" class="headerlink" title="压测项目的价值有多大"></a>压测项目的价值有多大</h3><p>根据压测的两大目标来看： 1. 发现系统瓶颈，提供优化建议  2. 回答线上容量问题</p><p>对于第 1 点，这是项目开发时需要的，例如开发一个通用的库，需要根据压测的结果进行优化。实际上，这是任何一个开发工程师都需要具备的能力，尤其是写中间件的工程师。</p><p>这种情况下，压测基本上是驱动这个项目进化的源动力之一。也是业务方评判这个项目的优劣及适用性的一个很重要的标准，业界流行的 <code>redis</code>、<code>kafka</code>、<code>mongo</code>、<code>mysql</code>等这类中间件，都是直接在发行版中自带 benchmark 工具。</p><p>对于第 2 个问题，大多数时候需要链路压测。最常见的系统压测是基于 http 这类 “request/response” 的，而这也是测试工程师最常接触的。目标在于找到整个链路的性能峰值。</p><p>毫无疑问，在项目开发过程中，我们需要回答第 1 个问题，而往往这个问题需要研发工程师自己回答。但从实际的情况来看，对于大多数业务场景，这类问题是比较基础的问题，如果项目中有比较高级一些的研发工程师在技术评审时下点功夫，基本就能将这些问题扼杀在摇篮里。</p><p>也就意味着，业务系统做这类压测，原因往往有两个： 1. 技术管理体系不成熟，代码质量得不到保障。 2. 跟其他业务有所关联，需要自证。</p><p>如果要回答第 2 个问题，就需要链路压测，这也是最被大家所熟悉的压测，这类压测往往需要一个团队来执行，主要包含： 1. <code>测试工程师</code>  2. <code>运维工程师</code>  3. <code>研发工程师</code>  4. <code>业务人员(运营/产品)</code>。 在新项目上线、大促活动等情况下，一般需要做这类测试，用于保障线上不会被打垮。</p><h3 id="业界做的比较好的容量是怎样的"><a href="#业界做的比较好的容量是怎样的" class="headerlink" title="业界做的比较好的容量是怎样的"></a>业界做的比较好的容量是怎样的</h3><p>根据一些公开资料，有了解到使用机器学习的方式，得出各条件下对于机器资源的需求量。机器学习的来源，一方面是通过多次(很多)压测得到，另一方面，是通过线上实际数据反馈进行修正。</p><p>这样一套容量的机器学习方案确实是一个不错的选择，尤其是对于业务较多的企业，还是有不错的收益，例如阿里的本地生活就有这么一套。</p><h3 id="性能保障的职责"><a href="#性能保障的职责" class="headerlink" title="性能保障的职责"></a>性能保障的职责</h3><ol><li>由测试人员</li><li>由运维人员(sre)</li><li>由开发人员</li><li>由架构师</li></ol><p>对于常规的 http 请求的压测，可以由测试人员负责，凭借测试人员对业务场景的理解，可以构造出符合需求的测试脚本，再使用特定的压测工具，则可进行压测，压测的结果也比较清晰，可以直接交给相关项目的开发人员去进行接口优化。</p><p>针对特殊项目的压测，和普通意义上我们认为的测试工程师所做的工作不太一样，常规认为的测试工程师，大多凭借对业务场景的理解，加上对测试(功能/性能)工具的掌握，能做针对业务场景的测试/压测。这种项目的性能测试需要对这个项目本身比较熟悉，往往需要自行开发一些压测的工具来进行压测，从上述描述的测试工程师所擅长的技能来看，不能很好匹配。</p><p>对于链路压测，一般来说需要准备的内容比较复杂，包含 <code>压测目标确定</code>、<code>环境准备</code>、<code>压测场景构建</code>、<code>压测脚本</code>、<code>压测过程控制</code>、<code>项目配置/环境配置调整</code>、<code>压测资源监控</code>、<code>压测报告</code>、<code>压测结果分析</code> 等一系列环节。</p><p>这些环节过于复杂，对于任意一个工程师而言，都是几乎无法完成的。因此，往往需要一个团队来配合。团队内的分工大致如下：</p><ol><li>业务人员(产品/运营)，负责压测目标的确定(业务侧视角)。</li><li>测试人员，负责压测场景梳理、压测数据准备(协同研发人员)、压测执行、压测结果收集、压测报告</li><li>研发人员，负责standby问题排查、环境配置调整</li><li>运维人员，负责环境准备、协助排查资源问题</li><li>架构师/高级开发人员，负责压测结果报告分析、优化方案</li></ol><h3 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h3><ul><li><a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html" name="WIP-kafka的高吞吐原因" >WIP-kafka的高吞吐原因</a></li><li><a href="/longblog/posts/22_11_06_01_47_some_thought_of_performance.html" name="压测的一些思考" >压测的一些思考</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/longblog/posts/22_11_06_02_14_knowledges_of_performance.html" name="性能工程的储备知识" >性能工程的储备知识</a></li><li><a href="/notpublish/index.html" name="简单的性能测试方案" >简单的性能测试方案</a></li><li><a href="/longblog/posts/22_11_23_23_02_disk_performance_and_network.html" name="关于磁盘和网络的性能的问题" >关于磁盘和网络的性能的问题</a></li><li><a href="/longblog/posts/22_07_16_a_record_of_service_performance_improve.html" name="记一次服务性能的调优排查" >记一次服务性能的调优排查</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;压测的目标是什么？&quot;&gt;&lt;a href=&quot;#压测的目标是什么？&quot; class=&quot;headerlink&quot; title=&quot;压测的目标是什么？&quot;&gt;&lt;/a&gt;压测的目标是什么？&lt;/h3&gt;&lt;p&gt;压测的目标有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过对模块的压测，找到模块的性能瓶颈，</summary>
      
    
    
    
    
    <category term="压测" scheme="https://iamlongalong.github.io/longblog/tags/%E5%8E%8B%E6%B5%8B/"/>
    
    <category term="load test" scheme="https://iamlongalong.github.io/longblog/tags/load-test/"/>
    
  </entry>
  
  <entry>
    <title>关于质量保证的探讨</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_07_16_20_00_something_about_qa.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_07_16_20_00_something_about_qa.html</id>
    <published>2023-03-04T19:46:00.000Z</published>
    <updated>2023-03-05T13:43:04.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是质量？"><a href="#什么是质量？" class="headerlink" title="什么是质量？"></a>什么是质量？</h2><p>系统质量，首先保证系统的正常运行，包括功能正确、系统稳定性。其次，要保证系统的健壮性，包括系统的容错能力、报警能力、自恢复能力。还要保证系统的可维护性和可扩展性，包括系统功能增加/修改的难易程度、系统横向扩展的能力。</p><h2 id="我们主要关注哪些点？"><a href="#我们主要关注哪些点？" class="headerlink" title="我们主要关注哪些点？"></a>我们主要关注哪些点？</h2><ol><li> 保证正确的业务逻辑</li></ol><p>任意一个功能都是符合业务预期的，覆盖业务所需要的所有场景。</p><ol start="2"><li> 保证可维护性</li></ol><p>考虑功能规划，确保在之后的新业务需求开发时，能流程地接入系统，而不是做trick兼容。</p><p>新老功能的替换时，确保在数据转换上的可实施。</p><p>在新老功能替换时，确保平滑迁移。</p><ol start="3"><li> 保证容错性(健壮性)</li></ol><p>确保程序有充分的错误处理机制，不会出现程序崩溃宕机的情况。</p><p>确保有明确的监控指标和告警措施，能在程序出现问题时第一时间感知。</p><p>确保有明确的应急方案，例如流量切换，降级、熔断，feature toggle等方案</p><ol start="4"><li> 保证可扩展性</li></ol><p>程序的设计尽量是无状态的，可以水平扩展的。</p><p>如果无法做到无状态，就要做到分治，最终达到可以无限扩展的能力。</p><ol start="5"><li> 保证性能</li></ol><p>选择合适的处理流程，能够异步处理的尽量异步，尽量保证主流程上没有较大的阻塞操作。</p><p>尽量保证程序逻辑层面的不冗余，再保证代码结构设计层面的性能优化。</p><p>由于数据库往往是最终瓶颈，因此要始终保持sql的高效，主要是 分页、批量、索引、独立 几个方式。</p><ol start="6"><li> 安全性？</li></ol><h2 id="如何保证："><a href="#如何保证：" class="headerlink" title="如何保证："></a>如何保证：</h2><ol><li> 代码规范(命令规范、职责单一、分层清晰等)</li><li> 写代码时的高标准(设计模式、面向对象、依赖注入、结构清晰)</li><li> 复杂问题的方案设计与review</li><li> 代码质量保证工具(如sonar、go vet)</li><li> 测试(单元测试、接口测试、集成测试、e2e测试、性能测试)</li><li> 不断重构(小步持续性重构)</li></ol><h2 id="如何执行："><a href="#如何执行：" class="headerlink" title="如何执行："></a>如何执行：</h2><ol><li> [代码规范] =&gt; 有规范、有review</li><li> [高要求] =&gt; 梳理流程、整理文档、先设计再执行、拉人探讨</li><li> [方案设计与review] =&gt; 有文档、有review流程</li><li> [代码质量工具] =&gt; CI/CD 步骤</li><li> [不断重构] =&gt; 每个月自查代码问题</li><li> [测试] =&gt; 见下方</li></ol><h4 id="单元测试的要求"><a href="#单元测试的要求" class="headerlink" title="单元测试的要求"></a>单元测试的要求</h4><ol><li> 所有库方法，必须有正确性单元测试用例。</li><li> 复杂的库方法，需要有多种边界情况测试用例。</li><li> 单元测试用例管理直接在当前模块下的 xxx_test.go 文件中。</li></ol><h4 id="接口测试要求"><a href="#接口测试要求" class="headerlink" title="接口测试要求"></a>接口测试要求</h4><p>目的：保证单个接口的输入输出的正确性</p><p>主要内容： 1. 输入值的边界参数传入。 2. 确保输出值的schema。</p><h4 id="集成测试要求"><a href="#集成测试要求" class="headerlink" title="集成测试要求"></a>集成测试要求</h4><p>目的：从用户行为的角度，保证功能的正确性。</p><p>主要内容：</p><ol><li> 从场景出发，进行数据准备。</li><li> 实际测试，对返回值进行断言。</li></ol><h4 id="e2e测试要求"><a href="#e2e测试要求" class="headerlink" title="e2e测试要求"></a>e2e测试要求</h4><ol><li> 重要流程的场景测试，例如，登录、注册、创建team、创建project、打开文档等。</li><li> 可以考虑基于图片对比的测试。(视觉感知测试)</li></ol><h4 id="性能测试要求"><a href="#性能测试要求" class="headerlink" title="性能测试要求"></a>性能测试要求</h4><ol><li> 单服务性能测试</li></ol><ul><li>  将所有服务拆分，对其进行性能测试。</li><li>  将服务的依赖项进行拆分，mock。</li></ul><ol start="2"><li> 集成服务性能测试</li></ol><ul><li>  全链路数据压测，数据准备与压测。</li><li>  数据来源可采用流量录制。</li></ul><ol start="3"><li> 数据库性能测试</li></ol><ul><li>  对业务场景进行数据库操作过程排查</li><li>  对单个sql语句进行查询分析</li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>服务质量的保证主要应当从</p><ol><li> 团队开发人员意识培养</li><li> 团队质量保证规范与流程</li><li> 测试</li></ol><p>这三个方面入手。</p><p>我当前从 测试 入手，主要有以下几个方面的内容：</p><h4 id="完成-api-接口测试框架搭建与开发"><a href="#完成-api-接口测试框架搭建与开发" class="headerlink" title="完成 api 接口测试框架搭建与开发"></a>完成 api 接口测试框架搭建与开发</h4><p>super-test 项目，目标是让团队成员写 <code>接口测试</code> 的难度降低，现在已经做到：</p><ol><li> 使用 json 配置文件进行测试</li><li> 具有简单的测试触发页面</li></ol><h4 id="考虑-websocket-的功能测试"><a href="#考虑-websocket-的功能测试" class="headerlink" title="考虑 websocket 的功能测试"></a>考虑 websocket 的功能测试</h4><p>[TODO]</p><h4 id="考虑-性能测试-框架"><a href="#考虑-性能测试-框架" class="headerlink" title="考虑 性能测试 框架"></a>考虑 性能测试 框架</h4><ol><li> 项目性能</li><li> 中间件性能</li><li> 数据库性能</li></ol><p>文档直通车：<br><a href="/longblog/posts/22_07_16_20_02_some_thing_about_qa.html" name="质量保证梳理" >质量保证梳理</a></p><hr><blockquote><p>A man’s growth is seen in the successive choirs of his friends<br>— <cite>Ralph Waldo Emerson</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是质量？&quot;&gt;&lt;a href=&quot;#什么是质量？&quot; class=&quot;headerlink&quot; title=&quot;什么是质量？&quot;&gt;&lt;/a&gt;什么是质量？&lt;/h2&gt;&lt;p&gt;系统质量，首先保证系统的正常运行，包括功能正确、系统稳定性。其次，要保证系统的健壮性，包括系统的容错能力、报</summary>
      
    
    
    
    
    <category term="质量保证" scheme="https://iamlongalong.github.io/longblog/tags/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/"/>
    
    <category term="qa" scheme="https://iamlongalong.github.io/longblog/tags/qa/"/>
    
    <category term="quality" scheme="https://iamlongalong.github.io/longblog/tags/quality/"/>
    
    <category term="项目工程" scheme="https://iamlongalong.github.io/longblog/tags/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="质量" scheme="https://iamlongalong.github.io/longblog/tags/%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次服务性能的调优排查</title>
    <link href="https://iamlongalong.github.io/longblog/posts/22_07_16_a_record_of_service_performance_improve.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/22_07_16_a_record_of_service_performance_improve.html</id>
    <published>2023-03-04T19:45:00.000Z</published>
    <updated>2023-03-05T13:42:49.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事情起因："><a href="#事情起因：" class="headerlink" title="事情起因："></a>事情起因：</h3><ol><li><p> 某一天，听到浩兄说我们有个告警，是因为 event-tracking 的 cpu 使用超标<br><img src="https://static.longalong.cn/img/warning.png"></p></li><li><p> 我感觉比较奇怪，顺口问了下情况，后来又和 浩兄、窦兄 一起看了下各种监控</p></li></ol><h3 id="查看-cpu、内存、网络-情况"><a href="#查看-cpu、内存、网络-情况" class="headerlink" title="查看 cpu、内存、网络 情况"></a>查看 cpu、内存、网络 情况</h3><p><img src="https://static.longalong.cn/img/asynccode-12.png"></p><p><img src="https://static.longalong.cn/img/asynccode-11.png"></p><p>发现很奇怪，内存和 cpu 是猛增上去的，但网络流量却非常小。</p><p>又听到 浩兄 说当时机器的 socket 连接数被打满了，于是怀疑是 goroutine 的问题，进一步查看 goroutine 监控</p><h3 id="查看-goroutine-监控"><a href="#查看-goroutine-监控" class="headerlink" title="查看 goroutine 监控"></a>查看 goroutine 监控</h3><p><img src="https://static.longalong.cn/img/asynccode-8.png"></p><p>发现确实 goroutine 飙得非常高。 也没多想，怀疑是不是有 for 循环里面起了 协程，导致 goroutine 没控制住？</p><p>于是和 窦兄 一块儿，一通代码查看，……额……，没发现啥问题。</p><p>此事一直耿耿于怀，听相关负责人说，在计划重构 event-tracking ，有点害怕，毕竟私有部署的项目中，我还有些依赖 event-tracking 的 sdk [😱]……</p><p>但由于 ① 没有现场，没法抓各种 profile ② 没有 tracing，不知道究竟卡在哪里了</p><p>毕竟，日志、监控、tracing、pprof 相当于我们的眼睛，没有这些，现在做一切都相当于盲猜……</p><p>为了减轻私有化适配的工作，在浩兄的怂恿下，开始了一番自救操作……</p><h3 id="进一步排查的准备工作"><a href="#进一步排查的准备工作" class="headerlink" title="进一步排查的准备工作"></a>进一步排查的准备工作</h3><ol><li><p> 由于不知道各接口的响应情况，于是初步建了个 metrics 的板子，简单看了下，觉得挖不同接口的响应时长可能没啥意义，这应该是个系统性问题，于是放弃继续做板子，转向其他方向。</p></li><li><p> 由于已经在框架中集成了 tracing 的东西，于是花了半个小时把 event-tracking 的 所有 tracing 接上。(包括 redis、db、kafka、http request)</p></li><li><p> 为了能复现高压力下的场景，在压测机上装了 ab </p></li></ol><h3 id="试下未做调整时的压测情况"><a href="#试下未做调整时的压测情况" class="headerlink" title="试下未做调整时的压测情况"></a>试下未做调整时的压测情况</h3><h4 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h4><p>并发 200， qps 54</p><p><img src="https://static.longalong.cn/img/asynccode-2.png"></p><p><img src="https://static.longalong.cn/img/asynccode-10.png"></p><p>tracing </p><p><img src="https://static.longalong.cn/img/20220716105356.png"></p><p>有四个表现奇怪的地方：</p><ol><li><p> 负载非常不均衡，必定有鬼</p></li><li><p> nginx 到 pod 的时间居然达到数秒</p></li><li><p> Pod 内 produce kafka 的时间 居然和 整个请求的时长一样</p></li><li><p> 在 kafka 队列中，居然卡了这么长时间</p></li></ol><h4 id="先怀疑下-kafka-实例的问题"><a href="#先怀疑下-kafka-实例的问题" class="headerlink" title="先怀疑下 kafka 实例的问题"></a>先怀疑下 kafka 实例的问题</h4><p>kafka 监控 </p><p><img src="https://static.longalong.cn/img/asynccode-6.png"></p><p>就这点量，远远达不到 kafka 的瓶颈，跳过。</p><h4 id="怀疑下-是不是代码中用了-同步发送"><a href="#怀疑下-是不是代码中用了-同步发送" class="headerlink" title="怀疑下 是不是代码中用了 同步发送"></a>怀疑下 是不是代码中用了 同步发送</h4><p><img src="https://static.longalong.cn/img/asynccode.png"></p><p>看来并不是，排除。</p><h4 id="怀疑一下-ikafka-包的问题"><a href="#怀疑一下-ikafka-包的问题" class="headerlink" title="怀疑一下 ikafka 包的问题"></a>怀疑一下 ikafka 包的问题</h4><p>此时发现 ikafka 没有接 metrics ，于是看了下之前写的文档，想把 ikafka 的 metrics 接上。</p><p>然后发现 我想接的是 sarama ，但 ikafka 没有暴露 metrics 出来，也没有把 sarama 的 metrics 接口暴露出来，无果……</p><p>这个问题留到之后再怀疑吧</p><h4 id="怀疑一下-kafka-的配置问题"><a href="#怀疑一下-kafka-的配置问题" class="headerlink" title="怀疑一下 kafka 的配置问题"></a>怀疑一下 kafka 的配置问题</h4><p><img src="https://static.longalong.cn/img/asynccode-1.png"></p><p>果然，看到了一个问题，consumer 的 队列数 居然仅设置了 1 ，这岂不是意味着，消息只能一条条从 kafka 取回来？那不得老慢了……</p><p>另外，看到没有开 autocommit，于是也顺手加上。<br><img src="https://static.longalong.cn/img/20220716105438.png"></p><p>ok，这下顺眼多了。其他也不知道咋样，先压一波试下吧。</p><h3 id="调整-channel-size-后的压测"><a href="#调整-channel-size-后的压测" class="headerlink" title="调整 channel size 后的压测"></a>调整 channel size 后的压测</h3><p>刚准备压的，看了一眼 grafana ，懵了…… </p><p><img src="https://static.longalong.cn/img/asynccode-4.png"></p><p>啥情况？？？ Cpu 直接被拉满了？？？</p><p>吓得我反手就抓了一波 pprofile</p><p><img src="https://static.longalong.cn/img/asynccode-9.png"></p><p>发现居然有大量的 park 方法的调用，这显然就是 goroutine 疯狂切换导致的问题啊。</p><p>按以往的经验，很有可能是 for 循环中的 select 不是全阻塞的。此时跑去搜了一圈 <code>for</code> 的代码。没发现问题，每个 for 循环都还比较规范……</p><p>于是回来接着看 pprofile，注意到 左边 kafka 的调用，按理，这是属于底层包的调用啊，应该不会有啥问题啊。</p><p>跟了一圈代码，由于是直接的 cgo 调用，也很难继续追下去了。</p><p><img src="https://static.longalong.cn/img/origin_img_v2_e59df2f5-be93-4e16-8749-3f500e19ab9g.jpg"></p><p>想到之前 confluent 给我留下的奇奇怪怪的印象 (主要是因为黑盒问题)，再加上对 sarama 做过比较仔细的源码阅读，想着既然 confluent 不好调试，换成 sarama 先试试吧……</p><h3 id="切换-sarama-后的压测"><a href="#切换-sarama-后的压测" class="headerlink" title="切换 sarama 后的压测"></a>切换 sarama 后的压测</h3><p>并发 200， qps 940</p><p><img src="https://static.longalong.cn/img/asynccode-3.png"></p><p>grafana 监控</p><p><img src="https://static.longalong.cn/img/asynccode-7.png"></p><p>时间分布合理</p><p><img src="https://static.longalong.cn/img/asynccode-5.png"></p><p>打完   收工 ！</p><h3 id="结局："><a href="#结局：" class="headerlink" title="结局："></a>结局：</h3><ol><li><p> Event-tracking 的性能问题至少算是解了</p></li><li><p> 如果需要的话，可以再去整理下 confluent 的正确打开方式 ( 还是算了…… ，直接用 sarama 或者 kafka-go 不香吗 )</p></li><li><p> 公共包最好还是提供一些统一的 metrics 接口、提供统一的 tracing 设置</p></li><li><p> 对于我们现在大多数的业务场景，1c 的 cpu 支撑个 1000qps 问题是不大的，大家可能需要更新下对性能的感性认识</p></li></ol><hr><blockquote><p>There are two kinds of failures: those who thought and never did, and those who did and never thought.<br>— <cite>Laurence J. Peter</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事情起因：&quot;&gt;&lt;a href=&quot;#事情起因：&quot; class=&quot;headerlink&quot; title=&quot;事情起因：&quot;&gt;&lt;/a&gt;事情起因：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 某一天，听到浩兄说我们有个告警，是因为 event-tracking 的 cpu 使用超标&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简单的集群监控方案</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html</id>
    <published>2023-02-14T17:04:00.000Z</published>
    <updated>2023-02-23T03:46:32.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于一个 saas 应用来说，面向的是广大用户，广大用户可能在任意一个时间点访问服务，因此，服务的高可用就变得非常重要了，用指标衡量的话，也就是 SLA (Service Level Agreement 服务等级保障)。</p><p>SLA 由两部分组成： 指标定义 + 目标 (SLI + SLO)(indicator + objective) 。具体的指标和目标根据不同的服务而定。对于一个系统的可用性，一般有一个很直观的指标：<code>1 - 当年宕机时长/当前总时长</code>，大家平常说的服务可用性为 2 个 9、3 个 9、4 个 9 基本值的都是这个。 </p><p>指标，也就是这套体系中的基石了，指标的采集、指标是否健康的判断、异常之后的告警 组成了监控体系。</p><h2 id="常用的指标体系"><a href="#常用的指标体系" class="headerlink" title="常用的指标体系"></a>常用的指标体系</h2><p>“服务可观测性” 方面，我们一般有 3 个方向： log、metrics、tracing。 指标也一样，绝大多数指标都是从这三个方向中得出来的。</p><p>本文中我们暂不讨论 metrics 的细节，也不讨论 log 和 tracing 系统，一些 log 系统的信息可以参考 <a href="/longblog/posts/22_11_12_00_17_simple_ways_in_log_collect_in_k8s.html" name="简单的集群日志采集方案" >简单的集群日志采集方案</a> ，tracing 体系之后再聊吧。 本文着重于实践搭建一套简单实用的集群监控体系。</p><p>经典的 metrics 体系是 <a href="https://prometheus.io/docs/introduction/overview/">prometheus</a> + <a href="https://grafana.com/docs/">grafana</a>，这也是大多数互联网同学熟悉的体系。 prometheus 作为一个 metrics 数据采集器 + tsdb 存储引擎 + promql 查询语句，能很好地满足 metrics 使用的需求。 之前在 <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a> 也对 prometheus 做了一些代码层的研读。</p><p>实际上 metrics 存储和查询体系，从技术实现来看并不是特别难。我觉得 prometheus 最大的成功在于 <a href="https://prometheus.io/docs/operating/integrations/">生态</a> 。其一，它有比较完整的 client SDK，各语言都能很方便地集成；其二，它有齐全的工具链，采集、存储、查询、面板； 其三，它很好地实现了对 k8s 、service mesh 等的集成，云原生领域占了先机。</p><p>另外 一些常用的监控系统有:  zabbix、open-falcon、Nagios、datadog 等。 各有一些优劣，空了的话可以再进一步了解下。</p><p>prometheus 竞品中有一个比较有意思的身影: ELK，对，就是那个大名鼎鼎的日志系统。 他们的方案是 <a href="https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-overview.html">metricsbeat</a> + elasticsearch + <a href="https://www.elastic.co/cn/kibana/">kibana</a> 。</p><p>官方也有和一些竞品的对比： <a href="https://prometheus.io/docs/introduction/comparison/">官方对比文档</a></p><p>我们就选用 prometheus + grafana 的方案进行后续的实操了。</p><h2 id="监控项"><a href="#监控项" class="headerlink" title="监控项"></a>监控项</h2><p>一般而言，我们的架构体系中都会把软件系统分为这么几层：</p><ul><li>基础设施层 (机器、虚拟机、网络、磁盘、集群等)</li><li>基础服务层 (数据库、缓存、队列、配置中心、注册/调度中心、网关等)</li><li>应用层 (业务应用)</li></ul><blockquote><p>当然，从更广泛的视角看，业务本身可以作为一层，主要关注业务指标相关的东西，例如注册量、转化率、用户路径等等。 这类指标被直接成为 <code>业务指标</code> ，一般不融入到技术的监控中来，主要采用的方案是 <code>埋点上报</code> + <code>BI 平台</code>，这方面的内容也非常丰富，只有可以专门梳理一下。</p></blockquote><p>prometheus 的生态非常好，除了非常具体的业务监控外，其他几乎都有对应的开源监控项。</p><ul><li>基础设施：<ul><li>node: <a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></li><li>process: <a href="https://github.com/ncabatoff/process-exporter">https://github.com/ncabatoff/process-exporter</a></li><li>network: <a href="https://github.com/syepes/network_exporter">https://github.com/syepes/network_exporter</a></li></ul></li><li>k8s 集群： <ul><li><a href="https://github.com/kubernetes/kube-state-metrics">https://github.com/kubernetes/kube-state-metrics</a></li><li><a href="https://github.com/google/cadvisor">https://github.com/google/cadvisor</a></li></ul></li><li>基础服务：<ul><li>es: <a href="https://github.com/prometheus-community/elasticsearch_exporter">https://github.com/prometheus-community/elasticsearch_exporter</a></li><li>pg: <a href="https://github.com/prometheus-community/postgres_exporter">https://github.com/prometheus-community/postgres_exporter</a></li><li>java: <a href="https://github.com/prometheus/jmx_exporter">https://github.com/prometheus/jmx_exporter</a></li><li>redis: <a href="https://github.com/oliver006/">https://github.com/oliver006/</a></li><li>nginx: <a href="https://github.com/nginxinc/nginx-prometheus-exporter">https://github.com/nginxinc/nginx-prometheus-exporter</a></li><li>mongodb: <a href="https://github.com/percona/mongodb_exporter">https://github.com/percona/mongodb_exporter</a></li><li>gitlab-ci: <a href="https://github.com/mvisonneau/gitlab-ci-pipelines-exporter">https://github.com/mvisonneau/gitlab-ci-pipelines-exporter</a></li><li>haproxy: <a href="https://github.com/prometheus/haproxy_exporter">https://github.com/prometheus/haproxy_exporter</a></li><li>kafka-lag: <a href="https://github.com/seglo/kafka-lag-exporter">https://github.com/seglo/kafka-lag-exporter</a></li><li>kafka: <a href="https://github.com/redpanda-data/kminion">https://github.com/redpanda-data/kminion</a></li><li>kafka: <a href="https://github.com/danielqsj/kafka_exporter">https://github.com/danielqsj/kafka_exporter</a></li><li>ssl: <a href="https://github.com/ribbybibby/ssl_exporter">https://github.com/ribbybibby/ssl_exporter</a></li><li>gin: <a href="https://github.com/zsais/go-gin-prometheus">https://github.com/zsais/go-gin-prometheus</a></li><li>ping: <a href="https://github.com/czerwonk/ping_exporter">https://github.com/czerwonk/ping_exporter</a></li><li>nats: <a href="https://github.com/nats-io/prometheus-nats-exporter">https://github.com/nats-io/prometheus-nats-exporter</a></li><li>influxdb: <a href="https://github.com/prometheus/influxdb_exporter">https://github.com/prometheus/influxdb_exporter</a></li><li>rocketmq: <a href="https://github.com/apache/rocketmq-exporter">https://github.com/apache/rocketmq-exporter</a></li><li>airflow: <a href="https://github.com/epoch8/airflow-exporter">https://github.com/epoch8/airflow-exporter</a></li><li>pagespeed: <a href="https://github.com/foomo/pagespeed_exporter">https://github.com/foomo/pagespeed_exporter</a></li><li>ov: <a href="https://github.com/kumina/openvpn_exporter">https://github.com/kumina/openvpn_exporter</a></li><li>logstash: <a href="https://github.com/BonnierNews/logstash_exporter">https://github.com/BonnierNews/logstash_exporter</a></li><li>zk: <a href="https://github.com/dabealu/zookeeper-exporter">https://github.com/dabealu/zookeeper-exporter</a></li></ul></li></ul><p>上面这些只是自己扒的 github 得到的，其实官方文档已经维护了一份更全的了： <a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></p><ul><li>业务指标<ul><li>框架指标<ul><li>http 请求状态指标</li><li>ws 事件请求量、消息大小 histgram</li></ul></li><li>中间件使用指标<ul><li>kafka 消息情况 (可看 <a href="/longblog/posts/23_02_16_10_56_why_kafka_is_so_efficient.html#应用中的经验" name="WIP-kafka的高吞吐原因" >sarama metrics 指标</a>)</li><li>数据库的连接情况、请求耗时等</li></ul></li><li>业务特性的指标<ul><li>eg: 登录失败人数</li></ul></li></ul></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="二进制部署"><a href="#二进制部署" class="headerlink" title="二进制部署"></a>二进制部署</h3><p>在机器上搭建 prometheus 很简单，直接一个 二进制就起来了。</p><ul><li>二进制的下载 <a href="https://prometheus.io/download/">可以从这里找</a></li><li>配置 可以参考<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">官方文档</a><ul><li>最简单的只用配 global 和 scrape_config 即可</li><li>如果要做告警，则要配置 <a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">rules</a> 和 <a href="https://prometheus.io/docs/alerting/latest/configuration/">alertManager</a>，告警的消息需要用 <a href="https://prometheus.io/docs/prometheus/latest/configuration/template_examples/">模板</a> 来实现</li><li>如果要和 k8s 集成 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config">service discovery</a>，需要为 prometheus 创建 role 和 rolebinding (ns、svc、ep、pod、node、ing 等的 list、watch)</li></ul></li></ul><h3 id="k8s-部署"><a href="#k8s-部署" class="headerlink" title="k8s 部署"></a>k8s 部署</h3><p>使用 <a href="https://github.com/prometheus-operator/prometheus-operator">prometheus-operator</a> , 这是对应的 <a href="https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack">helm charts</a> 。<br>这是<a href="https://prometheus-operator.dev/">官方文档</a></p><h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><ul><li><a href="https://github.com/prometheus/alertmanager">https://github.com/prometheus/alertmanager</a> (官方告警服务)</li><li><a href="https://github.com/samber/awesome-prometheus-alerts">https://github.com/samber/awesome-prometheus-alerts</a> (常用的 alerts)</li><li><a href="https://github.com/feiyu563/PrometheusAlert">https://github.com/feiyu563/PrometheusAlert</a></li><li><a href="https://www.aiops.com/docs/ca/">https://www.aiops.com/docs/ca/</a></li><li><a href="https://github.com/pppscn/SmsForwarder">https://github.com/pppscn/SmsForwarder</a> (短信接码)</li></ul><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><p>在监控</p><h2 id="文档直通车"><a href="#文档直通车" class="headerlink" title="文档直通车"></a>文档直通车</h2><ul><li><a href="/longblog/posts/22_11_06_00_54_health_check_and_monitor.html" name="WIP-健康检查与监控梳理" >WIP-健康检查与监控梳理</a></li><li><a href="/notpublish/index.html" name="promethues的一些信息" >promethues的一些信息</a></li><li><a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li></ul><h2 id="不错的资料"><a href="#不错的资料" class="headerlink" title="不错的资料"></a>不错的资料</h2><ul><li><a href="https://github.com/roaldnefs/awesome-prometheus">https://github.com/roaldnefs/awesome-prometheus</a> (信息聚合，非常不错)</li><li><a href="https://github.com/crazy-canux/awesome-monitoring">https://github.com/crazy-canux/awesome-monitoring</a> (信息聚合，非常不错)</li><li><a href="https://exporterhub.io/">https://exporterhub.io/</a> (有几个中间件的监控资料聚合的社区)</li><li><a href="https://zhuanlan.zhihu.com/p/34005738">https://zhuanlan.zhihu.com/p/34005738</a> (grafana 使用技巧)</li><li><a href="https://prometheus.io/docs/practices/naming/">https://prometheus.io/docs/practices/naming/</a> (prometheus 官方最佳实践)</li><li><a href="https://zhuanlan.zhihu.com/p/563799358">https://zhuanlan.zhihu.com/p/563799358</a> (grafana panel 发送图片 实践)</li><li><a href="https://github.com/IzakMarais/reporter">https://github.com/IzakMarais/reporter</a> (grafana dashboard to pdf)</li><li><a href="https://github.com/zuchka/grafana-awesome">https://github.com/zuchka/grafana-awesome</a></li><li><a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a> (grafana 社区看板)</li><li><a href="https://github.com/starsliao/Prometheus">https://github.com/starsliao/Prometheus</a> 一哥们儿做的基础设施管理平台</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 梳理一下业务指标体系建设</li><li><input disabled="" type="checkbox"> grafana 的具体实践流程走一次<ul><li><input disabled="" type="checkbox"> sso 配置、看板导入导出、权限设置</li></ul></li></ul><hr><blockquote><p>I know where I’m going and I know the truth, and I don’t have to be what you want me to be. I’m free to be what I want.<br>— <cite>Muhammad Ali</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;对于一个 saas 应用来说，面向的是广大用户，广大用户可能在任意一个时间点访问服务，因此，服务的高可用就变得非常重要了，用指标衡量的话，也</summary>
      
    
    
    
    
    <category term="operation" scheme="https://iamlongalong.github.io/longblog/tags/operation/"/>
    
    <category term="monitor" scheme="https://iamlongalong.github.io/longblog/tags/monitor/"/>
    
    <category term="云原生" scheme="https://iamlongalong.github.io/longblog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="k8s" scheme="https://iamlongalong.github.io/longblog/tags/k8s/"/>
    
    <category term="promethues" scheme="https://iamlongalong.github.io/longblog/tags/promethues/"/>
    
  </entry>
  
  <entry>
    <title>如何白嫖存储空间</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_02_15_00_18_use_oss_for_file_backup.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_02_15_00_18_use_oss_for_file_backup.html</id>
    <published>2023-02-14T16:18:00.000Z</published>
    <updated>2023-02-15T13:44:13.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>手机中文件越来越多，空间越来越少，因此想找一个可用于文件备份的存储空间。</p><h2 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h2><h3 id="最简单的方案"><a href="#最简单的方案" class="headerlink" title="最简单的方案"></a>最简单的方案</h3><p>直接购买手机厂商提供的云盘，同步即可。</p><p>优点： 简单，方便，可预览。<br>缺点： 要花钱，长期来看还不便宜，私密性得不到保证。</p><h3 id="简单的方案"><a href="#简单的方案" class="headerlink" title="简单的方案"></a>简单的方案</h3><p>买一块硬盘，将手机中的文件转移到硬盘中。</p><p>优点： 私密性<br>缺点： 要花钱( 比买云盘便宜些，1T在500-1000元，5-10年都还ok )，硬盘坏了就 gg 了</p><h3 id="穷人的方案"><a href="#穷人的方案" class="headerlink" title="穷人的方案"></a>穷人的方案</h3><ul><li>参考 <a href="/longblog/posts/21_12_02_a_nas_solution_used_by_poor.html" name="穷人才会用的nas方案" >穷人才会用的nas方案</a></li></ul><h3 id="白嫖事儿还多的人的方案"><a href="#白嫖事儿还多的人的方案" class="headerlink" title="白嫖事儿还多的人的方案"></a>白嫖事儿还多的人的方案</h3><p>需求有这么几点：</p><ul><li>绝对不能花钱，10 块钱都不行！！</li><li>安全必须要保障，文件不能说丢就丢了！</li><li>私密性必须要保障，不想让自己的文件有泄漏的风险！</li><li>方便，使用起来要方便！</li></ul><p>梳理梳理思路啊：</p><p>第一，不能花钱，那就只有白嫖了，嫖谁呢？阿里云不行，虽然有 9 块钱 40g 一年的套餐，但终究要花钱啊，而且超过 40g 想扩展就很贵了。腾讯云、华为云也差不多。七牛云在认证了之后有 10G 的免费存储空间，可以嫖，但容量有限。</p><p>似乎专门做存储的不好搞，那不是专门做存储的怎么样呢？公共存储？</p><p>阿里云盘在经过一段时间发展，现在也还不错，目前不限速，容量还挺大，我现在就有 1.5T 左右的空间。但将来不好说，毕竟现在想吃一点百度的市场，不盈利谁会白做网盘呢。</p><p>阿里云盘可以考虑下抓一下接口，看看能怎么搞成自动化，作为一个备选方案还 ok。</p><p>还有谁有公共存储呢？似乎各大内容平台都有？主要是用来存各种静态资源的，比如图片啥的。 dockerhub 的公开镜像倒是可以无限免费存。 github 的公开仓库也可以免费存。 这里面的想象空间就比较大了 🐶 。</p><p>另一个思路是 p2p，公开的 p2p 存储节点，可以再调研看看。</p><p>第二，要保证安全，有两方面要考虑，① 尽量保证数据不会损坏 ② 尽量保证数据有多份冗余 。</p><p>如果要用公共存储，那就要考虑第一点尽量少发生，例如，不会因为长久未使用被删掉、被压缩、被处理……，不会因为平台关闭导致数据丢失。 </p><p>多份冗余，多存几份咯，可以通过分块、副本的方式保证冗余，俗话说，鸡蛋不能放到同一个篮子里~</p><p>第三，私密性。 不用说，就是加密。</p><p>第四，方便。 考虑一些使用场景，比如，文件的预览、打开、恢复、删除、迁移 等操作要能够很方便地进行。</p><h2 id="整体的思路"><a href="#整体的思路" class="headerlink" title="整体的思路"></a>整体的思路</h2><h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><ul><li>github</li><li>dockerhub</li><li>阿里云盘</li><li>阿里云 docker hub?</li></ul><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><ul><li>密钥加密</li><li>三方认证加密 (openid + salt)</li></ul><h3 id="冗余方式"><a href="#冗余方式" class="headerlink" title="冗余方式"></a>冗余方式</h3><ul><li>切分 block</li><li>多平台冗余存储</li><li>增量更新，不删老数据 (公共存储很多不提供 delete 操作)</li></ul><h3 id="便利性"><a href="#便利性" class="headerlink" title="便利性"></a>便利性</h3><ul><li>专属应用进行管理</li><li>提供缩略图<ul><li>pdf 可以参考 <a href="https://gist.github.com/alamsal/bdfa7528cc9bd291e527">python-pdf-thumbnail</a></li><li>word、txt</li><li>ps、sketch 等</li></ul></li><li>一系列小文件可采用文件夹打包的方案</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>把 <a href="/longblog/posts/21_12_02_a_nas_solution_used_by_poor.html" name="穷人才会用的nas方案" >穷人才会用的nas方案</a> 做一个升级，看看能怎么变成一套超级自动化的方案。</li><li>继续梳理公共存储的方案，形成一套可用的工具。</li></ol><hr><blockquote><p>It is the province of knowledge to speak, and it is the privilege of wisdom to listen.<br>— <cite>Oliver Wendell Holmes Jr.</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;手机中文件越来越多，空间越来越少，因此想找一个可用于文件备份的存储空间。&lt;/p&gt;
&lt;h2 id=&quot;方案分析&quot;&gt;&lt;a href=&quot;#方案分析&quot;</summary>
      
    
    
    
    
    <category term="oss" scheme="https://iamlongalong.github.io/longblog/tags/oss/"/>
    
    <category term="backup" scheme="https://iamlongalong.github.io/longblog/tags/backup/"/>
    
  </entry>
  
  <entry>
    <title>golevelDB源码走读</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_02_11_18_15_code_reading_of_go_leveldb_and_others.html</id>
    <published>2023-02-11T10:15:00.000Z</published>
    <updated>2023-02-14T02:17:17.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><ul><li><a href="https://github.com/syndtr/goleveldb">https://github.com/syndtr/goleveldb</a> (lsm)</li><li><a href="https://github.com/flower-corp/lotusdb">https://github.com/flower-corp/lotusdb</a> (lsm &amp; b+, using bbolt)</li><li><a href="https://github.com/timtadh/fs2">https://github.com/timtadh/fs2</a> (b+ &amp; list)</li><li><a href="https://github.com/philippgille/gokv">https://github.com/philippgille/gokv</a> (kv abstract)</li><li><a href="https://github.com/flower-corp/rosedb">https://github.com/flower-corp/rosedb</a>  (bitcask)</li><li><a href="https://github.com/etcd-io/bbolt">https://github.com/etcd-io/bbolt</a> (b+, 很牛)</li><li><a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a> (etcd, 基于 bbolt)</li></ul><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul><li>levelDB 采用 LSM tree，具体的存储文件采用 sstable 格式</li><li>levelDB 是一个单机应用，且没有配备 server 和 client，相当于 sqlite 的模式</li><li>rocksDB 是以 levelDB 为基础的分布式 kv server</li><li>Google BigTable，HBase，RocksDB，Apache Cassandra 都是基于 LSM tree 的数据库</li><li>chrome 的 indexDB 也是基于 levelDB 的 (或者参考？)</li><li>其实 prometheus 也是同样的模型 <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li><li>对于一些嵌入式场景，或者一些 有状态 server，都可以用 levelDB 做 kv 存储</li><li><a href="https://github.com/ideawu/ssdb">SSDB</a> 是基于 levelDB 的 kv 存储，提供了 client-server ，并实现了 redis 的接口，可以用 redis client 实现很多功能，还是很有前途的。 </li><li><a href="https://riak.com/assets/bitcask-intro.pdf">bitcask</a> 是类 LSM tree 的方案，具体的存储上，采用了 hashmap 的方式，<a href="https://github.com/roseduan/rosedb">rosedb</a> 就是采用这种方案，并且也实现了 redis 的接口。</li></ul><h2 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h2><p>不得不说，用两个字形容 goleveldb 的代码： 非常简洁！</p><ul><li><input disabled="" type="checkbox"> 需要再细看一下 memdb 的具体实现</li><li><input disabled="" type="checkbox"> 需要再细看一下 compact 的具体实现</li></ul><p>看看别人的笔记，写得多好啊：</p><ul><li><a href="https://www.jianshu.com/p/750c7ea9b88c">https://www.jianshu.com/p/750c7ea9b88c</a> (levelDB)</li><li><a href="https://www.jianshu.com/p/a4ce176f11ce">https://www.jianshu.com/p/a4ce176f11ce</a> (levelDB)</li><li><a href="https://www.jianshu.com/p/798c457412d7">https://www.jianshu.com/p/798c457412d7</a> (levelDB)</li><li><a href="https://www.jianshu.com/p/82c0a55f8b92">https://www.jianshu.com/p/82c0a55f8b92</a> (levelDB)</li><li><a href="https://mp.weixin.qq.com/s/s8s6VtqwdyjthR6EtuhnUA">https://mp.weixin.qq.com/s/s8s6VtqwdyjthR6EtuhnUA</a> (rosedb 作者)</li><li><a href="https://blog.csdn.net/ws1296931325/article/details/86635751/">https://blog.csdn.net/ws1296931325/article/details/86635751/</a> (sstable)</li><li><a href="https://zhuanlan.zhihu.com/p/415799237">https://zhuanlan.zhihu.com/p/415799237</a> (lsm tree)</li><li><a href="https://zhuanlan.zhihu.com/p/490963897">https://zhuanlan.zhihu.com/p/490963897</a> (lsm tree)</li><li><a href="https://developer.hashicorp.com/vault/tutorials/monitoring/inspect-data-boltdb">https://developer.hashicorp.com/vault/tutorials/monitoring/inspect-data-boltdb</a> ( hashicorp 的 vault 项目实例 )</li><li><a href="https://zhuanlan.zhihu.com/p/332439403">https://zhuanlan.zhihu.com/p/332439403</a> ( bboltdb，看看别人是怎么写源码导读的 ) <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html#你想要什么？" name="prometheus代码走读" >如何把读源码价值最大化</a></li></ul><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><ul><li>嵌入式场景下的数据库选型</li></ul><hr><blockquote><p>Happiness mainly comes from our own attitude, rather than from external factors.<br>— <cite>Dalai Lama</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/syndtr/goleveldb&quot;&gt;https://gi</summary>
      
    
    
    
    
    <category term="code reading" scheme="https://iamlongalong.github.io/longblog/tags/code-reading/"/>
    
    <category term="源码阅读" scheme="https://iamlongalong.github.io/longblog/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="levelDB" scheme="https://iamlongalong.github.io/longblog/tags/levelDB/"/>
    
    <category term="LSM tree" scheme="https://iamlongalong.github.io/longblog/tags/LSM-tree/"/>
    
  </entry>
  
  <entry>
    <title>alertmanager等监控项目源码走读</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_02_09_15_15_code_reading_of_alert_manager.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_02_09_15_15_code_reading_of_alert_manager.html</id>
    <published>2023-02-09T07:14:00.000Z</published>
    <updated>2023-02-20T06:18:52.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做私有部署的监控告警方案，由于我们线上用的是 promethues + alert manager + grafana 的方案，为了保持方案一致性，也使用了这套方案。</p><p>但在梳理需求的过程中，发现了一些其他的应用，具体可以查看:</p><ul><li><a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html" name="简单的集群监控方案" >简单的集群监控方案</a></li><li><a href="/longblog/posts/22_11_06_00_54_health_check_and_monitor.html" name="WIP-健康检查与监控梳理" >WIP-健康检查与监控梳理</a></li></ul><p>其中，发现 <a href="github.com/megaease/easeprobe">easeprobe</a> 和 <a href="https://github.com/sourcegraph/checkup">checkup</a> 这两个项目还挺有意思，这和我们平常所认识的： promethues 、 zabbix、open-falcon、Nagios、datadog 等等不同。 这两个项目都是面向简单环境下的检查，很轻量，都是一个配置文件 + 一个二进制文件 即可运行起来。</p><p>在这里对 alertmanager 、easeprobe 、 checkup 做一次源码走读，看看有些什么可以借鉴的。</p><h2 id="整体认识"><a href="#整体认识" class="headerlink" title="整体认识"></a>整体认识</h2><p>对于监控告警而言，整体来说有这么几个核心概念：</p><ul><li>监控探测</li><li>探测数据存储</li><li>数据检查规则</li><li>告警分发<ul><li>告警组</li><li>告警渠道</li></ul></li><li>辅助系统<ul><li>api server</li><li>fontend admin page</li></ul></li></ul><p>以上是一个监控告警系统的核心环节，当然，在这之上可以添加很多辅助系统，例如用户系统、权限系统 等等。</p><h2 id="代码走读"><a href="#代码走读" class="headerlink" title="代码走读"></a>代码走读</h2><h3 id="alertmanager"><a href="#alertmanager" class="headerlink" title="alertmanager"></a>alertmanager</h3><h4 id="代码层级主体职能"><a href="#代码层级主体职能" class="headerlink" title="代码层级主体职能"></a>代码层级主体职能</h4><ul><li><p>cmd</p><ul><li>amtool<ul><li>这是 cli 的入口文件，详情可查看 cli 目录</li></ul></li><li>alertmanager<ul><li>这是 server 的直接入口文件</li><li>做一系列的初始化，例如： nflog(详见 nflog 目录)、cluster (详见 cluster 目录)、slience (详见 slience 目录)、mem provider (详见 provider 目录)、dispatch、api server (详见 api 目录)</li></ul></li></ul></li><li><p>config</p><ul><li>配置的 model，主要有 route (分发路由)、notifier (通知渠道)</li></ul></li><li><p>dispatch</p><ul><li>实现了 route 和分发逻辑。两个循环，① 循环接收 alerts  ② 对每一个 alert 循环判断是否需要分发到 route。</li><li>聚合了 route(aggrGroup)、provider.Alerts、notify.Stage 等实例。</li></ul></li><li><p>api</p><ul><li>api server 的实现</li><li>restapi : 做了一个 http server 的封装，我们一般使用现成的框架，例如 gin、echo 等等。  <ul><li>api： 具体业务接口的实现。</li><li>operations： 做了一些 params 和 response 的定义，看起来感觉实际意义不大。</li></ul></li><li>models : 接口的模型，做了 Validate 和 marshal 的逻辑，我们一般使用 tag 的方式做 validate，使用 http 框架提供的 bind 等做 marshal 操作。</li><li>client: 实际的 service 接口，业务方可直接使用作为 client sdk。</li></ul></li><li><p>notify</p><ul><li>通知的具体实现，有很多通知类型，写一些通知工具的时候可以参考： email、discord、opsgenie、pushover、slack、sns、telegram、webex、wechat……</li><li>扩展很方便，仅需要实现 Notify 接口即可。</li></ul></li><li><p>provider</p><ul><li>alerts 的暂存和分发，目前仅有 mem 的实现。</li></ul></li><li><p>store</p><ul><li>存储的实际实现，主体为一个 map 结构，有 gc。 provider 的 mem 中存的也是这个。</li></ul></li><li><p>silence</p><ul><li>静默的实现</li></ul></li><li><p>types</p><ul><li>几个公共的 model</li></ul></li><li><p>cluster</p><ul><li>集群实现</li></ul></li><li><p>cli</p><ul><li>提供一系列 cli 命令，主要是用于和 server 交互的，例如 添加告警、添加静默、获取状态 等等。</li><li>使用的 <a href="https://github.com/alecthomas/kingpin">alecthomas/kingpin</a> cli 框架，我们平常用的是 cobra。</li></ul></li><li><p>timeinterval</p><ul><li>自己实现了一个时间周期判断器</li></ul></li><li><p>asset</p><ul><li>用的 github.com/shurcooL/httpfs 把静态资源打包到二进制文件中，保证了启动服务的简单。</li></ul></li><li><p>nflog</p><ul><li>每隔一段时间把接收到的 notify 情况进行 log 存储，用 proto 定义了 entry，存的也是 protocal buffer。</li></ul></li><li><p>ui</p><ul><li>管理面板的实现，前端项目，最后会打包到 assets 中。这种模式很方便，可以参考。</li></ul></li><li><p>把 proto 作为 model 使用</p><ul><li>cluster</li><li>nflog</li><li>slience</li></ul></li><li><p>使用二进制文件存数据</p><ul><li>nflog</li></ul></li><li><p>在网上看到这个，觉得不错</p></li></ul><p><img src="https://static.longalong.cn/img/20230220141634.png"></p><h3 id="easeprobe"><a href="#easeprobe" class="headerlink" title="easeprobe"></a>easeprobe</h3><ul><li>channel : 消息通道，用来绑定探测和通知的</li><li>cmd : 服务的入口，做配置解析、绑定探测器、绑定通知 等等</li><li>conf : 全局的配置定义</li><li>daemon : 做 pidfile 管理，避免重复启动，没有重启能力</li><li>eval : 结果解析器，有 JSON、xml、text、html 等解析器，可以定义更丰富的结果判断方法</li><li>global : 定义一些全局变量</li><li>metric : 对接 promethues 指标</li><li>notify : 消息通知渠道，有很多种通知，可以参考<ul><li>base : 所有 notify 公共的字段和方法，继承 和 实现接口 是两种很通用的多态方式。</li></ul></li><li>probe : 探针的逻辑，最核心的部分<ul><li>data : 使用全局变量，保存所有探针结果。 status 为探针得出的结论。stat 为每次探测的记录。result 为当前探针的结果，包括了 status 和 stat 以及 探针本身的信息。</li><li>base : 探针的主题逻辑，使用 Config(probeFuc) 的方式实现多态，由各种探测方式自行进行探测，并返回结果给 base。</li></ul></li><li>report : 拼接各种报告模板</li><li>web : 提供 metrics 采集 和 报告获取接口</li></ul><p>整个服务实现得很简单清晰，很值得参考，主要有 ① 全局 config 的定义  ② 探针和 notify 的多态实现。</p><h3 id="checkup"><a href="#checkup" class="headerlink" title="checkup"></a>checkup</h3><ul><li>check : 提供了一些检查方式，有 http、tcp、tls、dns，还有 exec</li><li>cmd : 命令的入口文件<ul><li>采用了 cobra 的命令行框架</li><li>提供了几种执行探测的方式</li><li>serve : 提供了 web 服务，具体的前端代码在 statuspage 中</li></ul></li><li>notifier : 几种通知的方式<ul><li>每次检测 (每次检测可配置多次测试)，如果有错误就进行通知</li></ul></li><li>storage : 提供了多种存储方式，可用文件存储，也可用 sql 存储</li><li>types : 一些 model 的定义</li><li>checkup.go、notifier.go、storage.go 都是一些 model 的定义</li></ul><p>这个工具非常简单，把几个部分都拆得特别干净，相互没有依赖，也没有全局依赖，和上面两个不同的是，它完全采用了 无状态 设计，这让它可以实现分布式部署，所有数据都汇总到一个独立的地方，再对数据做聚合。</p><blockquote><p>吐槽一下，界面还是有点…… 🤦🏻‍♀️</p></blockquote><h2 id="简单思考"><a href="#简单思考" class="headerlink" title="简单思考"></a>简单思考</h2><p>这几个项目都比较简单，在梳理清楚 <code>工具的目标</code> 之后，实施起来实际上都不会特别麻烦。</p><p>但不同的开发者，看问题的视角和开发习惯都不完全相同，因此也有一些编程技巧是可以借鉴和学习的。</p><h3 id="你想得到什么？"><a href="#你想得到什么？" class="headerlink" title="你想得到什么？"></a>你想得到什么？</h3><p>这些都只是工具而已，看过了一遍代码也就过去了，关键还是得知道： 你究竟想得到什么？是否有战略目标？是否能把自己看到的这些东西融入到自己的一套体系中？</p><p>我希望得到：</p><ol><li>企业级业务系统可直接使用的监控方案</li><li>小项目可直接使用的监控方案</li></ol><h3 id="后续-TODO"><a href="#后续-TODO" class="headerlink" title="后续 TODO"></a>后续 TODO</h3><ul><li><del>走读 pushgateway 代码</del> <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li><li><del>走读 prometheus 代码</del> <a href="/longblog/posts/23_02_09_23_45_code_reading_of_prometheus.html" name="prometheus代码走读" >prometheus代码走读</a></li><li><del>走读 prometheus client go 代码</del> (简单看了下，没什么特别说的)</li><li><del>完全走一次 promethues 的监控告警流程</del> <a href="/longblog/posts/23_02_15_01_04_easy_monitor_of_k8s_cluster.html#二进制部署" name="简单的集群监控方案" >简单的集群监控方案</a></li><li>梳理在具体业务中使用 easeprobe 的场景<ul><li>考虑家用场景</li><li>考虑看板 和 ui 平台的价值</li></ul></li></ul><hr><blockquote><p>This is the final test of a gentleman: his respect for those who can be of no possible value to him.<br>— <cite>William Lyon Phelps</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做私有部署的监控告警方案，由于我们线上用的是 promethues + alert manager + grafana 的方案，为了保</summary>
      
    
    
    
    
    <category term="code reading" scheme="https://iamlongalong.github.io/longblog/tags/code-reading/"/>
    
    <category term="源码阅读" scheme="https://iamlongalong.github.io/longblog/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="源码" scheme="https://iamlongalong.github.io/longblog/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="alertmanager" scheme="https://iamlongalong.github.io/longblog/tags/alertmanager/"/>
    
    <category term="monitor" scheme="https://iamlongalong.github.io/longblog/tags/monitor/"/>
    
    <category term="easeprobe" scheme="https://iamlongalong.github.io/longblog/tags/easeprobe/"/>
    
    <category term="checkup" scheme="https://iamlongalong.github.io/longblog/tags/checkup/"/>
    
  </entry>
  
  <entry>
    <title>WIP-改变意味着什么？</title>
    <link href="https://iamlongalong.github.io/longblog/posts/23_02_01_08_22_what_is_change.html"/>
    <id>https://iamlongalong.github.io/longblog/posts/23_02_01_08_22_what_is_change.html</id>
    <published>2023-02-01T00:21:00.000Z</published>
    <updated>2023-02-01T03:38:53.742Z</updated>
    
    <content type="html"><![CDATA[<p>人人都知道，唯有改变才能带来新事物，想到达理想的彼岸，只有通过改变现状，持续朝着彼岸前进。</p><p>但我们真的理解 改变 意味着什么吗？</p><p>改变意味着 朝着理想目标在前进<br>改变意味着 打破现状<br>改变意味着 与原有的 行为习惯 和 思维习惯 做斗争<br>改变意味着 你需要放弃现在拥有的一些东西</p><p>“得到” 和 “放弃” 是 “改变” 的一体两面，没有放弃也就不会有得到。</p><p>做好心理准备分为两个方面，一方面是指 “能接受所放弃的东西”，另一方面，是指”能接受没有获得期待的东西”。</p><p>如果没有做好心理准备，就会在短暂的改变过程中，被”意外”的失去打个措手不及，导致一次改变之旅被扼杀在襁褓中。</p><p>刨去外在环境的差异，绝大多数人在底层的潜力都是差不多的，是否能发挥出这份潜力，取决于内外两方面，整体而言有两种典型模式：</p><ul><li><p>外在环境带动改变</p></li><li><p>内在核心驱动改变</p><p>  两种模式不是割裂的，可以同时具备，也可能同时不具备</p></li></ul><p>驱动力有两种，同样，阻力也有两种：</p><ul><li>外在环境的阻力</li><li>内在思维和习惯的阻力</li></ul><p>人们期待改变，但往往又不能接受改变带来的副产物，所以又会尽可能阻碍改变。 这是人生常态，也是阻碍人转变的重要原因。</p><p>看到窈窕淑女、肌肉猛男，我们都想拥有其所带来的好处，但是否考虑过得到它的代价 以及 它的副产物呢？</p><p>改变，意味着你在期待能得到好处的同时，也要能够接受其带来的副产物。</p><p>举一些例子：</p><p>你想拥有很强的技术，那你是否愿意舍弃休息时间？是否愿意死磕一些基础知识？是否愿意探索可能没有任何收益的问题？<br>你想成为牛逼的作家，是否愿意接受很长时间没有收入或收入很低？是否愿意接受大量时间处于沉思状态而不是娱乐？是否愿意接受一系列你可能无法接受的观点？是否愿意接受可能成为疯子？<br>你想成为肌肉猛男，是否愿意接受早起运动？是否愿意长期接受缺盐少油的食物？是否愿意接受肌肉的疼痛？</p><p>用一个不大恰当的比喻： 爱屋及乌<br>也如魔兽中所言：那么古尔丹，代价是什么？</p><p>要想改变，就要梳理清楚这些问题：</p><ul><li>改变的意义是什么？</li><li>改变有哪些动力？</li><li>改变有哪些阻力？</li></ul><p>进而可以逐个击破：</p><ul><li>明白自己想要的是什么？为什么想要？</li><li>明白自己可以借助哪些力量达成目标？</li><li>明白哪些问题会阻碍我们前进，又能如何解决？</li></ul><p>实际案例：<br>我自己的例子，想要获得内心的平静，寻找意义的过程中，就会经历 观念轰炸，娱乐压缩，持续非舒适区。</p><p>其他思考：</p><ul><li>我如何能应用这套 改变的框架 去实现改变？</li><li>如何把用这套框架进行改变的过程进行作品化，并扩大影响力？</li><li>作为”金手指”的一部分，如何让其发挥更大的作用？进行更广泛的实践？</li></ul><p>文档直通车：</p><ul><li><a href="/longblog/posts/23_01_31_13_25_the_way_to_build_habit.html" name="习惯的养成方法论" >习惯的养成方法论</a></li><li><a href="/notpublish/index.html" name="习惯养成列表" >习惯养成列表</a></li><li><a href="/notpublish/index.html" name="习惯养成的另一个隐藏破坏者" >习惯养成的另一个隐藏破坏者</a></li><li><a href="/notpublish/index.html" name="以案例分析和练习为主的学习方法论" >以案例分析和练习为主的学习方法论</a></li></ul><hr><blockquote><p>To do all that one is able to do, is to be a man; to do all that one would like to do, is to be a god.<br>— <cite>Napoleon</cite></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人人都知道，唯有改变才能带来新事物，想到达理想的彼岸，只有通过改变现状，持续朝着彼岸前进。&lt;/p&gt;
&lt;p&gt;但我们真的理解 改变 意味着什么吗？&lt;/p&gt;
&lt;p&gt;改变意味着 朝着理想目标在前进&lt;br&gt;改变意味着 打破现状&lt;br&gt;改变意味着 与原有的 行为习惯 和 思维习惯 做斗</summary>
      
    
    
    
    
    <category term="改变" scheme="https://iamlongalong.github.io/longblog/tags/%E6%94%B9%E5%8F%98/"/>
    
    <category term="习惯" scheme="https://iamlongalong.github.io/longblog/tags/%E4%B9%A0%E6%83%AF/"/>
    
    <category term="成长" scheme="https://iamlongalong.github.io/longblog/tags/%E6%88%90%E9%95%BF/"/>
    
    <category term="金手指" scheme="https://iamlongalong.github.io/longblog/tags/%E9%87%91%E6%89%8B%E6%8C%87/"/>
    
  </entry>
  
</feed>
